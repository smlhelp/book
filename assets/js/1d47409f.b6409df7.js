"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[1936],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=l(n),d=i,h=c["".concat(p,".").concat(d)]||c[d]||m[d]||r;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8269:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:3},o="Trees",s={unversionedId:"concepts/recursion/tree",id:"concepts/recursion/tree",title:"Trees",description:"By Len Huang, August 2020. Rewritten by Thea Brick, July 2023",source:"@site/docs/concepts/recursion/tree.md",sourceDirName:"concepts/recursion",slug:"/concepts/recursion/tree",permalink:"/book/docs/concepts/recursion/tree",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Other Types of Induction",permalink:"/book/docs/concepts/recursion/induction"},next:{title:"Tail Recursion",permalink:"/book/docs/concepts/recursion/tail"}},p={},l=[{value:"Inductive Intuition Revisited",id:"inductive-intuition-revisited",level:2},{value:"An Exploration of Tree Sums",id:"an-exploration-of-tree-sums",level:2},{value:"1. Solving for the Base Cases",id:"1-solving-for-the-base-cases",level:3},{value:"2. Define the Inductive Hypothesis",id:"2-define-the-inductive-hypothesis",level:3},{value:"3. Assume the Inductive Hypothesis to Show the Inductive Step.",id:"3-assume-the-inductive-hypothesis-to-show-the-inductive-step",level:3},{value:"QED",id:"qed",level:2}],u={toc:l};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"trees"},"Trees"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"By Len Huang, August 2020. Rewritten by Thea Brick, July 2023")),(0,i.kt)("p",null,"As we've seen, there is strong association between mathematical induction and\nrecursion, especially in SML. This association extends beyond the types of\ninduction we've seen with integers and lists, but also into more complex\n",(0,i.kt)("inlineCode",{parentName:"p"},"datatypes"),"."),(0,i.kt)("h2",{id:"inductive-intuition-revisited"},"Inductive Intuition Revisited"),(0,i.kt)("p",null,"Recall that induction proofs can fall along the following line of logic:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Case and solve the ",(0,i.kt)("strong",{parentName:"li"},"base cases"),"."),(0,i.kt)("li",{parentName:"ol"},"Case on the ",(0,i.kt)("strong",{parentName:"li"},"inductive case")," or ",(0,i.kt)("strong",{parentName:"li"},"inductive step")),(0,i.kt)("li",{parentName:"ol"},"Define the ",(0,i.kt)("strong",{parentName:"li"},"inductive hypothesis"),"."),(0,i.kt)("li",{parentName:"ol"},"Assume the correctness of the ",(0,i.kt)("strong",{parentName:"li"},"inductive hypothesis")," to show the\ncorrectness of the ",(0,i.kt)("strong",{parentName:"li"},"inductive step"),".")),(0,i.kt)("p",null,"This idea can be generalized to many ",(0,i.kt)("inlineCode",{parentName:"p"},"datatype"),"s that we can write in SML."),(0,i.kt)("p",null,"For instance, consider a ",(0,i.kt)("inlineCode",{parentName:"p"},"datatype tree = Empty | Node of tree * int * tree"),".\nOur rules now extend to have multiple ",(0,i.kt)("strong",{parentName:"p"},"inductive hypotheses"),"! One assuming the\ntheorem for the left tree and another for the right tree."),(0,i.kt)("p",null,"We can similarly apply this line of logic to solving problems with SML\nfunctions! Let's take a look at a common recursive problem. ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum")," takes an\n",(0,i.kt)("inlineCode",{parentName:"p"},"int tree")," and returns the sum of all the integers in that tree. By the end of\nthis, we'll be able to implement recursive functions with the following\ninductive logic:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The ",(0,i.kt)("strong",{parentName:"p"},"base case")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum")," is that an ",(0,i.kt)("inlineCode",{parentName:"p"},"Empty")," tree has a sum of 0. Let's\ndefine the ",(0,i.kt)("strong",{parentName:"p"},"inductive hypothesis")," to be that for ",(0,i.kt)("strong",{parentName:"p"},"some")," tree ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", that\n",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum")," is correct for its left subtree and right subtree. Define my\n",(0,i.kt)("strong",{parentName:"p"},"inductive step")," to be for a tree ",(0,i.kt)("inlineCode",{parentName:"p"},"T = Node(L,x,R)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"L")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," are\nsome arbitrary trees, and ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is some arbitrary number. By the definition of\ntrees, I know that all integers in ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," are represented by the integers in ",(0,i.kt)("inlineCode",{parentName:"p"},"L"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"R"),", and the integer ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),". If I sum all of these, I will get ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum(T)"),". By\nassuming the ",(0,i.kt)("strong",{parentName:"p"},"IH"),", I can say that ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum L")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum R")," are correct.\nTherefore, by math, I will say that\n",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum T = (treeSum L) + (treeSum R) + x")," is correct by the above reasoning.\nAs such, I've shown my ",(0,i.kt)("strong",{parentName:"p"},"IS")," to be correct, and thus the theorem that\n",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum T")," is correct for all ",(0,i.kt)("inlineCode",{parentName:"p"},"T : int tree"),".")),(0,i.kt)("h2",{id:"an-exploration-of-tree-sums"},"An Exploration of Tree Sums"),(0,i.kt)("p",null,"Let's define ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum"),". This function should take in an ",(0,i.kt)("inlineCode",{parentName:"p"},"int tree")," and return\nthe sum of all the integers in that tree."),(0,i.kt)("p",null,"Note that in SML, the ",(0,i.kt)("inlineCode",{parentName:"p"},"tree")," datatype is recursively defined. This is a good\nhint that we should be using recursive/inductive strategies to approach this\nproblem. Consider the proof of the following theorem:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Theorem:")," For all ",(0,i.kt)("inlineCode",{parentName:"p"},"T : int tree"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum T")," is correct.")),(0,i.kt)("p",null,"Let's not worry about formalizing this proof too much so that we can focus on\nthe ",(0,i.kt)("strong",{parentName:"p"},"inductive intuition")," of it. If we were to prove this using induction,\nwe'll need a ",(0,i.kt)("strong",{parentName:"p"},"(1) base case, (2) induction hypothesis, and (3) induction step.")),(0,i.kt)("h3",{id:"1-solving-for-the-base-cases"},"1. Solving for the Base Cases"),(0,i.kt)("p",null,"Let's first think about proving the base case: ",(0,i.kt)("inlineCode",{parentName:"p"},"T = Empty"),". What does it mean\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum Empty")," to be correct? Well, an ",(0,i.kt)("inlineCode",{parentName:"p"},"Empty")," tree does not have any\nnodes, and if there are no nodes, there are no ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," values. The sum of nothing\nis 0. Let's write that in a proof-like manner:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Base Case:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"T = Empty")),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"treeSum(Empty)")," ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mo",{parentName:"mrow"},"\u27f9")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\Longrightarrow")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.549em",verticalAlign:"-0.024em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},"\u27f9")))))," ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," because an ",(0,i.kt)("inlineCode",{parentName:"p"},"Empty")," int tree does not\nhave an int value, so the sum must be ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),".")),(0,i.kt)("p",null,"That wasn't so bad! If we have an empty node, we can't have a value there, and\nso the sum is 0. Before we move on to solving the recursive step, let's tie in\nthis idea of how recursion and induction are related. In our proof, we say that\n",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum Empty")," is correct when it evaluates to 0. Let's use this as an answer\nto how to define the base case of our function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"fun treeSum (Empty : int tree): int = 0\n")),(0,i.kt)("p",null,"Nice job! We've leveraged inductive reasoning to help us define the base case\nfor our recursive problem. Let's move on to something a little harder and may\nbe less obvious than what we've done here."),(0,i.kt)("h3",{id:"2-define-the-inductive-hypothesis"},"2. Define the Inductive Hypothesis"),(0,i.kt)("p",null,"The next step in our proof is to define the inductive hypothesis. Here, as we've\ndone before, we'll assume the correctness of a smaller part, then use that to\nprove the correctness of a bigger part. More specifically, we'll be using some\nideas of structural induction for this problem. Let's elaborate more on that:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Induction Hypothesis:")," Assume for some arbitrary values ",(0,i.kt)("inlineCode",{parentName:"p"},"L : int tree")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"R : int tree")," that ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum L")," is correct and ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum R")," is correct.")),(0,i.kt)("p",null,"Because we've shown our base case to be true, let's assume tha for the recursiv\nstructures (the left subtree ",(0,i.kt)("inlineCode",{parentName:"p"},"L")," and the right subtree ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),"), ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum")," is\ncorrect. Just like how in induction we can use these nuggets of information to\nhelp us prove our ",(0,i.kt)("strong",{parentName:"p"},"inductive step"),", we can do the same to help us solve the\nSML function."),(0,i.kt)("h3",{id:"3-assume-the-inductive-hypothesis-to-show-the-inductive-step"},"3. Assume the Inductive Hypothesis to Show the Inductive Step."),(0,i.kt)("p",null,"What nuggets of information do we know from the previous step, and how can we\nuse that to help us with inductive step? We assume that both ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum L")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum R")," are correct by the ",(0,i.kt)("strong",{parentName:"p"},"inductive hypothesis (IH)"),". Since they are\ncorrect, their outputs represent the sum of all the integers in them. For\n",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum L")," is the sum of all integers in the int tree ",(0,i.kt)("inlineCode",{parentName:"p"},"L")," and for ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum R"),"\nis the sum of all integers in the int tree ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),"."),(0,i.kt)("p",null,"We also know that since ",(0,i.kt)("inlineCode",{parentName:"p"},"L")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," are the left and right subtrees of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", by\ndefinition, they represent all nodes of ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," (except the root node). Then, to get\nsum of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", we just need the sum of ",(0,i.kt)("inlineCode",{parentName:"p"},"L"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),", and the value of the root node!\nLet's proof-ify this line of thought a bit more:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Inductive Step:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"T = Node(L,x,R)")),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"treeSum L")," is correct by ",(0,i.kt)("strong",{parentName:"li"},"IH")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"treeSum R")," is correct by ",(0,i.kt)("strong",{parentName:"li"},"IH")),(0,i.kt)("li",{parentName:"ul"},'"The sum of integers in ',(0,i.kt)("inlineCode",{parentName:"li"},"T"),'" are represented by the sum of the following:',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'"The sum of integers in ',(0,i.kt)("inlineCode",{parentName:"li"},"L"),'"'),(0,i.kt)("li",{parentName:"ul"},'"The sum of integers in ',(0,i.kt)("inlineCode",{parentName:"li"},"R"),'"'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x"),", by definition of trees."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"treeSum T = (treeSum L) + (treeSum R) + x")," by definition of ",(0,i.kt)("inlineCode",{parentName:"li"},"treeSum"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"(treeSum L) + (treeSum R) + x")," is correct by math and above logic."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"treeSum T")," is correct by substitution."))),(0,i.kt)("p",null,"Using the logic needed to complete the proof, we were able to arrive at how to\nimplement our function! Let's translate the above logic into SML:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"fun treeSum (Empty : int tree) : int = 0\n  | treeSum (Node(L,x,R)) = (treeSum L) + (treeSum R) + x\n")),(0,i.kt)("h2",{id:"qed"},"QED"),(0,i.kt)("p",null,"And like that, we're able to leverage mathematical induction to help us find\nthe solution to part of an SML function. For some, this intuition is obvious.\nBut for others, it isn't! A deep spiral of pure math and proving every single\naspect of your code isn't usually needed. ",(0,i.kt)("strong",{parentName:"p"},"BUT"),", it will definitely be helpful\nto adopt this style of thinking when approaching more difficult and advanced\nrecursion problems. Whenever you're trying to implement a recursive function in\nSML, remember to think inductively!"),(0,i.kt)("h1",{id:"beyond-trees"},"Beyond Trees"),(0,i.kt)("p",null,"Lets consider a weird ",(0,i.kt)("inlineCode",{parentName:"p"},"datatype")," like the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"datatype example =\n    A of int\n  | B\n  | C of example\n  | D of example * example * string\n")),(0,i.kt)("p",null,"A good exercise would be to consider what the the base cases and inductive\ncases would be if we had a typical proof about this datatype. Note that with\nthis ",(0,i.kt)("inlineCode",{parentName:"p"},"datatype")," you may need to have multiple base cases and inductive steps.\nThink about how you might answer that before you read on..."),(0,i.kt)("p",null,"A common misconception is that ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," isn't a base case because it has the ",(0,i.kt)("inlineCode",{parentName:"p"},"of"),"\nkeyword. Remember, we only need an inductive hypothesis if there is a recursive\ncomponent to the ",(0,i.kt)("inlineCode",{parentName:"p"},"datatype"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," constructor doesn't have a recursive part,\njust a ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", so no need to have an inductive hypothesis associated."),(0,i.kt)("p",null,"Okay, to explain fully: the constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," would require an inductive\nhypothesis since it has a recursive component; ",(0,i.kt)("inlineCode",{parentName:"p"},"D")," would require two inductive\nhypothesis (one for each recursive part, but not for ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),"); ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),"\ndon't have an IH, so are base cases."))}m.isMDXComponent=!0}}]);