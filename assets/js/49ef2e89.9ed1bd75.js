"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[3643],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=a,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return n?r.createElement(h,i(i({ref:t},u),{},{components:n})):r.createElement(h,i({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4802:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_position:3},i="Real",l={unversionedId:"types/real",id:"types/real",title:"Real",description:"By Brandon Wu, May 2020",source:"@site/docs/types/real.md",sourceDirName:"types",slug:"/types/real",permalink:"/book/docs/types/real",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Int",permalink:"/book/docs/types/int"},next:{title:"String",permalink:"/book/docs/types/string"}},s={},p=[{value:"Values",id:"values",level:2},{value:"Production",id:"production",level:2},{value:"Combination",id:"combination",level:2},{value:"From the Structure",id:"from-the-structure",level:2}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"real"},"Real"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"By Brandon Wu, May 2020")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"real")," is the SML type of real or floating-point numbers. As in other programming languages, reals in SML are restricted to finite machine representations, which means that they cannot represent every real number with perfect precision. For this reason, generally in this course we will prefer the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"int"),"s when performing numeric operations."),(0,a.kt)("h2",{id:"values"},"Values"),(0,a.kt)("p",null,"A real number is a sequence of numbers, followed by a decimal point, followed by another sequence of numbers. This includes examples such as ",(0,a.kt)("inlineCode",{parentName:"p"},"15.150"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"1.0"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"3.14159"),". Reals are noteworthy in that they are not ",(0,a.kt)("em",{parentName:"p"},"equality types"),", which means that they cannot be compared for equality with the ",(0,a.kt)("inlineCode",{parentName:"p"},"=")," operator. In addition, they cannot be pattern matched upon. This means that when designing programs with specific behavior based on equality with a specific real number, they should instead be written to operate within some ",(0,a.kt)("em",{parentName:"p"},"degree of precision")," of the real number in question. For instance:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sml"},"val equalThreshold = 0.000001\nfun isZero (x : real) : bool = Real.abs x < equalThreshold\n")),(0,a.kt)("p",null,'This function simply prespecifies a (small) range, within which a number can be considered to be "equal" to 0. It uses the function ',(0,a.kt)("inlineCode",{parentName:"p"},"Real.abs")," to check if the real number in question is within that threshold of zero, in either direction. In this way, we can approximate some test for equality, up to some degree of acceptable precision."),(0,a.kt)("h2",{id:"production"},"Production"),(0,a.kt)("p",null,"Real numbers similarly have access to some of the basic arithmetic operations as integers. In particular, they have:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sml"},"(op +) : real * real -> real\n(op -) : real * real -> real\n(op *) : real * real -> real\n(op /) : real * real -> real\n")),(0,a.kt)("p",null,"Note that all but the last operator are also defined to work on ",(0,a.kt)("inlineCode",{parentName:"p"},"int")," types. This may seem to violate type safety, however this is just an example of those functions being ",(0,a.kt)("em",{parentName:"p"},"overloaded"),'. There are two "copies" of, for instance, the ',(0,a.kt)("inlineCode",{parentName:"p"},"+")," operator - one that has type ",(0,a.kt)("inlineCode",{parentName:"p"},"int * int -> int")," and one with type ",(0,a.kt)("inlineCode",{parentName:"p"},"real * real -> real"),". Notably, however, it only works on either both ints or both reals - it is not defined on both. As such, SML can infer from its arguments whether it should use the ",(0,a.kt)("inlineCode",{parentName:"p"},"int")," or the ",(0,a.kt)("inlineCode",{parentName:"p"},"real")," variant, and similarly for ",(0,a.kt)("inlineCode",{parentName:"p"},"-")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"*"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"div"),", however, is only defined for integers - ",(0,a.kt)("inlineCode",{parentName:"p"},"/")," is the counterpart for division on the real numbers."),(0,a.kt)("h2",{id:"combination"},"Combination"),(0,a.kt)("p",null,"While not defined for equality, reals can still be compared to one another."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sml"},"(op <)  : real * real -> bool\n(op >)  : real * real -> bool\n(op <=) : real * real -> bool\n(op >=) : real * real -> bool\n")),(0,a.kt)("p",null,"These operations are similarly overloaded, and will also work on integers."),(0,a.kt)("h2",{id:"from-the-structure"},"From the Structure"),(0,a.kt)("p",null,"The structure ",(0,a.kt)("inlineCode",{parentName:"p"},"Real")," is bound as part of the SML Basis. It has access to a few useful functions, including:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sml"},"Real.toString : real -> string\nReal.compare  : real * real -> order\nReal.abs      : real -> real\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"Real.toString")," is the standard function that transforms a real number into its corresponding string representation, ",(0,a.kt)("inlineCode",{parentName:"p"},"Real.compare")," on two reals returns ",(0,a.kt)("inlineCode",{parentName:"p"},"LESS"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"EQUAL"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"GREATER")," depending on their relative magnitudes, and ",(0,a.kt)("inlineCode",{parentName:"p"},"Real.abs")," returns the absolute value of the real number in question."))}c.isMDXComponent=!0}}]);