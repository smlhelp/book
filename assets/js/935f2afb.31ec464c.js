"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"defaultSidebar":[{"type":"link","label":"Welcome!","href":"/book/docs/","docId":"README"},{"type":"category","label":"Getting Started","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Installing SML/NJ","href":"/book/docs/start/install","docId":"start/install"},{"type":"link","label":"SML Syntax Cheatsheet","href":"/book/docs/start/syntax","docId":"start/syntax"},{"type":"link","label":"Common Tasks in SML","href":"/book/docs/start/common","docId":"start/common"}]},{"type":"category","label":"Types","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Bool","href":"/book/docs/types/bool","docId":"types/bool"},{"type":"link","label":"Int","href":"/book/docs/types/int","docId":"types/int"},{"type":"link","label":"Real","href":"/book/docs/types/real","docId":"types/real"},{"type":"link","label":"String","href":"/book/docs/types/string","docId":"types/string"},{"type":"link","label":"Functions","href":"/book/docs/types/function","docId":"types/function"},{"type":"link","label":"List","href":"/book/docs/types/list","docId":"types/list"},{"type":"link","label":"Option","href":"/book/docs/types/options","docId":"types/options"}],"href":"/book/docs/types/"},{"type":"category","label":"Libraries","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"SML/NJ Basis","href":"/book/docs/libs/basis","docId":"libs/basis"},{"type":"link","label":"Auxiliary Library","href":"/book/docs/libs/aux-lib","docId":"libs/aux-lib"}]},{"type":"category","label":"Debugging","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Common Errors","href":"/book/docs/debugging/errors","docId":"debugging/errors"},{"type":"link","label":"Debugging Hints and Strategies","href":"/book/docs/debugging/hints","docId":"debugging/hints"}]},{"type":"category","label":"Concepts","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Basics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Evaluation","href":"/book/docs/concepts/basic/eval","docId":"concepts/basic/eval"},{"type":"link","label":"Extensional Equivalence","href":"/book/docs/concepts/basic/eeq","docId":"concepts/basic/eeq"},{"type":"link","label":"Pattern Matching","href":"/book/docs/concepts/basic/patternmatch","docId":"concepts/basic/patternmatch"}],"href":"/book/docs/concepts/basic/"},{"type":"category","label":"Recursion and Induction","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Tail Recursion","href":"/book/docs/concepts/recursion/tail","docId":"concepts/recursion/tail"},{"type":"link","label":"Trees","href":"/book/docs/concepts/recursion/tree","docId":"concepts/recursion/tree"}],"href":"/book/docs/concepts/recursion/"},{"type":"category","label":"Asymptotic Analysis","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Work and Span","href":"/book/docs/concepts/asymptotic/workspan","docId":"concepts/asymptotic/workspan"}],"href":"/book/docs/concepts/asymptotic/"},{"type":"link","label":"Parametric Polymorphism","href":"/book/docs/concepts/poly","docId":"concepts/poly"},{"type":"category","label":"Higher Order Functions","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Currying and Staging","href":"/book/docs/concepts/hof/curry","docId":"concepts/hof/curry"},{"type":"link","label":"Common HOFs and Partial Evaluation","href":"/book/docs/concepts/hof/common","docId":"concepts/hof/common"}],"href":"/book/docs/concepts/hof/"},{"type":"category","label":"Control Flow","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Continuation Passing Style","href":"/book/docs/concepts/control-flow/cps","docId":"concepts/control-flow/cps"},{"type":"link","label":"Exceptions","href":"/book/docs/concepts/control-flow/exn","docId":"concepts/control-flow/exn"}],"href":"/book/docs/concepts/control-flow/"},{"type":"category","label":"Modules","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Functors","href":"/book/docs/concepts/modules/functors","docId":"concepts/modules/functors"}],"href":"/book/docs/concepts/modules/"},{"type":"link","label":"Sequences","href":"/book/docs/concepts/sequences","docId":"concepts/sequences"},{"type":"link","label":"Lazy Evaluation","href":"/book/docs/concepts/lazy","docId":"concepts/lazy"},{"type":"link","label":"Imperative Programming","href":"/book/docs/concepts/imperative","docId":"concepts/imperative"}]},{"type":"category","label":"Examples","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"SML Basics Examples","href":"/book/docs/examples/basics","docId":"examples/basics"},{"type":"link","label":"Recursion and Induction","href":"/book/docs/examples/recursion","docId":"examples/recursion"}]},{"type":"link","label":"About","href":"/book/docs/about","docId":"about"}]},"docs":{"about":{"id":"about","title":"About","description":"SML Help is a joint venture between previous and current teaching assistants of the computer science course 15-150: Principles of Functional Programming, taught at Carnegie Mellon University. It is aimed at being a comprehensive and accessible resource to students of 150, as well as those just interested in learning functional programming concepts in general, as viewed through the lens of the Standard ML language.","sidebar":"defaultSidebar"},"concepts/asymptotic/README":{"id":"concepts/asymptotic/README","title":"Asymptotic Analysis","description":"By Brandon Wu, May 2020","sidebar":"defaultSidebar"},"concepts/asymptotic/workspan":{"id":"concepts/asymptotic/workspan","title":"Work and Span","description":"By Aditi Gupta and Brandon Wu, May 2020. Revised September 2020","sidebar":"defaultSidebar"},"concepts/basic/eeq":{"id":"concepts/basic/eeq","title":"Extensional Equivalence","description":"By Brandon Wu, June 2020","sidebar":"defaultSidebar"},"concepts/basic/eval":{"id":"concepts/basic/eval","title":"Evaluation","description":"By Brandon Wu, May 2020","sidebar":"defaultSidebar"},"concepts/basic/patternmatch":{"id":"concepts/basic/patternmatch","title":"Pattern Matching","description":"By Kaz Zhou, September 2020. Revised May 2021","sidebar":"defaultSidebar"},"concepts/basic/README":{"id":"concepts/basic/README","title":"Basics","description":"Standard ML is a functional programming language, meaning that we eschew the use of side effects and state changes to obtain programs that are easy to reason about, analogous to reasoning about mathematical expressions. Similarly to mathematics, we perform operations and view computation as a process of simplification (or reduction, as we will more commonly name it). Seen in this way, computation becomes an elaborate series of expression evaluations, and it is this concept that will permeate the course. In these notes, we will go further in detail about the basic concepts of SML.","sidebar":"defaultSidebar"},"concepts/control-flow/cps":{"id":"concepts/control-flow/cps","title":"Continuation Passing Style","description":"By Brandon Wu, June 2020. Revised March 2022","sidebar":"defaultSidebar"},"concepts/control-flow/exn":{"id":"concepts/control-flow/exn","title":"Exceptions","description":"By Brandon Wu, June 2020. Revised June 2022","sidebar":"defaultSidebar"},"concepts/control-flow/README":{"id":"concepts/control-flow/README","title":"Control Flow","description":"Programs inherently are composed of a series of steps. Depending on the context, syntax, and semantics of the programming language in general, we arrive at a certain prescribed order in which instructions are executed (at least for sequential programs). It is often the case that, according to small differences in state or environment, control may be affected, causing different instructions to be executed. In this chapter, we will discuss two control flow constructs, namely continuations and exceptions, that can allow us to more easily and cleanly write functions that need to have complex control flow behavior, or in other words, complicated decision-making.","sidebar":"defaultSidebar"},"concepts/hof/common":{"id":"concepts/hof/common","title":"Common HOFs and Partial Evaluation","description":"By Brandon Wu, June 2020. Revised March 2022","sidebar":"defaultSidebar"},"concepts/hof/curry":{"id":"concepts/hof/curry","title":"Currying and Staging","description":"By Brandon Wu, June 2020","sidebar":"defaultSidebar"},"concepts/hof/README":{"id":"concepts/hof/README","title":"Higher Order Functions","description":"At this point, we\'ve explored the concept of computation as evaluation, passing around values and reducing expressions to values as well. We have seen how we are allowed a great deal of versatility while maintaining type safety in SML\'s type system, and how we can construct arbitrary datatypes to be passed around as first class citizens, that is being able to be manipulated the same as any other value. We will now discuss what is considered one of the most powerful tools available in functional programming languages - that is, the exploitation of functions themselves as values, with which we can further parameterize our functions and results.","sidebar":"defaultSidebar"},"concepts/imperative":{"id":"concepts/imperative","title":"Imperative Programming","description":"By Len Huang and Cooper Pierce, February 2021","sidebar":"defaultSidebar"},"concepts/lazy":{"id":"concepts/lazy","title":"Lazy Evaluation","description":"By Len Huang, Cooper Pierce, and Brandon Wu, January 2021. Rewritten by Thea Brick, April 2022.","sidebar":"defaultSidebar"},"concepts/modules/functors":{"id":"concepts/modules/functors","title":"Functors","description":"By Cooper Pierce and Brandon Wu, February 2021","sidebar":"defaultSidebar"},"concepts/modules/README":{"id":"concepts/modules/README","title":"Modules","description":"By Eunice Chen and Brandon Wu, December 2020","sidebar":"defaultSidebar"},"concepts/poly":{"id":"concepts/poly","title":"Parametric Polymorphism","description":"By Brandon Wu, September 2020","sidebar":"defaultSidebar"},"concepts/recursion/README":{"id":"concepts/recursion/README","title":"Recursion and Induction","description":"By Jacob Neumann and Kaz Zhou, May 2022","sidebar":"defaultSidebar"},"concepts/recursion/tail":{"id":"concepts/recursion/tail","title":"Tail Recursion","description":"By Eunice Chen and Brandon Wu, December 2020. Revised March 2022","sidebar":"defaultSidebar"},"concepts/recursion/tree":{"id":"concepts/recursion/tree","title":"Trees","description":"By Len Huang, August 2020","sidebar":"defaultSidebar"},"concepts/sequences":{"id":"concepts/sequences","title":"Sequences","description":"By Kaz Zhou, January 2021. Revised April 2021","sidebar":"defaultSidebar"},"debugging/errors":{"id":"debugging/errors","title":"Common Errors","description":"By Eunice Chen, January 2021. Revised April 2022","sidebar":"defaultSidebar"},"debugging/hints":{"id":"debugging/hints","title":"Debugging Hints and Strategies","description":"By Eunice Chen, January 2021","sidebar":"defaultSidebar"},"examples/basics":{"id":"examples/basics","title":"SML Basics Examples","description":"By Eunice Chen, May 2020","sidebar":"defaultSidebar"},"examples/recursion":{"id":"examples/recursion","title":"Recursion and Induction","description":"By Eunice Chen, June 2020","sidebar":"defaultSidebar"},"libs/aux-lib":{"id":"libs/aux-lib","title":"Auxiliary Library","description":"By Jacob Neumann, June 2021","sidebar":"defaultSidebar"},"libs/basis":{"id":"libs/basis","title":"SML/NJ Basis","description":"By Jacob Neumann, June 2021","sidebar":"defaultSidebar"},"README":{"id":"README","title":"Welcome!","description":"Welcome to SML Help! The goal of this site is to provide a convenient resource for learning functional programming, particularly in the language of Standard ML. You\'ll find various guides and references about the SML type system and functional programming concepts, as well as some worked examples and tutorials. Click on the navigation links on the left to get started!","sidebar":"defaultSidebar"},"start/common":{"id":"start/common","title":"Common Tasks in SML","description":"By Thea Brick, December 2021","sidebar":"defaultSidebar"},"start/install":{"id":"start/install","title":"Installing SML/NJ","description":"By Brandon Wu, May 2020, updated by Zach Battleman, April 2022","sidebar":"defaultSidebar"},"start/syntax":{"id":"start/syntax","title":"SML Syntax Cheatsheet","description":"By David Sun, February 2021","sidebar":"defaultSidebar"},"types/bool":{"id":"types/bool","title":"Bool","description":"By Jacob Neumann, May 2020","sidebar":"defaultSidebar"},"types/function":{"id":"types/function","title":"Functions","description":"By Brandon Wu, May 2020","sidebar":"defaultSidebar"},"types/int":{"id":"types/int","title":"Int","description":"By Brandon Wu, May 2020","sidebar":"defaultSidebar"},"types/list":{"id":"types/list","title":"List","description":"By Brandon Wu, May 2020","sidebar":"defaultSidebar"},"types/options":{"id":"types/options","title":"Option","description":"By Jacob Neumann, June 2021","sidebar":"defaultSidebar"},"types/README":{"id":"types/README","title":"Types","description":"By Brandon Wu, May 2020","sidebar":"defaultSidebar"},"types/real":{"id":"types/real","title":"Real","description":"By Brandon Wu, May 2020","sidebar":"defaultSidebar"},"types/string":{"id":"types/string","title":"String","description":"By Brandon Wu, May 2020","sidebar":"defaultSidebar"}}}')}}]);