"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[5116],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4291:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:1},i="Records",l={unversionedId:"concepts/beyond/records",id:"concepts/beyond/records",title:"Records",description:"By Thea Brick, January 2023",source:"@site/docs/concepts/beyond/records.md",sourceDirName:"concepts/beyond",slug:"/concepts/beyond/records",permalink:"/book/docs/concepts/beyond/records",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",previous:{title:"Beyond",permalink:"/book/docs/concepts/beyond/"},next:{title:"Multi-File Projects",permalink:"/book/docs/concepts/beyond/multi-files"}},s={},p=[{value:"The Type",id:"the-type",level:2},{value:"The Expression",id:"the-expression",level:2},{value:"The Pitfalls",id:"the-pitfalls",level:2}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"records"},"Records"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"By Thea Brick, January 2023")),(0,r.kt)("p",null,"In the prior chapters we've used tuples as a method to carry around multiple,\ndistinct pieces of information. Using tuples for this is perfectly reasonable\nfor simple programs or places where we are only passing around a couple of\nthings, but often we need to handle much more than a couple things. We may also\nwant to convey information about what is being passed in (for readability)."),(0,r.kt)("h2",{id:"the-type"},"The Type"),(0,r.kt)("p",null,"To support this, SML provides the record type, which can be thought of as a\nlabeled tuple. This means we can have a record of any length",(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," but each field\nhas an additional label that we can use for accessing it (rather than just\nusing the position). Here's an example of creating and using one:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"type version = { id : int, name : string, date : string }\n")),(0,r.kt)("p",null,"Any value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"version")," type must have the fields ",(0,r.kt)("inlineCode",{parentName:"p"},"id : int"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"name : string"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"date : string")," importantly with no additional fields. We\nmay already see why this may be desired. If we had just used a tuple (e.g.\n",(0,r.kt)("inlineCode",{parentName:"p"},"int * string * string"),") then there is no distinction (without documentation)\nbetween the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"date"),"."),(0,r.kt)("p",null,"You don't need to use a type declaration to define a record though. You can use\nit anywhere, just like a tuple."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"datatype 'a tree = Empty\n                 | Node of { left : 'a tree, value : 'a, right : 'a tree }\n\nval example : { tree : int tree, size : int } = (* omitted *)\n")),(0,r.kt)("h2",{id:"the-expression"},"The Expression"),(0,r.kt)("p",null,"To create values of these record types, we follow a very similar syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},'val version : version = {id=150, name="SMLhelp", date="Oct 23"}\n')),(0,r.kt)("p",null,"Every field must be defined in order for the type to match (with no additional\nones), but the ordering does not matter."),(0,r.kt)("p",null,"Now that we have these records how do we use them. There are two methods to go\nabout this, accessors and pattern-matching. An accessor is simply the ",(0,r.kt)("inlineCode",{parentName:"p"},"#")," with\nthe name of the field desired immediately after",(0,r.kt)("sup",{parentName:"p",id:"fnref-2"},(0,r.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),". For instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"val getName : version -> string = fn version => #name version\n")),(0,r.kt)("p",null,"Alternatively we can pattern-match instead. There are numerous different ways\nto pattern match, which you can use for various situations. For instance, the\nmost basic method is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"val getName : version -> string =\n  fn {name = n, id = i, date = d} => n\n")),(0,r.kt)("p",null,"We don't care about the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"date")," fields for this function, so we can use\n",(0,r.kt)("inlineCode",{parentName:"p"},"...")," to omit those any field we don't care about from our record pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"val getName : version -> string = fn {name = n, ...} => n\n")),(0,r.kt)("p",null,"Finally, ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," is the name of our field, but it would also be fine as the name\nfor our variable. So we can not include an ",(0,r.kt)("inlineCode",{parentName:"p"},"="),"s and SML will bind the field to a\nvariable of the same name:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"val getName : version -> string = fn {name, ...} => name\n")),(0,r.kt)("h2",{id:"the-pitfalls"},"The Pitfalls"),(0,r.kt)("p",null,"From above, we have the following declaration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"val getName : version -> string = fn version => #name version\n")),(0,r.kt)("p",null,'You may see this and think "hmmm... I can simplify this a bit," And write\nsomething along the lines of:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"val getName = fn v => #name v\nval getName = fn {name, ...} => name (* alternatively *)\n")),(0,r.kt)("p",null,'If you try and compile this, you\'ll get a type error, specifically an\n"unresolved flex record," SML is able to determine what the ',(0,r.kt)("inlineCode",{parentName:"p"},"getName")," function\nshould take in a record with at least the field ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),", but it can't infer\nanything else. It could reasonably be ",(0,r.kt)("inlineCode",{parentName:"p"},"{ name : 'a }")," or\n",(0,r.kt)("inlineCode",{parentName:"p"},"{ name : 'a, id : 'b}"),", or\n",(0,r.kt)("inlineCode",{parentName:"p"},"{ name : 'a, id : 'b, ijoergnq : 'c list list list}"),", or any other\npossibility. The ",(0,r.kt)("inlineCode",{parentName:"p"},"getName")," function can only be one type, so this isn't allowed."),(0,r.kt)("p",null,"There are two common workarounds for this. This first is just to annotate your\ntypes! If we specifically say ",(0,r.kt)("inlineCode",{parentName:"p"},"getName")," must take in a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"version"),",\nthen there is no abiguity, so no error. The other workaround involves wrapping\na record in a constructor, which enforces the type of the record. To implement\nthis we might change our code to the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"datatype version = Version of { id : int, name : string, date : string }\n\nval getName = fn Version v => #name v\n")),(0,r.kt)("p",null,"Thus, we know what fields ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," has, since the type can be infered by the\nconstructor it is associated with."),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},"If you were curious, the empty record ",(0,r.kt)("inlineCode",{parentName:"li"},"{}")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"li"},"()"),", thus\nhas type ",(0,r.kt)("inlineCode",{parentName:"li"},"unit"),".",(0,r.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,r.kt)("li",{parentName:"ol",id:"fn-2"},"The same can be done for tuples, where ",(0,r.kt)("inlineCode",{parentName:"li"},"#1")," accesses the first value in\nthe tuple, ",(0,r.kt)("inlineCode",{parentName:"li"},"#2")," for the second, etc.",(0,r.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")))))}d.isMDXComponent=!0}}]);