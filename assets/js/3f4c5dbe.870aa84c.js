"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[3954],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),m=l(n),u=o,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||r;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:o,i[1]=p;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4886:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>p,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:3},i="Types",p={unversionedId:"types/README",id:"types/README",title:"Types",description:"By Brandon Wu, May 2020",source:"@site/docs/types/README.md",sourceDirName:"types",slug:"/types/",permalink:"/book/docs/types/",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Common Tasks in SML",permalink:"/book/docs/start/common"},next:{title:"Bool",permalink:"/book/docs/types/bool"}},s={},l=[{value:"Type Safety",id:"type-safety",level:2},{value:"Type-Checking",id:"type-checking",level:2},{value:"Conclusion",id:"conclusion",level:2}],c={toc:l};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"types"},"Types"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"By Brandon Wu, May 2020")),(0,o.kt)("p",null,"Types are a very fundamental concept to Standard ML (SML), and indeed, to functional programming in general. Most programming languages have some notion of type, with ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"float"),", and data structures such as ",(0,o.kt)("inlineCode",{parentName:"p"},"array")," being common examples, however they tend to be weakly enforced, only being verified at runtime. In SML, we employ a system of ",(0,o.kt)("em",{parentName:"p"},"strong typing")," consisting of stricter typing rules \u2014 which allows us to catch errors earlier in program execution \u2014 at compile time."),(0,o.kt)("h2",{id:"type-safety"},"Type Safety"),(0,o.kt)("p",null,"Oftentimes, data is separated into types so that we can differentiate different kinds of data from each other. For instance, it makes no sense to add a ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," and an ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),", though certain programming languages will try to make sense of it. Usually, when different data types are haphazardly intermingled, it is because someone wrote a bug. The philosophy behind SML's type system is to disallow such intermingling. In SML, every expression and every function has a specified type, which governs what interactions are possible with other expressions."),(0,o.kt)("p",null,"Consider the following code fragment in Python:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},'def foo(x):\n    if x == 2:\n        return 1\n    elif x == "bar":\n        return True\n    return None\n')),(0,o.kt)("p",null,'What is the type of its output? The answer is "it depends", as it is dependent on the value of ',(0,o.kt)("inlineCode",{parentName:"p"},"x")," that is passed in. We could give ",(0,o.kt)("inlineCode",{parentName:"p"},"foo")," any type of argument, and we can see that in the cases that we pass in ",(0,o.kt)("inlineCode",{parentName:"p"},"2")," or ",(0,o.kt)("inlineCode",{parentName:"p"},'"bar"'),", we could obtain an ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," or a ",(0,o.kt)("inlineCode",{parentName:"p"},"bool")," as output, or even a ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," in any other case."),(0,o.kt)("p",null,"Consider the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"foo(y) + 3"),". Is it safe to evaluate? Again, the answer depends on what the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),' is, but we see the same answer of "it depends". In some cases, depending on what the program has done up to this point, it may be safe; this is in the case where ',(0,o.kt)("inlineCode",{parentName:"p"},"y")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"2"),", in which case ",(0,o.kt)("inlineCode",{parentName:"p"},"foo(y) + 3")," would just be ",(0,o.kt)("inlineCode",{parentName:"p"},"4"),". But if it wasn't, we may end up trying to add ",(0,o.kt)("inlineCode",{parentName:"p"},"True")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"3"),", which clearly doesn't make sense. If we tried to add ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"3")," we would encounter a ",(0,o.kt)("em",{parentName:"p"},"type error"),". While a contrived piece of code, type errors such as this spring up in code all the time. Type errors are unsafe. Whoever wrote this program likely didn't intend to try and add a non-",(0,o.kt)("inlineCode",{parentName:"p"},"int")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"3"),", but it can be tricky to reason about whether or not such an outcome is truly possible."),(0,o.kt)("p",null,"In SML, our philosophy will be to make such uncertainties impossible. We impose a certain degree of ",(0,o.kt)("em",{parentName:"p"},"determinism")," on our programs, such that the types of each expression and each step of evaluation throughout our program have a definite type that is known to the program. If a program tries to execute some computation that would use the wrong type somewhere, or otherwise cause types to mismatch, then we would call the program ",(0,o.kt)("em",{parentName:"p"},"ill-typed")," or ",(0,o.kt)("em",{parentName:"p"},"not well-typed"),", and it would be rejected before any evaluation. This process of verifying types is called ",(0,o.kt)("em",{parentName:"p"},"type-checking"),", and occurs at ",(0,o.kt)("em",{parentName:"p"},"compile-time"),", which stands opposed to ",(0,o.kt)("em",{parentName:"p"},"run-time"),". Compile-time type-checking happens before any actual evaluation \u2014 before the program's run-time \u2014 and only upon passing the type-checking phase will the program actually execute. At this point, we say the program ",(0,o.kt)("em",{parentName:"p"},"type-checks"),"."),(0,o.kt)("h2",{id:"type-checking"},"Type-Checking"),(0,o.kt)("p",null,"The most fundamental rule for type-checking is during ",(0,o.kt)("em",{parentName:"p"},"function application"),", or the act of ",(0,o.kt)("em",{parentName:"p"},"applying")," a function to its arguments. This is elaborated on further in the chapter on functions."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"[APP]")," An expression ",(0,o.kt)("inlineCode",{parentName:"p"},"e1 e2")," has type ",(0,o.kt)("inlineCode",{parentName:"p"},"t2")," if and only if ",(0,o.kt)("inlineCode",{parentName:"p"},"e1 : t1 -> t2")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"e2 : t1"),".")),(0,o.kt)("p",null,"More specifically, for a function ",(0,o.kt)("inlineCode",{parentName:"p"},"f : t1 -> t2"),", if ",(0,o.kt)("inlineCode",{parentName:"p"},"x : t3")," where ",(0,o.kt)("inlineCode",{parentName:"p"},"t3")," is not the same type as ",(0,o.kt)("inlineCode",{parentName:"p"},"t1"),", then the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"f x")," is not well-typed and therefore has no value. In other words, applying a function to an argument that does not match its argument type does not type-check \u2014 because doing that creates a type error \u2014 which will prompt the compiler to reject the program at compile-time during the type-checking process. We call an expression that does not encounter a type error ",(0,o.kt)("em",{parentName:"p"},"well-typed"),". A program that passes the type-checking process is one that type-checks."),(0,o.kt)("p",null,"The majority of type errors will occur as a consequence of this rule. Since functions have definite return types, it is very straightforward to check if a program type-checks or not: simply evaluate the ",(0,o.kt)("em",{parentName:"p"},"types")," of the expressions and see if any type errors are encountered. The type-checking phase is agnostic to the specific values of well-typed expressions. When given an expression \u2014 such as ",(0,o.kt)("inlineCode",{parentName:"p"},"1 + 2")," \u2014 the compiler sees two expressions of type ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," being passed into a function of type ",(0,o.kt)("inlineCode",{parentName:"p"},"int * int -> int")," and knows that the result must be of type ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," \u2014 thus the entire expression ",(0,o.kt)("inlineCode",{parentName:"p"},"1 + 2")," is well-typed."),(0,o.kt)("p",null,"Because of this, the well-typedness of expressions is independent of any run-time errors that may occur. For instance, the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"1 div 0")," clearly cannot give back a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),", as division by 0 is undefined. Instead, ",(0,o.kt)("inlineCode",{parentName:"p"},"1 div 0")," will raise the exception ",(0,o.kt)("inlineCode",{parentName:"p"},"Div")," during execution and try to terminate the execution of the program. From the perspective of the compiler's type-checking process, it only cares that all arguments to ",(0,o.kt)("inlineCode",{parentName:"p"},"div")," are of the right type \u2014 it only cares that the types match. The second argument of ",(0,o.kt)("inlineCode",{parentName:"p"},"div")," being ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," still type-checks. So even though ",(0,o.kt)("inlineCode",{parentName:"p"},"1 div 0")," will not evaluate to a value, it also will not encounter a type error; therefore the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"1 div 0")," is well-typed and has the type ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"SML's strong type system is a very powerful tool for ensuring the correctness of programs. The philosophy behind Standard ML is to push errors to compile-time \u2014 before a program is even run. In doing so, we ensure that unexpected errors do not arise during run-time, long after we've already proven that our code is correct. With strong typing and type-checking, we can guarantee that our code will be free of type errors, eliminating those bugs from our code at run-time. Later in this section, we will discuss some concrete types."))}d.isMDXComponent=!0}}]);