"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[6697],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,f=m["".concat(l,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(f,r(r({ref:t},u),{},{components:n})):a.createElement(f,r({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},988:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:5},r="Functions",s={unversionedId:"types/function",id:"types/function",title:"Functions",description:"By Brandon Wu, May 2020",source:"@site/docs/types/function.md",sourceDirName:"types",slug:"/types/function",permalink:"/book/docs/types/function",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"defaultSidebar",previous:{title:"String",permalink:"/book/docs/types/string"},next:{title:"List",permalink:"/book/docs/types/list"}},l={},p=[{value:"What is a Function?",id:"what-is-a-function",level:2},{value:"Function Types and Function Application",id:"function-types-and-function-application",level:2},{value:"Functions in SML",id:"functions-in-sml",level:2}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"functions"},"Functions"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"By Brandon Wu, May 2020")),(0,i.kt)("p",null,"Functions are a familiar concept in programming. In most languages, functions seem to capture a notion of a list of instructions to be carried out, with each invocation of the function resulting in another round of executing its instructions. In this class, however, we will take another perspective on functions - one that identifies the function more with the values that it outputs than the instructions that it executes."),(0,i.kt)("h2",{id:"what-is-a-function"},"What is a Function?"),(0,i.kt)("p",null,"What is a function? To most seasoned programmers, the definition given in the above section seems to be the most obvious. A function (or subroutine) is simply identified with the instructions that it executes, which have some ",(0,i.kt)("em",{parentName:"p"},"effect")," on the state of the program as a whole, such as incrementing some variable, or setting some flag."),(0,i.kt)("p",null,"Before most programmers were programmers, however, they had a different notion of a function. To a mathematician, a function is something else entirely. Instead of being an algorithmic sequence of instructions, a function is simply an entity that maps inputs to outputs - for example, ","(","f(x) = x + 1",")",". Something rather notable is that mathematical functions are ",(0,i.kt)("em",{parentName:"p"},"pure")," - given the same input, they always return the same output. So while it is a valid question in programming to ask how a function's behavior changes over time, this is a nonsensical question in terms of mathematical functions."),(0,i.kt)("p",null,"To be more concrete, let us consider a Python program."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x = 0\ndef f(y):\n    x += 1\n    return x + y\n")),(0,i.kt)("p",null,"This program instantiates a variable ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," outside the scope of the function ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," (which takes a single argument ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"), and the behavior of ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," is to increment the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", then return the sum of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),". What we would find is that the first time that we run ",(0,i.kt)("inlineCode",{parentName:"p"},"f(0)"),", for instance, we obtain ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),". The second time that we run ",(0,i.kt)("inlineCode",{parentName:"p"},"f(0)"),", it will return ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),", and so on and so forth. We cannot even say that ",(0,i.kt)("inlineCode",{parentName:"p"},"f(0) = f(0)"),"! The output behavior of this function changes every time that it is run. This makes it difficult to reason about the function - in order to do so, we must know the number of times that it has been called before, at a given step in the program. While this is a fairly tame example, this problem only compounds with more complicated functions."),(0,i.kt)("p",null,"Clearly, this function is ",(0,i.kt)("em",{parentName:"p"},"impure"),". Can we do better?"),(0,i.kt)("h2",{id:"function-types-and-function-application"},"Function Types and Function Application"),(0,i.kt)("p",null,"So far we have seen basic types such as ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", among others. Functions allow us to compose types in new ways."),(0,i.kt)("p",null,"In SML, we denote the type of a function that has input type ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and output type ",(0,i.kt)("inlineCode",{parentName:"p"},"t2")," (for some arbitrary, fixed ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"t2"),") to be ",(0,i.kt)("inlineCode",{parentName:"p"},"t1 -> t2"),". By SML's strict typing rules, functions of type ",(0,i.kt)("inlineCode",{parentName:"p"},"t1 -> t2")," can ",(0,i.kt)("em",{parentName:"p"},"only")," take in inputs of type ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and return outputs of type ",(0,i.kt)("inlineCode",{parentName:"p"},"t2"),", for any types ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"t2"),". Additionally, we write ",(0,i.kt)("inlineCode",{parentName:"p"},"e1 e2")," for the expression consisting of the function ",(0,i.kt)("inlineCode",{parentName:"p"},"e1")," being given as input the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"e2")," (so we may write the mathematical function ","(","f(x)",")"," instead as ",(0,i.kt)("inlineCode",{parentName:"p"},"f x"),")."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"[APP]")," An expression ",(0,i.kt)("inlineCode",{parentName:"p"},"e1 e2")," has type ",(0,i.kt)("inlineCode",{parentName:"p"},"t2")," if and only if ",(0,i.kt)("inlineCode",{parentName:"p"},"e1 : t1 -> t2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"e2 : t1"),".")),(0,i.kt)("p",null,"We call the above rule ","[APP]"," since it concerns the types of expressions during ",(0,i.kt)("em",{parentName:"p"},"function application"),", or the process of applying a function to an argument."),(0,i.kt)("p",null,"Note that a function must always have type ",(0,i.kt)("inlineCode",{parentName:"p"},"t1 -> t2")," (for some types ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"t2"),", though ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"t2")," may be complicated types in their own right). As such, all functions in SML can only take in ",(0,i.kt)("em",{parentName:"p"},"one")," input - though the input type ",(0,i.kt)("inlineCode",{parentName:"p"},"t1"),' may be one that "contains" multiple values. For instance, a function may have type ',(0,i.kt)("inlineCode",{parentName:"p"},"int * int -> bool"),". For such a function, it takes in only ",(0,i.kt)("em",{parentName:"p"},"one")," argument (a tuple containing two integers)."),(0,i.kt)("h2",{id:"functions-in-sml"},"Functions in SML"),(0,i.kt)("p",null,"We can declare a function with the ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," keyword."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"fun fact (0 : int) : int = 1\n  | fact (n : int) : int = n * fact (n - 1)\n")),(0,i.kt)("p",null,"The above example serves to initialize a function that computes the factorial function, and then bind it to the identifier ",(0,i.kt)("inlineCode",{parentName:"p"},"fact"),". Function declarations create a ",(0,i.kt)("em",{parentName:"p"},"closure")," which includes all bound variables in the scope of the function when it was declared, so the behavior of ",(0,i.kt)("inlineCode",{parentName:"p"},"fact")," will always be as if it was in the same environment as when it was first declared. As such, we can also declare functions such as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"val x = 1\nfun addX (n : int) : int = n + x\nval x = 2\n")),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"addX")," is bound, it is bound in a closure that includes the binding of the value ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," to the identifier ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," (we may denote this as ",(0,i.kt)("inlineCode",{parentName:"p"},"[1/x]"),"). As such, even though the body of ",(0,i.kt)("inlineCode",{parentName:"p"},"addX")," refers to the identifier ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", it is not affected by the later re-binding of the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", since it only matters what the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," was when ",(0,i.kt)("inlineCode",{parentName:"p"},"addX")," was first bound. Seen in this way, then, reasoning about functions which use bound variables is very intuitive - you simply have to look up for the most recent time that that variable was bound."),(0,i.kt)("p",null,"We also can use ",(0,i.kt)("em",{parentName:"p"},"anonymous lambda expressions")," to bind functions. These are denoted by the ",(0,i.kt)("inlineCode",{parentName:"p"},"fn")," keyword, and are called lambda expressions for historical reasons having to do with a model of computation called the ",(0,i.kt)("em",{parentName:"p"},"lambda calculus"),". For instance, we can declare:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"val addOne : int -> int = fn x => x + 1\n")),(0,i.kt)("p",null,"Lambda expressions can also be ",(0,i.kt)("em",{parentName:"p"},"multi-clausal"),", by pattern matching to multiple different clauses. For instance, we can define the following function, which simply returns true when given 0 and 1, and false otherwise."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"val isBinary : int -> bool = fn 0 => true | 1 => true | _ => false\n")),(0,i.kt)("p",null,"Note that the right hand side of this declaration is an expression in its own right, and can be used independently of just being bound. The above binding simply binds the anonymous lambda expression (which simply increments an integer) to the identifier ",(0,i.kt)("inlineCode",{parentName:"p"},"addOne"),". We could also do the following binding:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"val two : int = (fn x => x + 1) 1\n")),(0,i.kt)("p",null,"where we bind the result of evaluating the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn x => x + 1) 1")," to the identifier ",(0,i.kt)("inlineCode",{parentName:"p"},"two"),". Clearly, this expression evaluates to ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),", as ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," is substituted in for the local variable ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", and then simply summed with ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fn")," differ in that functions declared with ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," can be recursive, whereas val bindings using ",(0,i.kt)("inlineCode",{parentName:"p"},"fn")," ",(0,i.kt)("em",{parentName:"p"},"cannot")," unless you use ",(0,i.kt)("inlineCode",{parentName:"p"},"rec"),". As such, while we can define the function ",(0,i.kt)("inlineCode",{parentName:"p"},"fact")," as we did above, using ",(0,i.kt)("inlineCode",{parentName:"p"},"fun"),", the following code ",(0,i.kt)("em",{parentName:"p"},"does not")," work:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"(* DOES NOT WORK *)\nval fact : int -> int = fn 0 => 1 | n => n * fact (n - 1)\n")),(0,i.kt)("p",null,"We will explore later on in the course what lambda expressions are useful for. In the meantime, usage of ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," is sufficient to declare any functions that you may need."),(0,i.kt)("p",null,"It is also important to note that SML is an ",(0,i.kt)("em",{parentName:"p"},"eager")," language, or ",(0,i.kt)("em",{parentName:"p"},"call-by-value"),". This means that functions evaluate their arguments before stepping into their function bodies. This is explored more in the article on evaluation."))}c.isMDXComponent=!0}}]);