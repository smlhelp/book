"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[6336],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),h=a,m=u["".concat(l,".").concat(h)]||u[h]||c[h]||i;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5824:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const i={sidebar_position:3},o="Additional Modules Syntax",s={unversionedId:"concepts/beyond/more-syntax",id:"concepts/beyond/more-syntax",title:"Additional Modules Syntax",description:"By Thea Brick, January 2023",source:"@site/docs/concepts/beyond/more-syntax.md",sourceDirName:"concepts/beyond",slug:"/concepts/beyond/more-syntax",permalink:"/book/docs/concepts/beyond/more-syntax",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Multi-File Projects",permalink:"/book/docs/concepts/beyond/multi-files"},next:{title:"Oh No! The Value Restriction",permalink:"/book/docs/concepts/beyond/val-restrict"}},l={},p=[{value:"The <code>open</code>/<code>include</code> Keyword for Modules",id:"the-openinclude-keyword-for-modules",level:2},{value:"The <code>where</code> Keyword for Modules",id:"the-where-keyword-for-modules",level:2},{value:"The <code>sharing</code> Keyword for Modules",id:"the-sharing-keyword-for-modules",level:2}],d={toc:p};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"additional-modules-syntax"},"Additional Modules Syntax"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"By Thea Brick, January 2023")),(0,a.kt)("p",null,"Modules in general are fairly complex. Due to this, we mostly focused on a\nsubset of the available syntax. That is not to these things are not useful\nthough."),(0,a.kt)("h2",{id:"the-openinclude-keyword-for-modules"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"open"),"/",(0,a.kt)("inlineCode",{parentName:"h2"},"include")," Keyword for Modules"),(0,a.kt)("p",null,"These are very simple, but often useful declarations. The ",(0,a.kt)("inlineCode",{parentName:"p"},"open")," declaration\ntakes a structure and places everything defined within it into scope. For\ninstance, if you were to write ",(0,a.kt)("inlineCode",{parentName:"p"},"open Int"),", then you could just call ",(0,a.kt)("inlineCode",{parentName:"p"},"toString"),"\nto get the ",(0,a.kt)("inlineCode",{parentName:"p"},"Int.toString")," function instead."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"include")," keyword is essentially identical, but instead operates on the\nsignature/specification level. Writing ",(0,a.kt)("inlineCode",{parentName:"p"},"include SIGNATURE")," essentially inserts\nall the specification defined in the signature into wherever the ",(0,a.kt)("inlineCode",{parentName:"p"},"include")," is\nplaced."),(0,a.kt)("h2",{id:"the-where-keyword-for-modules"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"where")," Keyword for Modules"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," syntax allows the sharing of abstract type information for a\nstructure which otherwise uses opaque ascription. This is useful because we\ngenerally want to always use opaque ascription, as not letting outside programs\nmess with internal representations is important, yet there are some instances\nwhere knowledge of the representation is essential, but it doesn't make sense\nto make the type concrete."),(0,a.kt)("p",null,"There ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," keyword appears after the signature which it is being applied to.\nHere is an example of what the ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," keyword does."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sml"},"signature EXAMPLE =\nsig\n  type t (* abstract *)\n  type u (* abstract *)\n  type v (* abstract *)\nend\n\nsignature EXAMPLE2 = EXAMPLE where type t = int\n")),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"t")," is no longer abstract in ",(0,a.kt)("inlineCode",{parentName:"p"},"EXAMPLE2")," rather it is defined to be\n",(0,a.kt)("inlineCode",{parentName:"p"},"int"),". Likewise this can be done for multiple types, either through chaining\n",(0,a.kt)("inlineCode",{parentName:"p"},"where"),"s or through the ",(0,a.kt)("inlineCode",{parentName:"p"},"and")," keyword."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sml"},"signature EXAMPLE3 = EXAMPLE where type t = int and type u = string\n")),(0,a.kt)("p",null,"Only type ",(0,a.kt)("inlineCode",{parentName:"p"},"v")," remains abstract."),(0,a.kt)("h2",{id:"the-sharing-keyword-for-modules"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"sharing")," Keyword for Modules"),(0,a.kt)("p",null,"Sharing (in SML) is stating that two types need to be the same. There are\nnumerous complexities with this. In general, if one of the types that is\nbeing shared is not abstract, then it cannot be shared."),(0,a.kt)("p",null,"Here is a really basic example of type sharing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sml"},"signature EXAMPLE =\nsig\n  type t (* abstract *)\n  type u (* abstract *)\n  sharing type t = u\nend\n")),(0,a.kt)("p",null,"This enforces that in any structure implementing ",(0,a.kt)("inlineCode",{parentName:"p"},"EXAMPLE"),", the types ",(0,a.kt)("inlineCode",{parentName:"p"},"t")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"u")," must be the same. This might seem a little silly, becaue we could easily\nwrite the following to do the same thing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sml"},"signature EXAMPLE2 =\nsig\n  type t (* abstract *)\n  type u = t\nend\n")),(0,a.kt)("p",null,"This does do the same thing. And in fact, it is prefered to the first example,\nso sharing should be avoided if possible. Yet, there are some scenarios where\nsharing is useful. For instance, enforcing two different structures use the\nsame type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sml"},"signature EXAMPLE3 =\nsig\n  type t (* abstract *)\nend\n\nsignature EXAMPLE4 =\nsig\n  structure S1 : EXAMPLE3\n  structure S2 : EXAMPLE3\n  sharing type S1.t = S2.t\nend\n")),(0,a.kt)("p",null,"In this case, the two structures ",(0,a.kt)("inlineCode",{parentName:"p"},"S1")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"S2")," must have the same type for ",(0,a.kt)("inlineCode",{parentName:"p"},"t"),",\nand without the ",(0,a.kt)("inlineCode",{parentName:"p"},"sharing")," specification this could not be enforced."))}c.isMDXComponent=!0}}]);