"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[246],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=o,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||i;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},463:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:1},r="Common Errors",s={unversionedId:"debugging/errors",id:"debugging/errors",title:"Common Errors",description:"By Eunice Chen, January 2021. Revised April 2022",source:"@site/docs/debugging/errors.md",sourceDirName:"debugging",slug:"/debugging/errors",permalink:"/book/docs/debugging/errors",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",previous:{title:"Auxiliary Library",permalink:"/book/docs/libs/aux-lib"},next:{title:"Debugging Hints and Strategies",permalink:"/book/docs/debugging/hints"}},l={},p=[{value:"Casing Issues",id:"casing-issues",level:2},{value:"Match Nonexhaustive",id:"match-nonexhaustive",level:3},{value:"Should we always be afraid of nonexhaustive warnings?",id:"should-we-always-be-afraid-of-nonexhaustive-warnings",level:4},{value:"Nested Cases",id:"nested-cases",level:3},{value:"Associativity Issues",id:"associativity-issues",level:2},{value:"Equality Type Warnings (i.e. <code>&#39;&#39;a</code> vs <code>&#39;a</code>)",id:"equality-type-warnings-ie-a-vs-a",level:2},{value:"?.t Type Errors",id:"t-type-errors",level:2},{value:"Re-declaring Datatypes",id:"re-declaring-datatypes",level:2},{value:"Forgetting a Bar",id:"forgetting-a-bar",level:2},{value:"Let in without an end",id:"let-in-without-an-end",level:2}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"common-errors"},"Common Errors"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"By Eunice Chen, January 2021"),". ",(0,o.kt)("em",{parentName:"p"},"Revised April 2022")),(0,o.kt)("p",null,"In this section, we will explore some common mistakes and errors that may occur when programming in Standard ML."),(0,o.kt)("h2",{id:"casing-issues"},"Casing Issues"),(0,o.kt)("h3",{id:"match-nonexhaustive"},"Match Nonexhaustive"),(0,o.kt)("p",null,"A Match Nonexhaustive warning occurs when your cases in a pattern matching expression, are, well, non-exhaustive. This means that there is some case/combination of constructors, values, or other pattern that could appear as an input, but is not covered in your code. A straightforward example would be a function like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},"fun addList [] = 0\n  | addList (x::y::L) = x + y + (addList L)\n")),(0,o.kt)("p",null,"What would happen if we called ",(0,o.kt)("inlineCode",{parentName:"p"},"addList [5]"),"? We couldn't match on the first clause because the list is non-empty, and we couldn't match on the second clause because we only have one cons constructor (in particular ",(0,o.kt)("inlineCode",{parentName:"p"},"5::[]"),"). SML, understandably, won't know what to do and will raise a nonexhaustive match exception and crash."),(0,o.kt)("p",null,"This can occur in other places besides function inputs. For example, consider the following function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},'fun example x =\n  case x of\n    5 => "yay!"\n  | 6 => "boo!"\n')),(0,o.kt)("p",null,"What would happen if we called ",(0,o.kt)("inlineCode",{parentName:"p"},"example 7"),"? Again, SML wouldn't know what to do (as 7 is not equal to 5 or 6) and would again raise a nonexhaustive match error. That is to say, nonexhaustive match errors can occur wherever you have some sort of pattern matched cases. In order to fix a match nonexhaustive error, simply add the case(s) that you are missing."),(0,o.kt)("h4",{id:"should-we-always-be-afraid-of-nonexhaustive-warnings"},"Should we always be afraid of nonexhaustive warnings?"),(0,o.kt)("p",null,"It is ok to have a nonexhaustive warning ",(0,o.kt)("em",{parentName:"p"},"if")," you can prove that the nonexhaustive case will never occur. An example of this is the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},'fun NE_Match x =\n  let\n    val L = [1, 2]\n  in\n    case L of\n         x::y::xs => "at least two elements!"\n       | [] => "empty!"\n  end\n')),(0,o.kt)("p",null,"While this is certainly a contrived example, even though SML will warn us of a nonexhaustive match, we have no reason to worry about it. As we can see, ",(0,o.kt)("inlineCode",{parentName:"p"},"L")," is bound to ",(0,o.kt)("inlineCode",{parentName:"p"},"[1, 2]")," (which is equivalent to ",(0,o.kt)("inlineCode",{parentName:"p"},"1::2::[]"),") and therefore will always match on the first case (it has at least two ",(0,o.kt)("inlineCode",{parentName:"p"},"cons")," constructors). This proves that ",(0,o.kt)("inlineCode",{parentName:"p"},"L")," will always match to one of our patterns, and therefore will never raise a match nonexhaustive exception. Still, it is good style to cover all cases by using a wildcard (",(0,o.kt)("inlineCode",{parentName:"p"},"_"),")."),(0,o.kt)("h3",{id:"nested-cases"},"Nested Cases"),(0,o.kt)("p",null,'When you nest case expressions within case expressions, it\'s good to wrap your case statements with parentheses. SML will continue to look for patterns to case on, so using parentheses will let it know when to "stop".'),(0,o.kt)("p",null,"For example, the following code will compile without warnings:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},'case 0 of\n  0 => (case "x" of _ => 3)\n| _ => 5\n')),(0,o.kt)("p",null,"but this code will have a match redundant error and a match nonexhaustive error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},'case 0 of\n  0 => case "x" of _ => 3\n| _ => 5\n')),(0,o.kt)("p",null,"Obviously, this example is very contrived, but adding parens may help in nested case expressions."),(0,o.kt)("h2",{id:"associativity-issues"},"Associativity Issues"),(0,o.kt)("p",null,"Since function application is left associative, making sure you have correct parenthesization is very important. It is almost always a good idea to double check your parenthesization in your code, since it can cause very confusing bugs, but can be fixed with a simple check."),(0,o.kt)("p",null,"For example, the following code will not compile:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},"fun f [] = 0\n  | f x::xs = 1\n")),(0,o.kt)("p",null,"This fails to compile because function application is left-associative, so the SML compiler thinks that ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," is the only argument to the function ",(0,o.kt)("inlineCode",{parentName:"p"},"f"),", and does not know how to parse the extra ",(0,o.kt)("inlineCode",{parentName:"p"},"::xs"),". A fix for this issue would just to put parens around the ",(0,o.kt)("inlineCode",{parentName:"p"},"x::xs"),", like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},"fun f [] = 0\n  | f (x::xs) = 1\n")),(0,o.kt)("p",null,"Similarly, if some expression is an argument to another function, it is usually good to put parens around that expression. For example, suppose we had some functions ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"g")," of type ",(0,o.kt)("inlineCode",{parentName:"p"},"int -> int"),", and we would like to apply the function ",(0,o.kt)("inlineCode",{parentName:"p"},"g")," to the value ",(0,o.kt)("inlineCode",{parentName:"p"},"f 1"),". Then, if we wrote ",(0,o.kt)("inlineCode",{parentName:"p"},"g f 1"),", this would not typecheck, since function application is left-associative (writing ",(0,o.kt)("inlineCode",{parentName:"p"},"g f 1")," would be the same thing as writing ",(0,o.kt)("inlineCode",{parentName:"p"},"((g f) 1)"),"). To fix this, we would write this as ",(0,o.kt)("inlineCode",{parentName:"p"},"g (f 1)")," to fix the associativity issues."),(0,o.kt)("h2",{id:"equality-type-warnings-ie-a-vs-a"},"Equality Type Warnings (i.e. ",(0,o.kt)("inlineCode",{parentName:"h2"},"''a")," vs ",(0,o.kt)("inlineCode",{parentName:"h2"},"'a"),")"),(0,o.kt)("p",null,"Sometimes, code will fail to typecheck because it expects something of type ",(0,o.kt)("inlineCode",{parentName:"p"},"'a")," but instead gets something of type ",(0,o.kt)("inlineCode",{parentName:"p"},"''a")," instead. A plain type variable like ",(0,o.kt)("inlineCode",{parentName:"p"},"'a")," can be substituted with any type, but something like type ",(0,o.kt)("inlineCode",{parentName:"p"},"''a")," (with two apostrophes in front) can only be substituted with an ",(0,o.kt)("em",{parentName:"p"},"equality")," type. An ",(0,o.kt)("em",{parentName:"p"},"equality")," type is a type that can use operators like ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"<>")," to compare their values (",(0,o.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"bool")," are good examples of equality types). Thus, if your code has an ",(0,o.kt)("inlineCode",{parentName:"p"},"''a")," instead of an ",(0,o.kt)("inlineCode",{parentName:"p"},"a"),", it is likely that you are using ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"<>")," to compare values."),(0,o.kt)("p",null,"For example, the following function has type ",(0,o.kt)("inlineCode",{parentName:"p"},"''a list * 'a -> bool"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},"fun contains (x, []) = false\n  | contains (x, y::ys) = x = y orelse contains (x, ys)\n")),(0,o.kt)("p",null,"Because ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," are compared by ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," in the function, then any inputs into the ",(0,o.kt)("inlineCode",{parentName:"p"},"contains")," function must consist of equality types, so the type is ",(0,o.kt)("inlineCode",{parentName:"p"},"''a list * ''a -> bool"),"."),(0,o.kt)("p",null,"However, we might want a function that takes in an ",(0,o.kt)("inlineCode",{parentName:"p"},"'a list")," instead because it is more general. We still need some way of comparing whether two elements are equal or not, so we will pass in an extra parameter to compare two elements. We can rewrite the function as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},"fun contains (cmp, x, []) = false\n  | contains (cmp, x, y::ys) =\n    case cmp (x, y) of\n      EQUAL => true\n    | _ => contains (cmp, x, ys)\n")),(0,o.kt)("p",null,"The type of the function will now be ",(0,o.kt)("inlineCode",{parentName:"p"},"('a * 'a -> order) * 'a list * 'a -> bool"),"."),(0,o.kt)("p",null,"In general, it's preferable to use ",(0,o.kt)("inlineCode",{parentName:"p"},"case")," expressions instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"if-then-else")," statements with ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," in the condition."),(0,o.kt)("h2",{id:"t-type-errors"},"?.t Type Errors"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"errors.sml:9.7-10.18 Error: right-hand-side of clause does not agree with function result type [tycon mismatch]\n  expression:  ?.t\n  result type:  ?.t\n")),(0,o.kt)("p",null,"Clearly, this is not a very helpful error message. The code that induces this error is shown below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},"signature T =\nsig\n  type t val x : t\nend\n\nfunctor Foo (structure A : T\n             structure B : T) =\nstruct\n  fun bar (0 : int) = A.x\n    | bar n = B.x\nend\n")),(0,o.kt)("p",null,"The reason for this error is because the compiler does not distinguish (in terms of name) structures that are given as argument to the functor ",(0,o.kt)("inlineCode",{parentName:"p"},"Foo"),". Both are referred to by ",(0,o.kt)("inlineCode",{parentName:"p"},"?"),". In other words, it is saying that, on the second line of ",(0,o.kt)("inlineCode",{parentName:"p"},"bar"),", it expected a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A.t")," to be returned, but received one of type ",(0,o.kt)("inlineCode",{parentName:"p"},"B.t"),", namely ",(0,o.kt)("inlineCode",{parentName:"p"},"B.x"),". Since ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," do not really have names, however, it just referred to either structure as ",(0,o.kt)("inlineCode",{parentName:"p"},"?"),", causing the confusing error."),(0,o.kt)("p",null,"If you receive this error, check your structures to make sure that you are not conflating types from different structures."),(0,o.kt)("h2",{id:"re-declaring-datatypes"},"Re-declaring Datatypes"),(0,o.kt)("p",null,"Some datatypes are already present in the SML Basis Library, meaning that you do not have to declare them, as they are already present at the top level. Re-declaring datatypes anyways, however, can cause type issues that are somewhat difficult to debug. Consider the following code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},"fun opt_wrap x = SOME x\n\ndatatype 'a option = NONE | SOME of 'a\n\nfun wrap_again (x : int) : int option = opt_wrap x\n")),(0,o.kt)("p",null,"Although it looks innocuous, we will run into the following type error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"errors.sml:5.5-5.51 Error: right-hand-side of clause does not agree with function result type [tycon mismatch]\n  expression:  int ?.Assembly.option\n  result type:  int option\n")),(0,o.kt)("p",null,"The reason for this is because the declaration of ",(0,o.kt)("inlineCode",{parentName:"p"},"'a option")," on the third line creates a new type ",(0,o.kt)("inlineCode",{parentName:"p"},"'a option"),' that "shadows" the basis\' definition. This means that on line 1, ',(0,o.kt)("inlineCode",{parentName:"p"},"SOME")," is of the type of the original option, whereas the function ",(0,o.kt)("inlineCode",{parentName:"p"},"wrap_again")," is type-annotated to expect a value of the type of the ",(0,o.kt)("em",{parentName:"p"},"new")," option."),(0,o.kt)("p",null,"In general, re-declaring datatypes is a bad idea that will cause conflicts down the road, as it makes your code incompatible with any other code expecting the original datatype, such as autograders. Be sure to not re-declare datatypes that already exist to avoid this issue."),(0,o.kt)("h2",{id:"forgetting-a-bar"},"Forgetting a Bar"),(0,o.kt)("p",null,"Recall that a bar ",(0,o.kt)("inlineCode",{parentName:"p"},"|")," is required to delimit different clauses in a function definition. For instance, take the following (incorrect) implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"fact")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},"fun fact (0 : int) : int = 1\n    fact n = n * fact (n - 1)\n")),(0,o.kt)("p",null,"Compiling this will result in the error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"errors.sml:2.24 Error: unbound variable or constructor: n\nerrors.sml:2.14 Error: unbound variable or constructor: n\nerrors.sml:2.10 Error: unbound variable or constructor: n\nerrors.sml:1.29-2.30 Error: operator is not a function [overload - bad instantiation]\n  operator: 'Z[INT]\n  in expression:\n    1 fact\nerrors.sml:1.6-2.30 Error: right-hand-side of clause does not agree with function result type [tycon mismatch]\n  expression:  bool\n  result type:  int\n  in declaration:\n    fact =\n      (fn 0 : int =>\n            (1 fact) <errorvar> = <errorvar> * fact (<errorvar> - 1): int)\n")),(0,o.kt)("p",null,"If you see ",(0,o.kt)("inlineCode",{parentName:"p"},"unbound variable or constructor")," errors where they don't make sense, and should not be unbound, it may be the case that you are having a deeper syntax issue!"),(0,o.kt)("h2",{id:"let-in-without-an-end"},"Let in without an end"),(0,o.kt)("p",null,"Consider the following code snippet:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sml"},"fun foo x =\n  let\n    val y =\n      let\n        val z = 3\n      in\n  in\n    4\n  end\n")),(0,o.kt)("p",null,"Compiling this will result in the error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'errors.sml:6.7-6.9 Error: syntax error: replacing  IN with  SEMICOLON\nerrors.sml:11.1 Error: syntax error found at EOF\n\nuncaught exception Compile [Compile: "syntax error"]\n  raised at: ../compiler/Parse/main/smlfile.sml:19.24-19.46\n             ../compiler/TopLevel/interact/evalloop.sml:45.54\n             ../compiler/TopLevel/interact/evalloop.sml:306.20-306.23\n')),(0,o.kt)("p",null,"due to the missing ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," at the end of the inner ",(0,o.kt)("inlineCode",{parentName:"p"},"let"),'. In general, an error that says "replacing" is trying to signal that you have probably put an unexpected form of syntax where it shouldn\'t be - look at precisely what is missing to determine what the error is.'))}c.isMDXComponent=!0}}]);