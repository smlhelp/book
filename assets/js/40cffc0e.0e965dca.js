"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[95],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1203:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:1},r="Evaluation",l={unversionedId:"concepts/basic/eval",id:"concepts/basic/eval",title:"Evaluation",description:"By Brandon Wu, May 2020",source:"@site/docs/concepts/basic/eval.md",sourceDirName:"concepts/basic",slug:"/concepts/basic/eval",permalink:"/book/docs/concepts/basic/eval",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",previous:{title:"Basics",permalink:"/book/docs/concepts/basic/"},next:{title:"Extensional Equivalence",permalink:"/book/docs/concepts/basic/eeq"}},s={},p=[{value:"Expressions and Values",id:"expressions-and-values",level:2},{value:"Reduction",id:"reduction",level:2},{value:"Eager Evaluation",id:"eager-evaluation",level:2}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"evaluation"},"Evaluation"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"By Brandon Wu, May 2020")),(0,i.kt)("p",null,"Evaluation is a commonplace idea. No matter what programming language you are in, it is a customary concept to invoke subroutines in order to obtain some kind of ",(0,i.kt)("em",{parentName:"p"},"final result"),", which can be further used in order to achieve some later goal. To obtain such a result, however, programs must perform certain computations and carry out certain steps - in other words, they must ",(0,i.kt)("em",{parentName:"p"},"evaluate"),". Ultimately, programs are complicated constructs whose main goal is to compute some value or achieve some effect - we will focus mainly on the first case here."),(0,i.kt)("h2",{id:"expressions-and-values"},"Expressions and Values"),(0,i.kt)("p",null,"Expressions in Standard ML are akin to mathematical expressions. They are built up from applications of certain operations, being subject to certain simplification rules that can be used to obtain a final answer. For instance, we would consider ",(0,i.kt)("inlineCode",{parentName:"p"},"2 + 2")," an expression, similarly to other examples such as ",(0,i.kt)("inlineCode",{parentName:"p"},"1 div 0")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Int.toString 2"),"."),(0,i.kt)("p",null,"The most fundamental building blocks in Standard ML are ",(0,i.kt)("em",{parentName:"p"},"values"),'. Values are the primordial units of a given type, being irreducible to any further simplified form. When trying to answer some computational problem, it is usually the case that we are looking for some kind of "answer". As such, values are important to obtain, as we are usually looking for some kind of answer in "simplest terms". Values in SML encompass examples such as ',(0,i.kt)("inlineCode",{parentName:"p"},"2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"foo"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 2, 3]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fn x => x + 1"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"[Value]")," A value is an expression ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," such that, for all ",(0,i.kt)("inlineCode",{parentName:"p"},"e'")," such that ",(0,i.kt)("inlineCode",{parentName:"p"},"e ==> e'"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"e' = e"),". In other words, a value is an expression that only reduces to itself - there is no pending computation left to be done.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE:")," The meaning of ",(0,i.kt)("inlineCode",{parentName:"p"},"==>")," in the above definition is ",(0,i.kt)("em",{parentName:"p"},"reduction"),", which is further explained below."),(0,i.kt)("p",null,"A noteworthy distinction to make is that certain language constructs, such as an if-then-else expression, let-in-end expression, or case expression, are in fact ",(0,i.kt)("em",{parentName:"p"},"expressions"),". This means that they can be passed around and evaluated just like any other expression. So for instance, the following code is a valid expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"(let\n    val x = 5\nin\n    x\nend) + 2\n")),(0,i.kt)("p",null,"and has the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"7"),". Similarly, the following code is also an expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"(if true then 15 else 150) * 2\n")),(0,i.kt)("p",null,"and has a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"30"),"."),(0,i.kt)("h2",{id:"reduction"},"Reduction"),(0,i.kt)("p",null,"We now define a notion of ",(0,i.kt)("em",{parentName:"p"},"reduction"),", which corresponds to our notion of simplification. We write that ",(0,i.kt)("inlineCode",{parentName:"p"},"e ==> e'")," if the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," ",(0,i.kt)("em",{parentName:"p"},"reduces to")," the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"e'"),", which means that ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," produces ",(0,i.kt)("inlineCode",{parentName:"p"},"e'")," from zero or more applications of some simplifying rule. For instance, we may say that ",(0,i.kt)("inlineCode",{parentName:"p"},"2 + 2 ==> 4"),", since by applying the function ",(0,i.kt)("inlineCode",{parentName:"p"},"(op +)"),", we obtain ",(0,i.kt)("inlineCode",{parentName:"p"},"4"),". Furthermore, we may say that ",(0,i.kt)("inlineCode",{parentName:"p"},'if true then "good" else "bad" ==> "good"')," by evaluation of the if-then-else expression, since the predicate (in this case ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") is true."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"==>")," is ",(0,i.kt)("em",{parentName:"p"},"not")," valid SML code, it is simply our shorthand for the idea of reduction."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"[Valuable]")," An expression ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is ",(0,i.kt)("em",{parentName:"p"},"valuable")," if there exists a value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," such that ",(0,i.kt)("inlineCode",{parentName:"p"},"e ==> v"),". Note that all values are by definition valuable.")),(0,i.kt)("p",null,"So valuable expressions include ",(0,i.kt)("inlineCode",{parentName:"p"},"2 + 2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"4"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"if true then 4 else 2")," (and in fact all reduce to the same value!). An example of a ",(0,i.kt)("em",{parentName:"p"},"non"),"-valuable expression is ",(0,i.kt)("inlineCode",{parentName:"p"},"1 div 0"),", which raises an exception ",(0,i.kt)("inlineCode",{parentName:"p"},"Div")," when evaluated (since division by zero is undefined). Additionally, if we consider the following code fragment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"fun loop (x : int) : int = loop x\n")),(0,i.kt)("p",null,"This defines a function ",(0,i.kt)("inlineCode",{parentName:"p"},"loop : int -> int")," that loops forever, since it continuously calls itself forever. Thus, ",(0,i.kt)("inlineCode",{parentName:"p"},"loop x")," for any ",(0,i.kt)("inlineCode",{parentName:"p"},"x : int")," is also a non-valuable expression, since it never reduces down to a value."),(0,i.kt)("p",null,"In fact, what we will see is that this behavior is sufficient to characterize ",(0,i.kt)("em",{parentName:"p"},"all")," well-typed expressions. We summarize it in the following:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"[Behavior of Well-Typed Expressions]")," For any well-typed expression ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),", it either:"),(0,i.kt)("ol",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ol"},"Reduces to a value"),(0,i.kt)("li",{parentName:"ol"},"Loops forever"),(0,i.kt)("li",{parentName:"ol"},"Raises an exception"))),(0,i.kt)("h2",{id:"eager-evaluation"},"Eager Evaluation"),(0,i.kt)("p",null,"SML is an ",(0,i.kt)("em",{parentName:"p"},"eagerly evaluated"),(0,i.kt)("sup",{parentName:"p",id:"fnref-1"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," language. This stands opposed to other paradigms such as ",(0,i.kt)("em",{parentName:"p"},"lazy"),' evaluation, which is exhibited in languages such as Haskell. In an eagerly evaluated language, we evaluate arguments of functions even if we may not need them. While this arguably may be "wasteful" in some cases, we will find that this greatly simplifies work/span analysis, among other benefits.'),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"[Eager Evaluation]")," In an eagerly evaluated language, arguments of functions are evaluated ",(0,i.kt)("em",{parentName:"p"},"before")," stepping into the body of a function. For a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and valuable expression ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),", when evaluating the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"f e"),", first ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is evaluated to obtain the value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," such that ",(0,i.kt)("inlineCode",{parentName:"p"},"e ==> v"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"f v")," is evaluated.")),(0,i.kt)("p",null,"As an example of this, consider the function ",(0,i.kt)("inlineCode",{parentName:"p"},"fn x => x + 1"),". If we were to try and evaluate ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn x => x + 1) (2 * 3)"),", first we would need to evaluate the function's arguments, that being ",(0,i.kt)("inlineCode",{parentName:"p"},"2 * 3"),". As such, this entire expression would reduce to ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn x => x + 1) 6"),", which is ",(0,i.kt)("inlineCode",{parentName:"p"},"7"),"."),(0,i.kt)("p",null,"In an example like the previous one, it doesn't particularly matter where we evaluated ",(0,i.kt)("inlineCode",{parentName:"p"},"2 * 3")," - we would have gotten the same result either way. This is not always the case. Consider the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn x => 2) (1 div 0)"),". By eager evaluation, we should evaluate the argument first, which means that this entire expression should raise an exception. Raising an exception thus happens ",(0,i.kt)("em",{parentName:"p"},"before we even look at the body of the function"),'. For all intents and purposes, the body of the function does not exist to us until we actually enter it - which necessitates that the argument to the function is valuable. It is a black box that is "locked" behind the argument.'),(0,i.kt)("div",{className:"footnotes"},(0,i.kt)("hr",{parentName:"div"}),(0,i.kt)("ol",{parentName:"div"},(0,i.kt)("li",{parentName:"ol",id:"fn-1"},"In other languages, we may instead say ",(0,i.kt)("em",{parentName:"li"},"call-by-value"),", which is a separate but closely related concept.",(0,i.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}c.isMDXComponent=!0}}]);