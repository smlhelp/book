"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[936],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,h=c["".concat(l,".").concat(d)]||c[d]||m[d]||o;return n?i.createElement(h,a(a({ref:t},u),{},{components:n})):i.createElement(h,a({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var p=2;p<o;p++)a[p]=n[p];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8269:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var i=n(7462),r=(n(7294),n(3905));const o={},a="Trees",s={unversionedId:"concepts/recursion/tree",id:"concepts/recursion/tree",title:"Trees",description:"By Len Huang, August 2020",source:"@site/docs/concepts/recursion/tree.md",sourceDirName:"concepts/recursion",slug:"/concepts/recursion/tree",permalink:"/book/docs/concepts/recursion/tree",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Tail Recursion",permalink:"/book/docs/concepts/recursion/tail"},next:{title:"Asymptotic Analysis",permalink:"/book/docs/concepts/asymptotic/"}},l={},p=[{value:"Inductive Intuition",id:"inductive-intuition",level:2},{value:"An Exploration of Tree Sums",id:"an-exploration-of-tree-sums",level:2},{value:"1. Solving for the Base Cases",id:"1-solving-for-the-base-cases",level:3},{value:"2. Define the Inductive Hypothesis",id:"2-define-the-inductive-hypothesis",level:3},{value:"3. Assume the Inductive Hypothesis to Show the Inductive Step.",id:"3-assume-the-inductive-hypothesis-to-show-the-inductive-step",level:3},{value:"QED",id:"qed",level:2}],u={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"trees"},"Trees"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"By Len Huang, August 2020")),(0,r.kt)("p",null,"There's a strong association between mathematical induction and recursion, especially in SML. Often times, we'll be able to use similar vocabularies when describing SML problems and mathematical induction. In particular, we're going to be use the words ",(0,r.kt)("strong",{parentName:"p"},"base case, induction hypothesis, and induction step")," to describe both types of problems."),(0,r.kt)("h2",{id:"inductive-intuition"},"Inductive Intuition"),(0,r.kt)("p",null,"Approaching induction proofs can fall along the following line of logic:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Solve the ",(0,r.kt)("strong",{parentName:"li"},"base cases"),"."),(0,r.kt)("li",{parentName:"ol"},"Define the ",(0,r.kt)("strong",{parentName:"li"},"inductive hypothesis"),"."),(0,r.kt)("li",{parentName:"ol"},"Assume the correctness of the ",(0,r.kt)("strong",{parentName:"li"},"inductive hypothesis")," to show the correctness of the ",(0,r.kt)("strong",{parentName:"li"},"inductive step"),".")),(0,r.kt)("p",null,"We can similarly apply this line of logic to solving problems with SML functions! Let's take a look at a common recursive problem. ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum")," takes an int tree and returns the sum of all the integers in that tree. By the end of this, we'll be able to implement recursive functions with the following inductive logic:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun treeSum (Empty : int tree) : int = 0\n  | treeSum (Node(L,x,R)) = treeSum(L) + treeSum(R) + x\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The ",(0,r.kt)("strong",{parentName:"p"},"base case")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum")," is that an ",(0,r.kt)("inlineCode",{parentName:"p"},"Empty")," tree has a sum of 0. Let's define the ",(0,r.kt)("strong",{parentName:"p"},"inductive hypothesis")," to be that for some tree ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),", that ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum")," is correct for its left subtree and right subtree. Define my ",(0,r.kt)("strong",{parentName:"p"},"inductive step")," to be for a tree ",(0,r.kt)("inlineCode",{parentName:"p"},"T = Node(L,x,R)"),". By the definition of trees, I know that all integers in ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," are represented by the integers in ",(0,r.kt)("inlineCode",{parentName:"p"},"L"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"R"),", and the integer ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),". If I sum all of these, I will get ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum(T)"),". By assuming the ",(0,r.kt)("strong",{parentName:"p"},"IH"),", I can say that ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum L")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum R")," are correct. Therefore, by math, I will say that ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum T = (treeSum L) + (treeSum R) + x")," is correct by the above reasoning. As such, I've shown my ",(0,r.kt)("strong",{parentName:"p"},"IS")," to be correct, and thus the theorem that ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum T")," is correct for all ",(0,r.kt)("inlineCode",{parentName:"p"},"T : int tree"),".")),(0,r.kt)("h2",{id:"an-exploration-of-tree-sums"},"An Exploration of Tree Sums"),(0,r.kt)("p",null,"Let's define ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum"),". This function should take in an ",(0,r.kt)("inlineCode",{parentName:"p"},"int tree")," and return the sum of all the integers in that tree."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"datatype int tree = Empty | Node of int tree * int * int\n\nfun treeSum (T : int tree) : int = ...\n")),(0,r.kt)("p",null,"Note that in SML, the ",(0,r.kt)("inlineCode",{parentName:"p"},"tree")," datatype is recursively defined. This is a good hint that we should be using recursive/inductive strategies to approach this problem. Consider the proof of the following theorem:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Theorem:")," For all ",(0,r.kt)("inlineCode",{parentName:"p"},"T : int tree"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum T")," is correct.")),(0,r.kt)("p",null,"Let's not worry about formalizing this proof too much so that we can focus on the ",(0,r.kt)("strong",{parentName:"p"},"inductive intuition")," of it. If we were to prove this using induction, we'll need a ",(0,r.kt)("strong",{parentName:"p"},"(1) base case, (2) induction hypothesis, and (3) induction step.")),(0,r.kt)("h3",{id:"1-solving-for-the-base-cases"},"1. Solving for the Base Cases"),(0,r.kt)("p",null,"Let's first think about proving the base case: ",(0,r.kt)("inlineCode",{parentName:"p"},"T = Empty"),". What does it mean for ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum Empty")," to be correct? Well, an ",(0,r.kt)("inlineCode",{parentName:"p"},"Empty")," tree does not have any nodes, and if there are no nodes, there are no ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," values. The sum of nothing is 0. Let's write that in a proof-like manner:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Base Case:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"T = Empty")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"treeSum(Empty) ==> 0")," because an ",(0,r.kt)("inlineCode",{parentName:"li"},"Empty")," int tree does not have an int value."))),(0,r.kt)("p",null,"That wasn't so bad! If we have an empty node, we can't have a value there, and so the sum is 0. Before we move on to solving the recursive step, let's tie in this idea of how recursion and induction are related. In our proof, we say that ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum Empty")," is correct when it evaluates to 0. Let's use this as an answer to how to define the base case of our function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun treeSum (Empty : int tree): int = 0\n")),(0,r.kt)("p",null,"Nice job! We've leveraged inductive reasoning to help us define the base case for our recursive problem. Let's move on to something a little harder and may be less obvious than what we've done here."),(0,r.kt)("h3",{id:"2-define-the-inductive-hypothesis"},"2. Define the Inductive Hypothesis"),(0,r.kt)("p",null,"The next step in our proof is to define the inductive hypothesis. Here, we'll assume the correctness of a smaller part, then use that to prove the correctness of a bigger part. More specifically, we'll be using some ideas of structural induction for this problem. Let's elaborate more on that:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Induction Hypothesis:")," Assume for all ",(0,r.kt)("inlineCode",{parentName:"p"},"L : int tree")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"R : int tree")," that ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum L")," is correct and ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum R")," is correct.")),(0,r.kt)("p",null,"Because we've shown our base case to be true, let's assume tha for the recursive structures (the left subtree ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," and the right subtree ",(0,r.kt)("inlineCode",{parentName:"p"},"R"),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum")," is correct. Just like how in induction we can use these nuggets of information to help us prove our ",(0,r.kt)("strong",{parentName:"p"},"inductive step"),", we can do the same to help us solve the SML function."),(0,r.kt)("h3",{id:"3-assume-the-inductive-hypothesis-to-show-the-inductive-step"},"3. Assume the Inductive Hypothesis to Show the Inductive Step."),(0,r.kt)("p",null,"What nuggets of information do we know from the previous step, and how can we use that to help us with inductive step? We assume that both ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum L")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum R")," are correct by the ",(0,r.kt)("strong",{parentName:"p"},"inductive hypothesis (IH)"),". Since they are correct, their outputs represent the sum of all the integers in them. For ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum L")," is the sum of all integers in the int tree ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," and for ",(0,r.kt)("inlineCode",{parentName:"p"},"treeSum R")," is the sum of all integers in the int tree ",(0,r.kt)("inlineCode",{parentName:"p"},"R"),"."),(0,r.kt)("p",null,"We also know that since ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"R")," are the left and right subtrees of ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),", by definition, they represent all nodes of ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," (except the root node). Then, to get sum of ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),", we just need the sum of ",(0,r.kt)("inlineCode",{parentName:"p"},"L"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"R"),", and the value of the root node! Let's proof-ify this line of thought a bit more:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Inductive Step:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"T = Node(L,x,R)")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"treeSum L")," is correct by ",(0,r.kt)("strong",{parentName:"li"},"IH")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"treeSum R")," is correct by ",(0,r.kt)("strong",{parentName:"li"},"IH")),(0,r.kt)("li",{parentName:"ul"},'"All integers in ',(0,r.kt)("inlineCode",{parentName:"li"},"T"),'" are represented by "all integers in ',(0,r.kt)("inlineCode",{parentName:"li"},"L"),'", "all integers in ',(0,r.kt)("inlineCode",{parentName:"li"},"R"),'", and ',(0,r.kt)("inlineCode",{parentName:"li"},"x")," by definition of trees."),(0,r.kt)("li",{parentName:"ul"},'The sum of "all integers in ',(0,r.kt)("inlineCode",{parentName:"li"},"T"),'" is the sum of "all integers in ',(0,r.kt)("inlineCode",{parentName:"li"},"L"),', "all integers in ',(0,r.kt)("inlineCode",{parentName:"li"},"R"),'", and the integer ',(0,r.kt)("inlineCode",{parentName:"li"},"x"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"treeSum T = (treeSum L) + (treeSum R) + x")," by definition of ",(0,r.kt)("inlineCode",{parentName:"li"},"treeSum"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(treeSum L) + (treeSum R) + x")," is correct by math and above logic."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"treeSum T")," is correct by substitution."))),(0,r.kt)("p",null,"Using the logic needed to complete the proof, we were able to arrive at how to implement our function! Let's translate the above logic into SML:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun treeSum (Empty : int tree) : int = 0\n  | treeSum (Node(L,x,R)) = (treeSum L) + (treeSum R) + x\n")),(0,r.kt)("h2",{id:"qed"},"QED"),(0,r.kt)("p",null,"And like that, we're able to leverage mathematical induction to help us find the solution to part of an SML function. For some, this intuition is obvious. But for others, it isn't! A deep spiral of pure math and proving every single aspect of your code isn't usually needed. ",(0,r.kt)("strong",{parentName:"p"},"BUT"),", it will definitely be helpful to adopt this style of thinking when approaching more difficult and advanced recursion problems. Whenever you're trying to implement a recursive function in SML, remember to think inductively!"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Solve the ",(0,r.kt)("strong",{parentName:"li"},"base cases"),"."),(0,r.kt)("li",{parentName:"ol"},"Define the ",(0,r.kt)("strong",{parentName:"li"},"inductive hypothesis"),"."),(0,r.kt)("li",{parentName:"ol"},"Assume the correctness of the ",(0,r.kt)("strong",{parentName:"li"},"inductive hypothesis")," to show the correctness of the ",(0,r.kt)("strong",{parentName:"li"},"inductive step"),".")))}m.isMDXComponent=!0}}]);