"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[1373],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>u});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),h=p(a),u=i,d=h["".concat(l,".").concat(u)]||h[u]||c[u]||o;return a?n.createElement(d,s(s({ref:t},m),{},{components:a})):n.createElement(d,s({ref:t},m))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,s=new Array(o);s[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var p=2;p<o;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8882:(e,t,a)=>{a.d(t,{B:()=>o});var n=a(7294);const i="center_wFZg";function o(e){return n.createElement("figure",{className:i},e.figure?e.figure:n.createElement("img",{src:e.img,alt:e.alt}),n.createElement("figcaption",null,n.createElement("b",null,"Fig ",e.idx,".")," ",e.children))}},293:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>N,contentTitle:()=>w,default:()=>b,frontMatter:()=>f,metadata:()=>g,toc:()=>y});var n=a(7462),i=(a(7294),a(3905)),o=a(8882);const s=a.p+"assets/images/cps-509ed7e328cb9f05362c34332715a8a5.png",r=a.p+"assets/images/updown-9439f07c60ac6bc4a12edddb1f3b5424.png",l=a.p+"assets/images/stack-fc9b47abba6f98a6684f330fd0453c55.png",p=a.p+"assets/images/donut-4366edb0dfa640e15c68ee0b04572b68.png",m=a.p+"assets/images/cpsTree-bf7b5c4f6e3a852a0f3e7c247e7871e7.png",c=a.p+"assets/images/phase1-934d90d81c109984f015d3e212b2230d.png",h=a.p+"assets/images/phase2-72e807f8327a8544f36eb00f347ede9c.png",u=a.p+"assets/images/phase3-fa558e35280476ea5833f6d56d8a36ab.png",d=a.p+"assets/images/phase4-62524da0c1b8809ffeeba6008969705a.png",k=a.p+"assets/images/phase5-69ad186180ccc5dd12f9787ed6f71536.png",f={sidebar_position:1},w="Continuation Passing Style",g={unversionedId:"concepts/control-flow/cps",id:"concepts/control-flow/cps",title:"Continuation Passing Style",description:"By Brandon Wu, June 2020. Revised March 2022",source:"@site/docs/concepts/control-flow/cps.mdx",sourceDirName:"concepts/control-flow",slug:"/concepts/control-flow/cps",permalink:"/book/docs/concepts/control-flow/cps",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",previous:{title:"Control Flow",permalink:"/book/docs/concepts/control-flow/"},next:{title:"Exceptions",permalink:"/book/docs/concepts/control-flow/exn"}},N={},y=[{value:"Continuation Passing Style: The Idea",id:"continuation-passing-style-the-idea",level:2},{value:"Continuation Passing Style: A Case Study",id:"continuation-passing-style-a-case-study",level:2},{value:"Continuation Passing Style: The Definition",id:"continuation-passing-style-the-definition",level:2},{value:"Continuation Passing Style: A Case Study v2.0",id:"continuation-passing-style-a-case-study-v20",level:2},{value:"Continuation Passing Style: A Case Study in Success and Failure",id:"continuation-passing-style-a-case-study-in-success-and-failure",level:2},{value:"Conclusions",id:"conclusions",level:2}],v={toc:y};function b(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},v,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"continuation-passing-style"},"Continuation Passing Style"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"By Brandon Wu, June 2020. Revised March 2022")),(0,i.kt)("p",null,"We have seen how we can write functions that are ",(0,i.kt)("em",{parentName:"p"},"tail recursive"),", in that they only make recursive calls as ",(0,i.kt)("em",{parentName:"p"},"tail calls"),", where the recursive calls is the last thing that the function does (i.e. there is no deferred work). This commonly was realized by implementing the tail-recursive function with an ",(0,i.kt)("em",{parentName:"p"},"accumulator"),", which simply stored the intermediate values that were computed. In this section, we will explore an concept known as ",(0,i.kt)("em",{parentName:"p"},"continuation-passing style"),", which sees the use of ",(0,i.kt)("em",{parentName:"p"},"functions as accumulators"),", which lets us use more explicit logic when encoding the control flow of our programs, as well as the intermediate results of our computations."),(0,i.kt)("h2",{id:"continuation-passing-style-the-idea"},"Continuation Passing Style: The Idea"),(0,i.kt)("p",null,"Consider the computation of ",(0,i.kt)("inlineCode",{parentName:"p"},"(2 + 3) * 4"),"."),(0,i.kt)("p",null,"Clearly, there is an ordering to how we should evaluate this. We should sum ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," first, then take the ",(0,i.kt)("em",{parentName:"p"},"result of that")," and multiply it by ",(0,i.kt)("inlineCode",{parentName:"p"},"4"),'. There is kind of a catch here, that is quickly glossed over by our human brains - we refer to "the result of that" rather casually. We haven\'t explicitly named it, but we nonetheless make an appeal to intuition to get our point across.'),(0,i.kt)("p",null,"How else might we represent this computation? Well, we could use lambda expressions, and then use the power of function application to compute the result. Then, we might obtain that this is akin to evaluating ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn res => res * 4) (2 + 3)"),'. This would be a more direct translation of the idea of "add 2 and 3, then pass the result of that to 4". We note that, in the process, we have explicitly made clear what we mean by "the result of that" - it is now bound to a name, that being ',(0,i.kt)("inlineCode",{parentName:"p"},"res"),"."),(0,i.kt)("p",null,'We can take this one step further. If we think about it a bit more, we might want to consider starting at a "single" value, so that we don\'t have to consider the operation of ',(0,i.kt)("inlineCode",{parentName:"p"},"2 + 3"),' as one step. Then, we might instead write "take 2, add the previous result to 3, and then multiply the previous result by 4". Clearly, we have now made it deliberate that we are passing around a ',(0,i.kt)("em",{parentName:"p"},"single value")," that we are performing operations on at each step. How would we write this as a lambda expression, however?"),(0,i.kt)("p",null,"We might write ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn res => (fn res2 => res2 * 4) (res + 3)) 2")," to encode the previous instructions. This essentially makes ",(0,i.kt)("inlineCode",{parentName:"p"},"res")," the ",(0,i.kt)("em",{parentName:"p"},"first"),' "previous result", and then the result of ',(0,i.kt)("inlineCode",{parentName:"p"},"2 + 3")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"res2"),", the ",(0,i.kt)("em",{parentName:"p"},"second"),' "previous result". Make sure you understand what is happening here - we are binding ',(0,i.kt)("inlineCode",{parentName:"p"},"2")," to the identifier ",(0,i.kt)("inlineCode",{parentName:"p"},"res"),", then binding the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"res + 3")," to the identifier ",(0,i.kt)("inlineCode",{parentName:"p"},"res2"),"."),(0,i.kt)("p",null,"However, it is still on us to provide the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),". We to somehow encode the notion of the ",(0,i.kt)("em",{parentName:"p"},"computation")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"(2 + 3) * 4"),', not necessarily evaluating the expression ourselves. We know that placing an expression within the confines of a lambda expression will "freeze" the computation, causing it to only resume once the lambda expression is given an input, so what we can do is simply do the same with a trivial input. Our trivial input here will be ',(0,i.kt)("inlineCode",{parentName:"p"},"()"),", or unit, since we always have access to it, and there is only one value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),"."),(0,i.kt)("p",null,"So somehow, we can encode the idea of this expression with ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn () => (fn res => (fn res2 => res2 * 4) (res + 3)) 2)"),". Seen in this way, we have somehow encoded the desired expression not by actually executing it, but forming some large function ",(0,i.kt)("em",{parentName:"p"},"a priori")," that essentially does the same thing. We thus form a correspondence between evaluating an expression by ",(0,i.kt)("em",{parentName:"p"},"carrying out each step in real time")," and by ",(0,i.kt)("em",{parentName:"p"},"writing out the steps to be done at a later time"),". We hope to show that two are really equivalent - this will be important to understand for later."),(0,i.kt)("h2",{id:"continuation-passing-style-a-case-study"},"Continuation Passing Style: A Case Study"),(0,i.kt)("p",null,"We will now discuss continuation passing style more explicitly."),(0,i.kt)("p",null,"It is hopefully clear that the previous example of ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn () => (fn res => (fn res2 => res2 * 4) (res + 3)) 2)")," encodes, in some form, the ",(0,i.kt)("em",{parentName:"p"},"idea")," of the computation of the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"(2 + 3) * 4"),". Somewhat key, however, is that computation ",(0,i.kt)("em",{parentName:"p"},"does not execute")," until we actually feed a unit to it. It is important to note the distinction between ",(0,i.kt)("em",{parentName:"p"},"doing something")," and ",(0,i.kt)("em",{parentName:"p"},"writing the instructions to do something"),". A continuation can be thought of as a ",(0,i.kt)("em",{parentName:"p"},"blueprint"),", or a ",(0,i.kt)("em",{parentName:"p"},"contingency plan"),". We will expand more on what we mean by this shortly, but a continuation essentially represents ",(0,i.kt)("em",{parentName:"p"},"what instructions need to be executed"),". This is a very powerful idea, because programs can continuously alter continuations by adding more instructions or even executing different continuations in order to determine what computations ultimately need to be executed."),(0,i.kt)("p",null,"We will first consider a simple example before going into the definition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"(* factCPS : int -> (int -> 'a) -> 'a *)\n(* REQUIRES: true *)\n(* ENSURES: factCPS n k ~= k (n!) *)\nfun factCPS 0 k = k 1\n  | factCPS n k = factCPS (n-1) (fn res => k (n * res))\n")),(0,i.kt)("p",null,"Here, ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS")," takes in two arguments - one is the counter for the factorial function (as normal), and the other is the ",(0,i.kt)("em",{parentName:"p"},"continuation"),". In this case, the continuation is a function from ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> 'a"),". The idea here is that the continuation should represent what work is ",(0,i.kt)("em",{parentName:"p"},"left to do"),". It is left polymorphic, however, in order to give the user control over what they want the function to do. In order to compute the factorial of ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," directly, one could just evaluate ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS n Fn.id"),", however we grant more versatility to the user in that they are not ",(0,i.kt)("em",{parentName:"p"},"just")," constrained to computing the factorial. If one wanted a textual representation of the factorial of ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),", they could evaluate ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS n Int.toString"),", for instance. This way, we get additional versatility out of our implementation."),(0,i.kt)("p",null,"We will now consider a trace of ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS 3 Int.toString")," to fully understand the mechanism by which it works."),(0,i.kt)(o.B,{img:s,alt:"CPS Trace",idx:1,mdxType:"Figure"},"Code trace of the evaluation of ",(0,i.kt)("code",null,"factCPS 3 Int.toString")),(0,i.kt)("p",null,"As we can see, this code trace does correctly result in ",(0,i.kt)("inlineCode",{parentName:"p"},"Int.toString 6"),", which is our desired result. Of particular interest to our analysis is the ",(0,i.kt)("em",{parentName:"p"},"continuation")," of the function, which seems to grow with every line through ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS"),"'s recursion, until ultimately being reduced down step-wise until it yields our final result."),(0,i.kt)("p",null,"The colors in the image denote the difference between the ",(0,i.kt)("em",{parentName:"p"},"current")," value of ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," and the new, ",(0,i.kt)("em",{parentName:"p"},"constructed")," k. For instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," is originally ",(0,i.kt)("inlineCode",{parentName:"p"},"Int.toString")," (which is the blue-colored text), however it is eventually wrapped in ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn res => ... (3 * res))"),", which is the RHS of the call to ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS 3 Int.toString"),'. Thus, the "inner" ',(0,i.kt)("inlineCode",{parentName:"p"},"k"),' in the third line is in orange, to signify that it is in fact the same as the entire continuation from the previous line (also in orange), which is the "previous" ',(0,i.kt)("inlineCode",{parentName:"p"},"k"),". Seen in this way, all that each recursive call seems to be doing is appending a layer to the continuation, while the inside remains the same."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE:")," The definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS")," says that the input to each lambda expression should be named ",(0,i.kt)("inlineCode",{parentName:"p"},"res"),". In order to make understanding clearer and avoid namespace collisions, we have opted to name it ",(0,i.kt)("inlineCode",{parentName:"p"},"res"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"res2"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"res3"),", on each recursive call to ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS"),". Note that this renaming does not affect the evaluation of ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS 3 Int.toString")," and does keep it exactly equivalent to how it is actually evaluated.",(0,i.kt)("sup",{parentName:"p",id:"fnref-1"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))),(0,i.kt)("p",null,"So hopefully now we are convinced of ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS"),"'s correctness.",(0,i.kt)("sup",{parentName:"p",id:"fnref-2"},(0,i.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," What might not be evident, however, is ",(0,i.kt)("em",{parentName:"p"},"why"),"."),(0,i.kt)("p",null,'Recall our previous metaphor with regards to writing down instructions. It is hopefully not too difficult to see that this large lambda expression that we are constructing is akin to writing down instructions - we specify the operations that should occur when it is ultimately "collapsed" (by being given an input value), but nothing actually occurs until then. It merely encodes that information in the meantime. The next diagram will attempt to more specifically show this relationship between the "instructions" and how it arises from the definition of ',(0,i.kt)("inlineCode",{parentName:"p"},"factCPS"),":"),(0,i.kt)(o.B,{img:r,alt:"Instructions",idx:2,mdxType:"Figure"},"Relationship between an arbitrary recursive call of ",(0,i.kt)("code",null,"factCPS"),' and the "instructions" that it writes down.'),(0,i.kt)("p",null,'The middle of this image is supposed to denote the "instructions" that you might write if you were to codify the algorithm to determine the factorial of ',(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"))))),". Note that these instructions are actually read from bottom to top - thus, we start with 1 and then work out way up multiplying until we reach ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"))))),", which presumably should give us the actual factorial."),(0,i.kt)("p",null,"Now consider if we were at some arbitrary point of execution of the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS n initK"),", for some arbitrary ",(0,i.kt)("inlineCode",{parentName:"p"},"initK : int -> 'a"),". That is, suppose that ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS n initK")," has reduced down to ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS i k'"),", for some other ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," (which is the result of modifying the continuation throughout the recursive calls of ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS")," until now. Then, we should see that the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," should look something like ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn res => (fn res2 => ... (fn resn => initK (n * resn)) ... ((i + 2) * res)) ((i + 1) * res))"),". That is, it exactly captures the idea of the instructions in orange - it covers the multiplication of all of the terms from ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"i"),(0,i.kt)("mo",{parentName:"mrow"},"+"),(0,i.kt)("mn",{parentName:"mrow"},"1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"i+1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7429em",verticalAlign:"-0.0833em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"i"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"1")))))," to ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"))))),"."),(0,i.kt)("p",null,"What is the action of the recursive call ",(0,i.kt)("em",{parentName:"p"},"at")," ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS i k"),"? Well, clearly it should reduce to ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS (i-1) (fn res => k (i * res))")," - that is, it wraps ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," in the lambda expression ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn res => k (i * res))"),', which is just the "instruction" to multiply the result by ',(0,i.kt)("inlineCode",{parentName:"p"},"i"),", which exactly corresponds to the instruction in blue."),(0,i.kt)("p",null,"How do we compute the rest of the factorial function? Everything seems correct so far, but that is all that we will have in our accumulation of ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),". The rest of the instructions are exactly corresponding to the recursive call - to ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS i")," itself. ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS i"),', as the recursive call, will continue to go and compute the factorial all the way down to 0. Thus, even though we have not written them down yet, we can use the "recursive leap of faith" to ',(0,i.kt)("em",{parentName:"p"},"assume")," that ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS i k")," will behave properly, and write down the instructions for multiplying ",(0,i.kt)("inlineCode",{parentName:"p"},"i-1")," through ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," properly, which will result in the final, correct result."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE:")," An equivalent, but also very ",(0,i.kt)("em",{parentName:"p"},"important")," way to view CPS functions is that recursive calls ",(0,i.kt)("em",{parentName:"p"},"pass their result")," to their continuation. For instance, as we have defined, ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS n k")," should be extensionally equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"k (fact n)"),", or in other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS n k")," will be the same as passing the actual factorial of ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),". This means that when we are writing our function, we can make that assumption - ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS (n-1) (fn res => k (n * res))")," should pass the result of ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mo",{parentName:"mrow"},"\u2212"),(0,i.kt)("mn",{parentName:"mrow"},"1"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"!")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"(n-1)!")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"1"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")!")))))," to ",(0,i.kt)("inlineCode",{parentName:"p"},"(fn res => k (n * res))"),'. This is equivalent to, in our "instructions" analogy, saying that ',(0,i.kt)("inlineCode",{parentName:"p"},"factCPS i k")," should faithfully execute all the instructions of multiplying from ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," - that is, ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS i k")," should pass the result of ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"i"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"!")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"i!")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"i"),(0,i.kt)("span",{parentName:"span",className:"mclose"},"!")))))," to ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),"."),(0,i.kt)("p",null,"So now, we can sort of inductively see how ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS")," writes down the entire page of instructions, which should mean that it is correct when we execute it. This is not an inductive proof in itself, but this should give the intuition for ",(0,i.kt)("em",{parentName:"p"},"why")," it does work."),(0,i.kt)("p",null,"An additional way to think about CPS functions is that they behave similarly to a ",(0,i.kt)("em",{parentName:"p"},"stack"),'. This is because, as we have seen, we are continuously wrapping lambda expressions with other lambda expressions - we can only "pop" off a lambda expression by evaluating it with an argument, or "push" on more instructions by wrapping our continuation in more lambda expressions. We cannot access the ones inside. As such, we could visualize the evaluation of ',(0,i.kt)("inlineCode",{parentName:"p"},"factCPS 3 k")," as the following diagram:"),(0,i.kt)(o.B,{img:l,alt:"CPS Stack",idx:3,mdxType:"Figure"},'A visualization of the "stack" of instructions created by evaluating'," ",(0,i.kt)("code",null,"factCPS 3 k"),"."),(0,i.kt)("p",null,"We would build this stack up from the bottom by first putting our ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),' on (as our "original" ',(0,i.kt)("inlineCode",{parentName:"p"},"k"),"), then wrapping it in more lambda expressions as we go along the recursive calls (so, for instance, the orange brick is added by ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS 3 k'"),", and the red brick is added by ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS 2 k''"),", for their own respective continuations ",(0,i.kt)("inlineCode",{parentName:"p"},"k'")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"k''"),'). Then, once we are at the end, our "instruction stack" looks like the one currently pictured. At that point, we have nothing left to do but execute the stack of instructions with an initial value of ',(0,i.kt)("inlineCode",{parentName:"p"},"1"),", which will cause the bricks to start being popped off one by one, and then ultimately result in the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"6")," being applied to ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),"."),(0,i.kt)("p",null,"Another, equivalent way to view continuations is as ",(0,i.kt)("em",{parentName:"p"},"donuts"),"."),(0,i.kt)(o.B,{img:p,alt:"CPS Donut",idx:4,mdxType:"Figure"},'An artist\'s rendition of the "CPS Donut" of instructions created by evaluating'," ",(0,i.kt)("code",null,"factCPS 3 k")," (colorized, 2020)."),(0,i.kt)("p",null,"As you can see, we cannot access the inner layers of the CPS Donut without first biting through the outer layers (corresponding to our evaluation of the outer layers first). One can only imagine what it would taste like in real life."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE:")," It is not important to be able to draw these examples, or parrot them verbatim. They are merely here to try and provide some intuition as to what is happening with CPS. It is very important to be able to understand ",(0,i.kt)("em",{parentName:"p"},"why")," it is that CPS functions work, which may be rather daunting and hard-to-grasp at first."),(0,i.kt)("h2",{id:"continuation-passing-style-the-definition"},"Continuation Passing Style: The Definition"),(0,i.kt)("p",null,"We are now ready to attempt a definition of continuation passing style."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"[Continuation]")," A ",(0,i.kt)("em",{parentName:"p"},"continuation")," is a function that specifies what is supposed to be done with the result of a computation.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"[Continuation Passing Style]")," A function is said to be written in ",(0,i.kt)("em",{parentName:"p"},"continuation passing style")," if it satisfies the following conditions:"),(0,i.kt)("ol",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"It takes in and uses continuation(s).")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"It calls functions with continuations (including itself) as tail calls.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"It can only call its continuations in tail calls."))),(0,i.kt)("p",{parentName:"blockquote"},"The key characteristic of CPS functions is that they are generally written with the goal of ",(0,i.kt)("em",{parentName:"p"},"passing their results to their continuations"),". These continuations specify what computations should occur next.")),(0,i.kt)("p",null,"First, take a moment to assure yourself that the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS")," that we have so deeply studied ",(0,i.kt)("em",{parentName:"p"},"is"),", in fact, in continuation passing style.",(0,i.kt)("sup",{parentName:"p",id:"fnref-3"},(0,i.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"fun factCPS 0 k = k 1\n  | factCPS n k = factCPS (n-1) (fn res => k (n * res))\n")),(0,i.kt)("p",null,"As we have seen, clearly ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS"),"'s continuation, and it does call it in tail calls (as well as itself). This seems consistent with our definition."),(0,i.kt)("p",null,"An important corollary of this definition is that a CPS function ",(0,i.kt)("em",{parentName:"p"},"cannot case on a recursive call to itself"),". So, for instance, making a recursive call to a CPS function to see if it succeeds, then taking some action based on that premise is illegal. You may not fully understand what that means at the present, but we will explore this idea more in the future."),(0,i.kt)("p",null,"A somewhat interesting note is that every direct-style (which is how we will term the kinds of functions that we have written until now) function admits a continuation passing style implementation. This means that continuation passing style is nothing arcane, but it is merely a ",(0,i.kt)("em",{parentName:"p"},"different way of viewing computation"),". Functions written in continuation passing style can have significant performance benefits when compared to their direct style counterparts, so there are reasons to use continuation passing style other than just for the sake of it."),(0,i.kt)("h2",{id:"continuation-passing-style-a-case-study-v20"},"Continuation Passing Style: A Case Study v2.0"),(0,i.kt)("p",null,"We will now explore an example of a CPS function that makes use of some concept of limited ",(0,i.kt)("em",{parentName:"p"},"backtracking"),", or ",(0,i.kt)("em",{parentName:"p"},"checkpointing"),". Somewhat key to this example is that it writes down not just ",(0,i.kt)("em",{parentName:"p"},"one")," instruction at each recursive call, but ",(0,i.kt)("em",{parentName:"p"},"multiple"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"fun treeSumCPS Empty k = k 0\n  | treeSumCPS (Node (L, x, R)) k =\n  treeSumCPS L (fn leftSum => treeSumCPS R (fn rightSum => k (leftSum + x + rightSum))\n")),(0,i.kt)("p",null,"This function computes the sum of the elements in an int tree. The recursive case has a slightly more intimidating-looking continuation, however we can view it as simply a case of the continuation being wrapped ",(0,i.kt)("em",{parentName:"p"},"twice"),"."),(0,i.kt)("p",null,"Consider how we would normally want to approach this problem. In a typical ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSum"),", we might compute both the left and right sums, and then simply add the results to ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),". This suffices, and follows rather intuitively, but in CPS we must make our control flow ",(0,i.kt)("em",{parentName:"p"},"explicit"),". In this manner, we must be very specific about ",(0,i.kt)("em",{parentName:"p"},"what")," we should do and in which ",(0,i.kt)("em",{parentName:"p"},"order"),". To that end, we fix a direction to visit first (in this case, left, though it does not matter), and then compute the sum of that direction, with the promise that we will eventually use the result of the left side to compute the final result."),(0,i.kt)("p",null,"To visualize what is happening, consider the following tree."),(0,i.kt)(o.B,{img:m,alt:"CPS Donut",idx:5,mdxType:"Figure"},"A tree of ints to be summed, whose node contents are conveniently enumerated according to visit order."),(0,i.kt)("p",null,"We will run through a mock simulation of the evaluation of ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSumCPS T k"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is the tree pictured, and ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),' is some arbitrary continuation. First, note that we will take the convention that "Tn" for some number n will denote the subtree rooted at the vertex n, and "Sn" will denote the sum of that subtree.'),(0,i.kt)("p",null,"Firstly, we know that from ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSumCPS T k")," we should obtain ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSumCPS T2 (fn S2 => treeSumCPS T4 (fn S4 => k (S2 + 1 + S4))"),"."),(0,i.kt)(o.B,{img:c,alt:"Phase 1",idx:6,mdxType:"Figure"},"Phase 1 of evaluation of the tree T."),(0,i.kt)("p",null,"We can think of the individual calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSumCPS")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"T2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"T4"),' as leaving "flags" on each arm of the edges coming from vertex 1 - denoting which node that we should visit next. Clearly, we visit ',(0,i.kt)("inlineCode",{parentName:"p"},"T2")," first, so the red brick corresponding to ",(0,i.kt)("inlineCode",{parentName:"p"},"T2")," is on top."),(0,i.kt)("p",null,"Our next move is to pop it off first, which will cause our expression to now have three bricks - two corresponding to the children of ",(0,i.kt)("inlineCode",{parentName:"p"},"T2"),", and one corresponding to ",(0,i.kt)("inlineCode",{parentName:"p"},"T4"),". We can visualize the next phase as the following:"),(0,i.kt)(o.B,{img:h,alt:"Phase 2",idx:7,mdxType:"Figure"},'Phase 2 of evaluation of the tree T. Note that two extra "bricks" have been added due to evaluation of treeSumCPS T2.'),(0,i.kt)("p",null,"where the brick labelled ",(0,i.kt)("inlineCode",{parentName:"p"},"treeSumCPS E")," corresponds to the empty child of ",(0,i.kt)("inlineCode",{parentName:"p"},"T2"),". Note that we have retained the blue flag at ",(0,i.kt)("inlineCode",{parentName:"p"},"T4"),' and left its brick alone, since for all intents and purposes we have not yet "touched" it - we have not evaluated our stack to that point. Note that due to corresponding to the ',(0,i.kt)("inlineCode",{parentName:"p"},"Empty")," case, the purple brick will not add any new bricks, but merely defer to the next brick on the stack - the orange brick. Thus, the next step looks like the following:"),(0,i.kt)(o.B,{img:u,alt:"Phase 3",idx:8,mdxType:"Figure"},"Phase 3 of evaluation of the tree T. Note that this follows from evaluating both of the top bricks from the previous step."),(0,i.kt)("p",null,"In this step, the green and light blue bricks again correspond to empty trees, so they simply dissolve without generating more instructions. As such, we reduce to the following diagram:"),(0,i.kt)(o.B,{img:d,alt:"Phase 4",idx:9,mdxType:"Figure"},'Phase 4 of evaluation of the tree T. Note that, after finishing our evaluation of all of the bricks of the left side, we return to our long-neglected "checkpoint" on the right side of the tree.'),(0,i.kt)("p",null,"We see in this step that, as the figure caption says, we have returned to the right hand side after finishing all evaluation on the left hand side of the tree. Thus, our construction was correct - we placed the blue brick onto the stack at the very beginning, then proceeded to forget about it until now. This works in our favor, however, as we only return to it once we have finished with everything on the left. One more step of evaluation yields:"),(0,i.kt)(o.B,{img:k,alt:"Phase 5",idx:10,mdxType:"Figure"},"Phase 5 of evaluation of the tree T."),(0,i.kt)("p",null,"Thus, all we have left are empty bricks, so we are very close to termination."),(0,i.kt)("p",null,"This demonstration was far from a rigorous treatment, and also omitted any mention of the actual value being passed into each continuation - this can be inductively assumed to be the proper sum at any given brick. We invite the reader to conduct any detailed analysis on their own, similarly to the treatment of ",(0,i.kt)("inlineCode",{parentName:"p"},"factCPS"),", in order to truly grasp how the different subtree sums are computed and passed around."),(0,i.kt)("p",null,'The main point in this example, however, was to demonstrate how even a slightly more complicated function can result in elegant, powerful control-flow behavior. By simply wrapping our continuation twice, we ensured that we could set up a "checkpointing" system, where we could set "flags" to jump back to once finishing a certain computation. This is an important idea to cognize with continuation passing style.'),(0,i.kt)("p",null,"In the next example, we will explore how we can set up more complicated arrangements of control flow through usage of two continuations."),(0,i.kt)("h2",{id:"continuation-passing-style-a-case-study-in-success-and-failure"},"Continuation Passing Style: A Case Study in Success and Failure"),(0,i.kt)("p",null,"Duality seems to permeate computational problems. When trying to write programs, we often come to cases where we need to make a choice between two extremes - on or off, keep or don't, left or right, 1 or 0. With the capacity to make choices, however, comes the possibility of making the ",(0,i.kt)("em",{parentName:"p"},"wrong")," choice. In such a case, we might want the ability to remember the choice we made, and take the other one, or ",(0,i.kt)("em",{parentName:"p"},"backtrack"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"[Backtracking]"),' Backtracking is a strategy employed by algorithms when trying to find all the possible "options" or "possibilities", so as to locate the "best" solution, or alternatively just one feasible solution. Problems that admit backtracking solutions include the N-queens puzzle, constraint satisfaction problems, and Sudoku.')),(0,i.kt)("p",null,'At first, backtracking might seem like it is akin to what was done in the previous example, with our idea of "checkpointing", except that we never really "reset" our state. When we set checkpoints to go back to in the ',(0,i.kt)("inlineCode",{parentName:"p"},"treeSumCPS")," example, we always did so while retaining the sum of the left side, so we never lost information. In a backtracking problem, we may need to throw away everything that we've done in the meantime and go to a different solution entirely."),(0,i.kt)("p",null,"In this example, we will analyze a classic optimization problem, and how it admits a CPS solution."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"[Knapsack Problem - Decision Version]")," The ",(0,i.kt)("em",{parentName:"p"},"knapsack problem")," is a resource allocation problem which traditionally concerns a person with a knapsack that can only contain a certain total weight of items. The person has to choose between a collection of items (all of differing weight and value) so as to maximize the amount of value collected, while being below the maximum weight limit of the knapsack. Note that items can be taken more than once."),(0,i.kt)("p",{parentName:"blockquote"},"In this chapter, we will be concerned specifically with the ",(0,i.kt)("em",{parentName:"p"},"decision problem")," version of the knapsack problem, which, instead of asking for a maximizing assignment, instead asks if there ",(0,i.kt)("em",{parentName:"p"},"exists")," an assignment that can achieve a certain threshold of value.")),(0,i.kt)("p",null,"We will now write a continuation passing style function that solves the knapsack problem."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"type weight = int\ntype value = int\n\n(* knapsackCPS :\n *            (value * weight) list ->\n *            value ->\n *            weight ->\n *            ((value * weight) list -> 'a) ->\n *            (unit -> 'a) ->\n *            'a\n * REQUIRES: The weights and values of the elements in L are strictly positive.\n * ENSURES: knapsackCPS L minVal maxWeight sc fc ~= sc L' for some L' that only\n * contains elements of L, such that the total value of L' >= minVal and the\n * total weight of L' <= maxWeight, if such an L' exists. If no such L' exists,\n * then it should be equivalent to fc ().\n *)\n\nfun knapsackCPS\n  (L : (value * weight) list)\n  (minVal : value)\n  (maxWeight : weight)\n  (sc : (value * weight) list -> 'a)\n  (fc : unit -> 'a)\n  : 'a =\n  case L of\n    [] => if minVal <= 0 andalso maxWeight >= 0 then sc []\n                                                else fc ()\n  | (v, w)::xs => if maxWeight < 0 then fc ()\n                                   else\n    knapsackCPS ((v, w)::xs) (minVal - v) (maxWeight - w)\n    (fn L' => sc ((v, w)::L')) (fn () => knapsackCPS xs minVal maxWeight sc fc)\n")),(0,i.kt)("p",null,"We see that ",(0,i.kt)("inlineCode",{parentName:"p"},"knapsackCPS")," takes in a list of items, each represented as a ",(0,i.kt)("inlineCode",{parentName:"p"},"value * weight")," tuple, where ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"weight")," are both really just aliases for ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". It also takes in a minimum threshold for the knapsack's value, ",(0,i.kt)("inlineCode",{parentName:"p"},"minVal"),", and a maximum weight of items to be taken ",(0,i.kt)("inlineCode",{parentName:"p"},"maxWeight"),". Of particular interest, however, are the parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"sc")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fc")," - denoting what we call the ",(0,i.kt)("em",{parentName:"p"},"success")," and ",(0,i.kt)("em",{parentName:"p"},"failure")," continuations. The goal of our function is to ultimately find a list ",(0,i.kt)("inlineCode",{parentName:"p"},"L'")," that contains elements that are also in ",(0,i.kt)("inlineCode",{parentName:"p"},"L")," (with duplicates allowed). This corresponds to choosing how many of each item in the allowed collection to pick."),(0,i.kt)("p",null,"If such a list exists, then we should return ",(0,i.kt)("inlineCode",{parentName:"p"},"sc L'"),". Otherwise, if there is no such list, we should return ",(0,i.kt)("inlineCode",{parentName:"p"},"fc ()"),"."),(0,i.kt)("p",null,"Rather immediately, this should seem as a kind of different problem. There isn't really a better algorithm than brute forcing possibilities, but if we try a possibility and it turns out to be wrong, we want to have the option to be able to ",(0,i.kt)("em",{parentName:"p"},"backtrack")," and try something else entirely. We will demonstrate how this is realized in the algorithm in the next part."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"case L of\n    [] => if minVal <= 0 andalso maxWeight >= 0 then sc []\n                                                else fc ()\n")),(0,i.kt)("p",null,"For the base case, however, we know that if we are given no items whatsoever, then we cannot place anything in our knapsack. Thus, we have no choice but to have a value and weight of 0. As such, if we know that our minimum value is at most 0 and our maximum weight is at least 0, then a valid list value for ",(0,i.kt)("inlineCode",{parentName:"p"},"L'")," is just the empty list, so we can call our success continuation in ",(0,i.kt)("inlineCode",{parentName:"p"},"sc []"),". Otherwise, we must call the failure continuation, as the problem is not solvable."),(0,i.kt)("p",null,"Note that, since we plan to write this function recursively, if we were given an initial list that was non-empty, we may eventually recurse down to the empty case. It may then seem like a concern that we are calling ",(0,i.kt)("inlineCode",{parentName:"p"},"sc []"),", as we might actually call ",(0,i.kt)("inlineCode",{parentName:"p"},"sc"),' on a list that contains elements. Note that this is not a concern - by the structure of CPS functions, if we were to recurse down to the base case, our "promise" is that the success continuation ',(0,i.kt)("inlineCode",{parentName:"p"},"sc"),' that we enter the base case with is not the "original" ',(0,i.kt)("inlineCode",{parentName:"p"},"sc"),' that we were passed - by this point, it should have accumulated a great deal of "information" and thus become more advanced than simply returning ',(0,i.kt)("inlineCode",{parentName:"p"},"sc []"),", for the original ",(0,i.kt)("inlineCode",{parentName:"p"},"sc"),". For the base case, it is sufficient to simply solve it from the perspective of having been originally given ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),"."),(0,i.kt)("p",null,"In the recursive case, we now have to think about how we might solve the knapsack problem given that we have a non-empty collection of items to take. Right off the bat, we can say that if our ",(0,i.kt)("inlineCode",{parentName:"p"},"maxWeight < 0"),", then this problem is unsolvable, since we cannot possibly have a negative total weight (our weights in this problem are strictly positive), so in that case we would simply call our failure continuation."),(0,i.kt)("p",null,"Otherwise, however, we now need to actually think about what to do. Oftentimes, it is very helpful reduce the problem to making a ",(0,i.kt)("em",{parentName:"p"},"binary choice"),", and then simply explore the consequences of doing so from there. In this case, we can imagine our choice to be whether to put the first element of the list into the knapsack, or to not."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml"},"| (v, w)::xs => if maxWeight < 0 then fc ()\n                                   else\n    knapsackCPS ((v, w)::xs) (minVal - v) (maxWeight - w)\n    (fn L' => sc ((v, w)::L')) (fn () => knapsackCPS xs minVal maxWeight sc fc)\n")),(0,i.kt)("p",null,"What does our recursive call for putting the first element ",(0,i.kt)("inlineCode",{parentName:"p"},"(v, w)")," into the knapsack look like? It takes the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"knapsackCPS ((v, w)::xs) (minVal - v) (maxWeight - w) sc' fc'"),", for some ",(0,i.kt)("inlineCode",{parentName:"p"},"sc'")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fc'")," that we will determine later. We keep the list the same, to account for the fact that we can have duplicates - in the next step, we want to reconsider whether we want to put ",(0,i.kt)("inlineCode",{parentName:"p"},"(v, w)")," on again. If we commit to putting ",(0,i.kt)("inlineCode",{parentName:"p"},"(v, w)")," in the knapsack, however, we need to somehow encode the fact that our value has gone up by ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),", and our knapsack's weight has gone up by ",(0,i.kt)("inlineCode",{parentName:"p"},"w"),". This is achieved by setting the new minimum value to be ",(0,i.kt)("inlineCode",{parentName:"p"},"minVal - v"),", and the new max weight to be ",(0,i.kt)("inlineCode",{parentName:"p"},"maxWeight - w")," - we simply lower our thresholds, which is functionally the same."),(0,i.kt)("p",null,'What should our continuations be? Remember that by the recursive leap of faith, we can assume a kind of "promise" of this recursive call - that is, we can assume that ',(0,i.kt)("inlineCode",{parentName:"p"},"knapsackCPS ((v, w)::xs) (minVal - v) (maxWeight - w) sc' fc'")," obeys the same ENSURES clause as was written above, for its own ",(0,i.kt)("inlineCode",{parentName:"p"},"sc'")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fc'"),". We now should define what to do in the case that either is called."),(0,i.kt)("p",null,"We are, at this point, not actually at the stage where we know if ",(0,i.kt)("inlineCode",{parentName:"p"},"sc'")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"fc'")," is going to be called, or on what, if at all. The power in CPS comes from the fact that this ",(0,i.kt)("em",{parentName:"p"},"does not matter"),", and we can write our algorithm despite that. Earlier, we discussed the concept of continuations as ",(0,i.kt)("em",{parentName:"p"},"contingency plans"),". In this function, we are going to be using that strategy to full effect."),(0,i.kt)("p",null,"Think of ",(0,i.kt)("inlineCode",{parentName:"p"},"sc'")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fc'")," as contingency plans for the success and failure case, respectively. ",(0,i.kt)("em",{parentName:"p"},"If")," we were to succeed on this recursive call, what should we do? If we were to fail, what should we do? Even though we have no idea what the input to the continuation is, the fact that it is a function allows us (inside the scope of the body of ",(0,i.kt)("inlineCode",{parentName:"p"},"sc'"),") to ",(0,i.kt)("em",{parentName:"p"},"assume we have access to it"),"."),(0,i.kt)("p",null,"As such, the first thing we may write for ",(0,i.kt)("inlineCode",{parentName:"p"},"sc'")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"fn L' => ..."),". Now, we must fill in the ellipses. If ",(0,i.kt)("inlineCode",{parentName:"p"},"sc'")," is called, we know that it must be called with an appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"L'")," that satisfies the ENSURES conditions. Recall that this recursive call emerged in the first place from our ",(0,i.kt)("em",{parentName:"p"},"choice")," - to place ",(0,i.kt)("inlineCode",{parentName:"p"},"(v, w)")," inside of the knapsack. Thus, if the call to ",(0,i.kt)("inlineCode",{parentName:"p"},"knapsackCPS")," succeeds, we know that placing ",(0,i.kt)("inlineCode",{parentName:"p"},"(v, w)")," inside the knapsack must be feasible, by extension. So then we know it makes sense to write ",(0,i.kt)("inlineCode",{parentName:"p"},"fn L' => sc ((v, w)::L')")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"sc'"),', which intuitively means "take the answer (knapsack) to the recursive call and then put ',(0,i.kt)("inlineCode",{parentName:"p"},"(v, w)"),' in it, then call success on it". Thus, we have written down a ',(0,i.kt)("em",{parentName:"p"},"contingency plan")," for what we should do ",(0,i.kt)("em",{parentName:"p"},"if"),", at some point in the future, our success continuation is called."),(0,i.kt)("p",null,"What about ",(0,i.kt)("inlineCode",{parentName:"p"},"fc'"),"? What should we do if we fail? Well, if our recursive call to ",(0,i.kt)("inlineCode",{parentName:"p"},"knapsackCPS")," does not succeed, that must mean that our choice to place ",(0,i.kt)("inlineCode",{parentName:"p"},"(v, w)")," inside of the knapsack was wrong. In that case, we want to make the other choice - to not put ",(0,i.kt)("inlineCode",{parentName:"p"},"(v, w)")," inside the knapsack. Thus, we write ",(0,i.kt)("inlineCode",{parentName:"p"},"fn () => knapsackCPS xs minVal maxWeight sc fc"),", which has the exact same parameters as what we were initially passed, except we have gotten rid of ",(0,i.kt)("inlineCode",{parentName:"p"},"(v, w)")," (since we know to put it in the knapsack is a mistake). Our ",(0,i.kt)("inlineCode",{parentName:"p"},"sc")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fc")," remain the same, since on a sucess or fail to this call, we just do whatever we would normally do on a success or fail."),(0,i.kt)("p",null,"This, in only a few lines (and generous whitespace), we have written an algorithm for a backtracking knapsack problem solver. While it looks intimidating at first, the overall algorithm reduces down to only a few simple steps, which is written in an elegant and explicit manner due to continuation passing style."),(0,i.kt)("h2",{id:"conclusions"},"Conclusions"),(0,i.kt)("p",null,"In this section, we explored the idea of continuation passing style, which lets us phrase the control flow of our functions in a more explicit manner, granting us more versatility in our implementation. We saw how CPS functions can be viewed as simply a more advanced form of accumulation, as well as how having multiple continuations (corresponding to success and failure cases) allows us to explore expansive trees of binary choices to find solutions. --\x3e"),(0,i.kt)("div",{className:"footnotes"},(0,i.kt)("hr",{parentName:"div"}),(0,i.kt)("ol",{parentName:"div"},(0,i.kt)("li",{parentName:"ol",id:"fn-1"},"In fact, it is ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence"},(0,i.kt)("em",{parentName:"a"},"alpha equivalent!")),(0,i.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,i.kt)("li",{parentName:"ol",id:"fn-2"},"Though perhaps we should not be, until we write a full inductive proof of correctness!",(0,i.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")),(0,i.kt)("li",{parentName:"ol",id:"fn-3"},"Otherwise, you should be quite concerned about the competency of the author, and you would probably be better off reading a different help site.",(0,i.kt)("a",{parentName:"li",href:"#fnref-3",className:"footnote-backref"},"\u21a9")))))}b.isMDXComponent=!0}}]);