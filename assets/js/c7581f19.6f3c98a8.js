"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[9965],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=s(n),m=r,f=c["".concat(p,".").concat(m)]||c[m]||d[m]||a;return n?i.createElement(f,o(o({ref:t},u),{},{components:n})):i.createElement(f,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<a;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5339:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var i=n(7462),r=(n(7294),n(3905));const a={sidebar_position:2},o="Int",l={unversionedId:"types/int",id:"types/int",title:"Int",description:"By Brandon Wu, May 2020",source:"@site/docs/types/int.md",sourceDirName:"types",slug:"/types/int",permalink:"/book/docs/types/int",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"defaultSidebar",previous:{title:"Bool",permalink:"/book/docs/types/bool"},next:{title:"Real",permalink:"/book/docs/types/real"}},p={},s=[{value:"Values",id:"values",level:2},{value:"Production",id:"production",level:2},{value:"Combination",id:"combination",level:2},{value:"From the Structure",id:"from-the-structure",level:2}],u={toc:s};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"int"},"Int"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"By Brandon Wu, May 2020")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"int")," is the SML type of integers."),(0,r.kt)("h2",{id:"values"},"Values"),(0,r.kt)("p",null,"The underlying representation of integers can be likened to the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"datatype int = ... | ~2 | ~1 | 0 | 1 | 2 | ...\n")),(0,r.kt)("p",null,"This signifies that the type ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," is inhabited by infinitely many values, all corresponding to whole numbers. In particular, every integer forms its own ",(0,r.kt)("em",{parentName:"p"},"constant constructor")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," type, meaning that they each individually can be pattern matched upon. Note that the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"~")," above denotes negativity. Additionally, ",(0,r.kt)("inlineCode",{parentName:"p"},"~")," is a valid function of type ",(0,r.kt)("inlineCode",{parentName:"p"},"int -> int")," that negates a number."),(0,r.kt)("p",null,"While in practice, computers can only represent a finite number of integers, for the purposes of this class we will generally assume the integers to be unbounded. This means that we can do induction on SML integers in exactly the same way as we would do induction on the natural numbers, and that we do not have to worry about the consequences of edge case behavior. This allows us to ignore pedantic implementation details and explore mathematically interesting properties of programs."),(0,r.kt)("h2",{id:"production"},"Production"),(0,r.kt)("p",null,"Integers have all the familiar arithmetic operations available to them. Note that some of these functions are also overloaded to work with ",(0,r.kt)("inlineCode",{parentName:"p"},"real")," types - this is further discussed in the Real page."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"(op +)   : int * int -> int\n(op -)   : int * int -> int\n(op *)   : int * int -> int\n(op div) : int * int -> int\n(op mod) : int * int -> int\n")),(0,r.kt)("p",null,"All of these functions are ",(0,r.kt)("em",{parentName:"p"},"infixed"),", so instead of being applied as ",(0,r.kt)("inlineCode",{parentName:"p"},"+(2, 3)"),", we write ",(0,r.kt)("inlineCode",{parentName:"p"},"2 + 3"),". Additionally, ",(0,r.kt)("inlineCode",{parentName:"p"},"div")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mod")," are not defined when the second argument is 0, and will raise a ",(0,r.kt)("inlineCode",{parentName:"p"},"Div")," exception."),(0,r.kt)("h2",{id:"combination"},"Combination"),(0,r.kt)("p",null,"Integers are also eligible for comparison, including equality and inequality. (In other words, integers are an ",(0,r.kt)("em",{parentName:"p"},"equality type"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"(op =)  : int * int -> bool\n(op <>) : int * int -> bool (* Inequality *)\n\n(op <)  : int * int -> bool\n(op >)  : int * int -> bool\n(op <=) : int * int -> bool\n(op >=) : int * int -> bool\n")),(0,r.kt)("h2",{id:"from-the-structure"},"From the Structure"),(0,r.kt)("p",null,"The structure ",(0,r.kt)("inlineCode",{parentName:"p"},"Int")," is bound as part of the SML Basis. It includes helpful functions such as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"Int.toString : int -> string\nInt.compare  : int * int -> order\nInt.min      : int * int -> int\nInt.max      : int * int -> int\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"Int.toString")," is the function that returns the string representation of a given integer, and ",(0,r.kt)("inlineCode",{parentName:"p"},"Int.compare")," has return type ",(0,r.kt)("inlineCode",{parentName:"p"},"order"),", which is inhabited only by values ",(0,r.kt)("inlineCode",{parentName:"p"},"LESS"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"EQUAL"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"GREATER"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Int.compare (x, y)")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"LESS")," only if x < y, ",(0,r.kt)("inlineCode",{parentName:"p"},"EQUAL")," if x = y, and ",(0,r.kt)("inlineCode",{parentName:"p"},"GREATER")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"x > y"),". Additionally, ",(0,r.kt)("inlineCode",{parentName:"p"},"Int.min")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Int.max")," are just the corresponding min and max functions for integers."))}d.isMDXComponent=!0}}]);