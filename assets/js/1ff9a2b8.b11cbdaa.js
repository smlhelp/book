"use strict";(self.webpackChunksmlhelp=self.webpackChunksmlhelp||[]).push([[495],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,h=m["".concat(s,".").concat(d)]||m[d]||p[d]||l;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2294:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const l={},i="Tail Recursion",o={unversionedId:"concepts/recursion/tail",id:"concepts/recursion/tail",title:"Tail Recursion",description:"By Eunice Chen and Brandon Wu, December 2020. Revised March 2022",source:"@site/docs/concepts/recursion/tail.md",sourceDirName:"concepts/recursion",slug:"/concepts/recursion/tail",permalink:"/book/docs/concepts/recursion/tail",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Recursion and Induction",permalink:"/book/docs/concepts/recursion/"},next:{title:"Trees",permalink:"/book/docs/concepts/recursion/tree"}},s={},c=[{value:"Example",id:"example",level:2},{value:"Answers",id:"answers",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tail-recursion"},"Tail Recursion"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"By Eunice Chen and Brandon Wu, December 2020. Revised March 2022")),(0,r.kt)("p",null,"In programs, functions often make calls to either themselves (recursive calls) or other functions. There are two types of function calls: non-tail calls, and ",(0,r.kt)("strong",{parentName:"p"},"tail calls"),". A function call is called a ",(0,r.kt)("strong",{parentName:"p"},"tail call")," if the caller does not modify or examine the result of the function call."),(0,r.kt)("p",null,"If every recursive call made by a function is a ",(0,r.kt)("strong",{parentName:"p"},"tail call"),", that function is called ",(0,r.kt)("strong",{parentName:"p"},"tail recursive"),". Put another way, a function is ",(0,r.kt)("strong",{parentName:"p"},"tail recursive")," if the last operation performed by the function is the recursive call."),(0,r.kt)("p",null,"Suppose we have the following function to sum the elements of a list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun sum [] = 0\n  | sum (x::xs) = x + (sum xs)\n")),(0,r.kt)("p",null,"This function is not tail-recursive, because after the recursive call is evaluated, we add the result to ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),". Similarly, if we were to case on ",(0,r.kt)("inlineCode",{parentName:"p"},"sum xs")," or did any other operation on its result, then this function would not be tail-recursive."),(0,r.kt)("p",null,"In order to write the ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," function in a tail-recursive manner, we know that the last computation that we can do is the recursive call to ",(0,r.kt)("inlineCode",{parentName:"p"},"sum"),". But, we also need some way to keep track of the sum of the list elements and add to it, since we no longer can add things after the recursive call. We will make an accumulator variable, ",(0,r.kt)("inlineCode",{parentName:"p"},"acc"),", that will keep track of the sum of list elements we have exposed so far, and pass that down through the recursive calls. In our base case, we know we have seen every element in the list and there are no more elements to add, so our base case looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun tsum ([], acc) = acc\n")),(0,r.kt)("p",null,"In our recursive case, we want to use our accumulator to account for the top element of our list, then pass down that accumulator to the recursive calls. We can do that as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun tsum (x::xs, acc) = tsum (xs, x + acc)\n")),(0,r.kt)("p",null,"Because SML evaluates the function arguments before evaluating the function call, ",(0,r.kt)("inlineCode",{parentName:"p"},"x + acc")," is performed before ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," is called, and then this updated accumulator value is passed down to the recursive ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," call on ",(0,r.kt)("inlineCode",{parentName:"p"},"xs"),". Thus, the last operation performed is the recursive call, making this a tail-recursive function."),(0,r.kt)("p",null,"Because we now have the accumulator variable, we must pass in ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," as the accumulator for ",(0,r.kt)("inlineCode",{parentName:"p"},"tsum")," to behave as expected. In addition, because we have changed the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"sum"),", we can rewrite the original ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," function by using the tail-recursive version as a helper."),(0,r.kt)("p",null,"Putting these parts together, we have:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun tsum ([], acc) = acc\n  | tsum (x::xs, acc) = tsum (xs, x + acc)\n\nfun sum L = tsum (L, 0)\n")),(0,r.kt)("p",null,"Why do we care about tail recursion? One reason is that the tail-recursive version of functions uses less space on the call stack. (The call stack is what keeps track of function calls- in this case, the call stack keeps track of the recursive calls and the work left to do after the recursive calls.)"),(0,r.kt)("p",null,"Consider the following stack trace of the ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," function, which is not tail-recursive:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"sum [3, 2, 1]\n=> 3 + (sum [2, 1])\n=> 3 + (2 + (sum [1]))\n=> 3 + (2 + (1 + (sum [])))\n=> 3 + (2 + (1 + (0)))\n=> 3 + (2 + (1))\n=> 3 + (3)\n=> 6\n")),(0,r.kt)("p",null,"In this stack trace, we can see that the sum function takes linear space. (By stack space, we mean the space around the recursive call). Assuming an input list of length ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),", the stack will have ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," additions at its largest, giving us a stack of size ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,r.kt)("p",null,"Now, consider a stack trace of the tail-recursive ",(0,r.kt)("inlineCode",{parentName:"p"},"sum'")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"sum ([3, 2, 1], 0)\n=> sum ([2, 1], 3)\n=> sum ([1], 5)\n=> sum ([], 6)\n=> 6\n")),(0,r.kt)("p",null,'Notice that the stack trace does not get any wider: we do not need any memory space to store "what is left to do," so this takes constant space.'),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"Let's try to turn the function to calculate the nth Fibonacci number into a tail-recursive function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun fib 0 = 1\n  | fib 1 = 1\n  | fib n = fib (n-1) + fib (n-2)\n")),(0,r.kt)("p",null,"Note that there are two recursive calls that we add together. In order to be tail-recursive, we can only make one recursive call (if there are two recursive calls, then one must be evaluated before the other, making the first recursive call not a tail call)."),(0,r.kt)("p",null,"What if, instead of computing the nth Fibonacci number, we calculate the ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"th and the (",(0,r.kt)("inlineCode",{parentName:"p"},"n-1"),")th Fibonacci number together? (When ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", we can just define the (",(0,r.kt)("inlineCode",{parentName:"p"},"n-1"),")th Fibonacci number to be ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun fib 0 = (1, 0)\n  | fib 1 = (1, 1)\n  | fib n =\n    let\n      val (a, b) = fib (n-1)\n    in\n      (a + b, a)\n    end\n")),(0,r.kt)("p",null,"This is closer, but we still are doing computation after the recursive call: we add the results of the recursive call to each other, then return. Let's try to use the accumulator idea we had earlier in the ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," function, but this time, since we calculate the ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"th and (",(0,r.kt)("inlineCode",{parentName:"p"},"n-1"),")th Fibonacci number, we will pass in two accumulators. Accumulator ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," will hold the ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"th Fibonacci number, and accumulator ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," will hold the (",(0,r.kt)("inlineCode",{parentName:"p"},"n-1"),")th Fibonacci number."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun fib' (0, a, b) = a\n  | fib' (n, a, b) = fib' (n-1, a + b, a)\n")),(0,r.kt)("p",null,"And if we call ",(0,r.kt)("inlineCode",{parentName:"p"},"fib' (n, 1, 0)"),", observe that we will indeed get the correct result."),(0,r.kt)("h1",{id:"further-practice"},"Further Practice"),(0,r.kt)("p",null,"For even further practice, try to write a tail-recursive function of the list-reversing function on your own."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun rev [] = []\n  | rev (x::xs) = (rev xs) @ [x]\n")),(0,r.kt)("h2",{id:"answers"},"Answers"),(0,r.kt)("p",null,"If we want to do this tail-recursively, we add an accumulator variable and proceed as usual. If we want to use the same types as the original ",(0,r.kt)("inlineCode",{parentName:"p"},"rev")," function, we can call our tail-recursive version, as we did in our ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sml"},"fun trev ([], acc) = acc\n  | trev (x::xs, acc) = trev (xs, x::acc)\n\nval rev = fn L => trev (L, [])\n")))}p.isMDXComponent=!0}}]);