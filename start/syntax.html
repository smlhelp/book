<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Syntax Cheatsheet - SML Help</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A resource for learning SML">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Welcome!</a></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/install.html"><strong aria-hidden="true">1.1.</strong> Install & run SML</a></li><li class="chapter-item expanded "><a href="../start/syntax.html" class="active"><strong aria-hidden="true">1.2.</strong> Syntax Cheatsheet</a></li><li class="chapter-item expanded "><a href="../start/common.html"><strong aria-hidden="true">1.3.</strong> Common Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="../types/index.html"><strong aria-hidden="true">2.</strong> Types & Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/type.html"><strong aria-hidden="true">2.1.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/bool.html"><strong aria-hidden="true">2.1.1.</strong> bool</a></li><li class="chapter-item expanded "><a href="../types/int.html"><strong aria-hidden="true">2.1.2.</strong> int</a></li><li class="chapter-item expanded "><a href="../types/real.html"><strong aria-hidden="true">2.1.3.</strong> real</a></li><li class="chapter-item expanded "><a href="../types/string.html"><strong aria-hidden="true">2.1.4.</strong> string</a></li><li class="chapter-item expanded "><a href="../types/function.html"><strong aria-hidden="true">2.1.5.</strong> function types</a></li><li class="chapter-item expanded "><a href="../types/list.html"><strong aria-hidden="true">2.1.6.</strong> list</a></li><li class="chapter-item expanded "><a href="../types/options.html"><strong aria-hidden="true">2.1.7.</strong> options</a></li></ol></li><li class="chapter-item expanded "><a href="../types/sig.html"><strong aria-hidden="true">2.2.</strong> Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/basis.html"><strong aria-hidden="true">2.2.1.</strong> Basis Library Documentation</a></li><li class="chapter-item expanded "><a href="../types/aux-lib.html"><strong aria-hidden="true">2.2.2.</strong> Auxiliary Library Documentation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../debugging/index.html"><strong aria-hidden="true">3.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../debugging/errors.html"><strong aria-hidden="true">3.1.</strong> Common Errors</a></li><li class="chapter-item expanded "><a href="../debugging/hints.html"><strong aria-hidden="true">3.2.</strong> Debugging Hints</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/index.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/basic.html"><strong aria-hidden="true">4.1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/eval.html"><strong aria-hidden="true">4.1.1.</strong> Evaluation</a></li><li class="chapter-item expanded "><a href="../concepts/eeq.html"><strong aria-hidden="true">4.1.2.</strong> Extensional Equivalence</a></li><li class="chapter-item expanded "><a href="../concepts/patternmatch.html"><strong aria-hidden="true">4.1.3.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/recind.html"><strong aria-hidden="true">4.2.</strong> Recursion and Induction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/induct.html"><strong aria-hidden="true">4.2.1.</strong> Inductive Proofs</a></li><li class="chapter-item expanded "><a href="../concepts/rec.html"><strong aria-hidden="true">4.2.2.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../concepts/tail.html"><strong aria-hidden="true">4.2.3.</strong> Tail Recursion</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/analysis.html"><strong aria-hidden="true">4.3.</strong> Asymptotic Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/workspan.html"><strong aria-hidden="true">4.3.1.</strong> Work and Span</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/datatypes.html"><strong aria-hidden="true">4.4.</strong> Datatypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/poly.html"><strong aria-hidden="true">4.4.1.</strong> Parametric Polymorphism</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/hofs.html"><strong aria-hidden="true">4.5.</strong> Higher Order Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/curry.html"><strong aria-hidden="true">4.5.1.</strong> Currying and Staging</a></li><li class="chapter-item expanded "><a href="../concepts/common.html"><strong aria-hidden="true">4.5.2.</strong> Common HOFs and Partial Evaluation</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/control.html"><strong aria-hidden="true">4.6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/cps.html"><strong aria-hidden="true">4.6.1.</strong> Continuation Passing Style</a></li><li class="chapter-item expanded "><a href="../concepts/exn.html"><strong aria-hidden="true">4.6.2.</strong> Exceptions</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/mods.html"><strong aria-hidden="true">4.7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/mods.html"><strong aria-hidden="true">4.7.1.</strong> Basics and Ascription</a></li><li class="chapter-item expanded "><a href="../concepts/functors.html"><strong aria-hidden="true">4.7.2.</strong> Functors</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/apps.html"><strong aria-hidden="true">4.8.</strong> Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/sequences.html"><strong aria-hidden="true">4.8.1.</strong> Sequences</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/lazy.html"><strong aria-hidden="true">4.9.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../concepts/imperative.html"><strong aria-hidden="true">4.10.</strong> Imperative</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/index.html"><strong aria-hidden="true">5.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/basics.html"><strong aria-hidden="true">5.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="../examples/recursion.html"><strong aria-hidden="true">5.2.</strong> Recursion & Induction</a></li></ol></li><li class="chapter-item expanded "><a href="../about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SML Help</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sml-syntax-cheatsheet"><a class="header" href="#sml-syntax-cheatsheet">SML Syntax Cheatsheet</a></h1>
<p><em>By David Sun, February 2021</em></p>
<h4 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h4>
<p>Six of the built-in types commonly encountered:</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>0</code></td><td style="text-align: center"><code>int</code></td></tr>
<tr><td style="text-align: center"><code>&quot;foo bar&quot;</code></td><td style="text-align: center"><code>string</code></td></tr>
<tr><td style="text-align: center"><code>#&quot; &quot;</code></td><td style="text-align: center"><code>char</code></td></tr>
<tr><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>bool</code></td></tr>
<tr><td style="text-align: center"><code>1.0</code></td><td style="text-align: center"><code>real</code></td></tr>
<tr><td style="text-align: center"><code>()</code></td><td style="text-align: center"><code>unit</code></td></tr>
</tbody></table>
<h4 id="structured-types"><a class="header" href="#structured-types">Structured Types</a></h4>
<p>Make tuples and lists using built-in types and themselves.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>(15,150)</code></td><td style="text-align: center"><code>int * int</code></td></tr>
<tr><td style="text-align: center"><code>[1,2,3,4]</code></td><td style="text-align: center"><code>int list</code></td></tr>
<tr><td style="text-align: center"><code>[[&quot;foo&quot;,&quot;bar&quot;],[&quot;baz&quot;]]</code></td><td style="text-align: center"><code>string list list</code></td></tr>
<tr><td style="text-align: center"><code>((true,1),(false,0,()))</code></td><td style="text-align: center"><code>(bool * int) * (bool * int * unit)</code></td></tr>
<tr><td style="text-align: center"><code>[(0,1),(1,0)]</code></td><td style="text-align: center"><code>(int * int) list</code></td></tr>
<tr><td style="text-align: center"><code>([#&quot;a&quot;,#&quot;b&quot;],[3.14])</code></td><td style="text-align: center"><code>char list * real list</code></td></tr>
</tbody></table>
<p>Note: 1-tuples don't exist in Standard ML.</p>
<h4 id="operators"><a class="header" href="#operators">Operators</a></h4>
<p>Operators have different priority levels. Higher priority operations are performed before lower priority operations.
The operators <code>*</code>, <code>+</code>, and <code>-</code> work on both <code>int</code> and <code>real</code> types.</p>
<table><thead><tr><th style="text-align: center">Operator</th><th style="text-align: center">Meaning</th><th style="text-align: center">Priority</th><th style="text-align: center">Example Expression</th><th style="text-align: center">Evaluates To</th><th style="text-align: center">Notes</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>*</code></td><td style="text-align: center">numeric multiplication</td><td style="text-align: center">7</td><td style="text-align: center"><code>8 * 3</code></td><td style="text-align: center"><code>24</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>/</code></td><td style="text-align: center"><code>real</code> division</td><td style="text-align: center">7</td><td style="text-align: center"><code>3.0 / 2.0</code></td><td style="text-align: center"><code>1.5</code></td><td style="text-align: center">operands must be <code>real</code></td></tr>
<tr><td style="text-align: center"><code>div</code></td><td style="text-align: center">integer divison</td><td style="text-align: center">7</td><td style="text-align: center"><code>3 div 2</code></td><td style="text-align: center"><code>1</code></td><td style="text-align: center">operands must be <code>int</code></td></tr>
<tr><td style="text-align: center"><code>mod</code></td><td style="text-align: center">&quot;modulo&quot;</td><td style="text-align: center">7</td><td style="text-align: center"><code>8 mod 3</code></td><td style="text-align: center"><code>2</code></td><td style="text-align: center">operands must be <code>int</code></td></tr>
<tr><td style="text-align: center"><code>+</code></td><td style="text-align: center">numeric addition</td><td style="text-align: center">6</td><td style="text-align: center"><code>3 + 4</code></td><td style="text-align: center"><code>7</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>-</code></td><td style="text-align: center">numeric subtraction</td><td style="text-align: center">6</td><td style="text-align: center"><code>3 - ~2</code></td><td style="text-align: center"><code>5</code></td><td style="text-align: center"><code>~</code> denotes negative numbers, e.g. <code>~5</code></td></tr>
<tr><td style="text-align: center"><code>^</code></td><td style="text-align: center">string combination</td><td style="text-align: center">6</td><td style="text-align: center"><code>&quot;foo&quot; ^ &quot;bar&quot;</code></td><td style="text-align: center"><code>&quot;foobar&quot;</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>::</code></td><td style="text-align: center">list construction (&quot;cons&quot;)</td><td style="text-align: center">5</td><td style="text-align: center"><code>1 :: [2,3,4]</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td><td style="text-align: center">right-associative</td></tr>
<tr><td style="text-align: center"><code>@</code></td><td style="text-align: center">list combination (&quot;append&quot;)</td><td style="text-align: center">5</td><td style="text-align: center"><code>[1,2] @ [3,4]</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td><td style="text-align: center">right-associative</td></tr>
</tbody></table>
<p>Except for <code>::</code> and <code>@</code>, the remaining built-in operators above are left-associative.
Left-associative operations of equal priority implicitly evaluate from left to right.
Right-associative operations of equal priority implicitly evaluate from right to left.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Implicit Interpretation</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>3 - ~2 + ~5</code></td><td style="text-align: center"><code>((3 - ~2) + ~5)</code></td><td style="text-align: center"><code>0</code></td></tr>
<tr><td style="text-align: center"><code>1 :: 2 :: 3 :: []</code></td><td style="text-align: center"><code>1 :: (2 :: (3 :: []))</code></td><td style="text-align: center"><code>[1,2,3]</code></td></tr>
<tr><td style="text-align: center"><code>1 :: [] @ 2 :: [] @ 3 :: []</code></td><td style="text-align: center"><code>1 :: ([] @ (2 :: ([] @ (3 :: []))))</code></td><td style="text-align: center"><code>[1,2,3]</code></td></tr>
</tbody></table>
<h4 id="boolean-operation"><a class="header" href="#boolean-operation">Boolean Operation</a></h4>
<p>There are three main ones: <code>andalso</code>, <code>orelse</code> and <code>not</code>.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th><th style="text-align: center">Notes</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>false andalso true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>andalso</code> short-circuits if left operand evaluates to <code>false</code></td></tr>
<tr><td style="text-align: center"><code>true orelse false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>orelse</code> short-circuits if left operand evaluates to <code>true</code></td></tr>
<tr><td style="text-align: center"><code>not true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>not false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"></td></tr>
</tbody></table>
<p>Note: See the page about the <code>bool</code> type <a href="../types/bool.html">here</a> for more information on short-circuiting behavior.</p>
<p>There are built-in equality operators: <code>=</code> and <code>&lt;&gt;</code>.</p>
<table><thead><tr><th style="text-align: center">Operator</th><th style="text-align: center">Meaning</th><th style="text-align: center">Priority</th><th style="text-align: center">Example Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>=</code></td><td style="text-align: center">&quot;equal to&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>1+2 = 4-1</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>&lt;&gt;</code></td><td style="text-align: center">&quot;not equal to&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>&quot;a&quot; &lt;&gt; &quot;b&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
</tbody></table>
<p>These two operate on <em>equality types</em>, which include the built-in types mentioned before — and the structured types that can be made from them — <strong>excluding</strong> <code>real</code> and function types.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>(true,true) = (true,true)</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>0 = 1 andalso 1 = 1</code></td><td style="text-align: center"><code>false</code></td></tr>
<tr><td style="text-align: center"><code>0 &lt;&gt; 0 orelse 1 &lt;&gt; 1</code></td><td style="text-align: center"><code>false</code></td></tr>
<tr><td style="text-align: center"><code>[1,2,3,4] = [1,2,3,4]</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>(1,2,&quot;a&quot;,&quot;b&quot;) = (1,2,&quot;a&quot;,&quot;b&quot;)</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>([1,2,3,4],([&quot;a&quot;,&quot;b&quot;],[()])) = ([1,2,3,4],([&quot;a&quot;,&quot;b&quot;],[()]))</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>0.0 = 0.0</code></td><td style="text-align: center">N/A: Not Well Typed</td></tr>
</tbody></table>
<p>Note: See the page about the <code>real</code> type <a href="../types/real.html">here</a> for more information on why <code>0.0 = 0.0</code> is not allowed.</p>
<p>There are built-in comparison operators <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, and <code>&lt;=</code>.</p>
<table><thead><tr><th style="text-align: center">Operator</th><th style="text-align: center">Meaning</th><th style="text-align: center">Priority</th><th style="text-align: center">Example Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&gt;</code></td><td style="text-align: center">&quot;greater than&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>&quot;ba&quot; &gt; &quot;ab&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>&lt;</code></td><td style="text-align: center">&quot;less than&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>&quot;ab&quot; &lt; &quot;abc&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>&gt;=</code></td><td style="text-align: center">&quot;greater than or equal to&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>#&quot;a&quot; &gt;= #&quot;A&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>&lt;=</code></td><td style="text-align: center">&quot;less than or equal to&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>&quot;cab&quot; &lt;= &quot;cba&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
</tbody></table>
<p>These have limited use; they operate on <code>int</code>, <code>string</code>, <code>char</code>, <code>real</code>.</p>
<p>To build good habits, please practice using the built-in comparison functions <code>Int.compare</code>, <code>String.compare</code>, <code>Char.compare</code>, and <code>Real.compare</code> to compare their corresponding types instead of exclusively using these equality and comparison operators.</p>
<h4 id="comparison-functions"><a class="header" href="#comparison-functions">Comparison Functions</a></h4>
<p>There is an <code>order</code> type with three values: <code>LESS</code>, <code>EQUAL</code>, and <code>GREATER</code>.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>LESS</code></td><td style="text-align: center"><code>order</code></td></tr>
<tr><td style="text-align: center"><code>EQUAL</code></td><td style="text-align: center"><code>order</code></td></tr>
<tr><td style="text-align: center"><code>GREATER</code></td><td style="text-align: center"><code>order</code></td></tr>
<tr><td style="text-align: center"><code>Int.compare</code></td><td style="text-align: center"><code>int * int -&gt; order</code></td></tr>
<tr><td style="text-align: center"><code>String.compare</code></td><td style="text-align: center"><code>string * string -&gt; order</code></td></tr>
<tr><td style="text-align: center"><code>Real.compare</code></td><td style="text-align: center"><code>real * real -&gt; order</code></td></tr>
</tbody></table>
<p>Example use:</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>Int.compare (~1,0)</code></td><td style="text-align: center"><code>LESS</code></td></tr>
<tr><td style="text-align: center"><code>Int.compare (0,0)</code></td><td style="text-align: center"><code>EQUAL</code></td></tr>
<tr><td style="text-align: center"><code>Int.compare (1,0)</code></td><td style="text-align: center"><code>GREATER</code></td></tr>
<tr><td style="text-align: center"><code>String.compare (&quot;abc&quot;,&quot;bac&quot;)</code></td><td style="text-align: center"><code>LESS</code></td></tr>
<tr><td style="text-align: center"><code>String.compare (&quot;cba&quot;,&quot;cb&quot;)</code></td><td style="text-align: center"><code>GREATER</code></td></tr>
<tr><td style="text-align: center"><code>Real.compare (0.0,0.0)</code></td><td style="text-align: center"><code>EQUAL</code></td></tr>
</tbody></table>
<p>Sometimes you want to compare data that is not of basic built-in types, e.g. when sorting lists of tuples. The built-in comparison operators by themselves will not work, but using the <code>order</code> type allows you to write a comparison function (perhaps using other comparison functions) that defines your own order over that data.</p>
<h4 id="comments"><a class="header" href="#comments">Comments</a></h4>
<p>Comments are denoted using <code>(* *)</code>.</p>
<pre><code class="language-sml">(* This is a comment. *)

(* This is another comment.
   Comments can span multiple lines!
 *)

(* This is (* a comment within *) a comment. *)
</code></pre>
<h4 id="value-binding"><a class="header" href="#value-binding">Value Binding</a></h4>
<p>Use the <code>val</code> keyword to create variables. It binds values to identifiers (variable names).</p>
<pre><code class="language-sml">val x : int = 5
val (a,b) : int * int = (1,2)
val L : int list = [3,4]
</code></pre>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>x</code></td><td style="text-align: center"><code>5</code></td></tr>
<tr><td style="text-align: center"><code>a</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>b</code></td><td style="text-align: center"><code>2</code></td></tr>
<tr><td style="text-align: center"><code>3 * x</code></td><td style="text-align: center"><code>15</code></td></tr>
<tr><td style="text-align: center"><code>2 * x * (5 + 2 * x)</code></td><td style="text-align: center"><code>150</code></td></tr>
<tr><td style="text-align: center"><code>a * x + b</code></td><td style="text-align: center"><code>7</code></td></tr>
<tr><td style="text-align: center"><code>a :: b :: L</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td></tr>
</tbody></table>
<h4 id="let-expressions"><a class="header" href="#let-expressions">Let-Expressions</a></h4>
<p>Create local bindings (local variables) to compute a <code>let</code>-expression.
Place declarations and bindings between the <code>let</code>-<code>in</code>; the <code>let</code>-expression between the <code>in</code>-<code>end</code>.
Can be nested.
The scope of the <code>let</code>-<code>in</code> declaration is that <code>let</code>-expression's expression.</p>
<head>
<style>
<p>table {
border-collapse: collapse;
width: 100%;
}</p>
<p>th {
background-color: #cccccc;
}</p>
<p>td {
border: 1px solid #dddddd;
}</p>
</style>
</head>
<table>
<tr>
<th> Expression </th>
<th> Evaluates To </th>
</tr>
<tr>
<td>
<pre><code class="language-sml">let
  val x : int = 25
  val x : int = x + 25 (* Shadows the previous x binding *)
  val y : int = x + 50
in
  x + y
end
</code></pre>
</td>
<td>
<pre><code class="language-sml">150
</code></pre>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">let
  val x : int = 25
in
  let
    val x : int = x + 25 (* Shadows the previous x binding *)
  in
    let
      val y : int = x + 50
    in
      x + y
    end
  end
end
</code></pre>
</td>
<td>
<pre><code class="language-sml">150
</code></pre>
</td>
</tr>
</table>
<h4 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h4>
<p>Write lambda expressions using the <code>fn</code> keyword — often verbalized as <strong>&quot;lambda&quot;</strong>.
A lambda expression is of the form: <code>fn</code>, pattern, <code>=&gt;</code>, expression.
The lambda expression itself is a value <a href="../assets/easteregg.jpg">—</a> a value of function type.
The <code>=&gt;</code> in lambda expressions correspond to the <code>-&gt;</code> in their types.
The <code>-&gt;</code> arrows are right-associative infix type constructors denoting function types.
Apply lambda expressions via prefix application — before the immediate operand.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>(fn (x : int,y : int) =&gt; x + y)</code></td><td style="text-align: center"><code>(fn (x : int,y : int) =&gt; x + y)</code></td><td style="text-align: center"><code>int * int -&gt; int</code></td></tr>
<tr><td style="text-align: center"><code>(3,4)</code></td><td style="text-align: center"><code>(3,4)</code></td><td style="text-align: center"><code>int * int</code></td></tr>
<tr><td style="text-align: center"><code>(fn (x : int,y : int) =&gt; x + y) (3,4)</code></td><td style="text-align: center"><code>7</code></td><td style="text-align: center"><code>int</code></td></tr>
</tbody></table>
<h4 id="function-binding"><a class="header" href="#function-binding">Function Binding</a></h4>
<p>Using a lambda expression more than once requires retyping it. We can give it a name instead.
The <code>val</code> and <code>fun</code> keywords bind a lambda expression to an identifier, creating a <em>named function</em>.
Take note that the <code>=</code> for binding differs from the <code>=&gt;</code> reserved word.</p>
<pre><code class="language-sml">(* add : int * int -&gt; int *)
val add : int * int -&gt; int = fn (x,y) =&gt; x + y

(* add : int * int -&gt; int *)
fun add (x : int,y : int) : int = x + y
</code></pre>
<p>Both function bindings for <code>add</code> above have the same value:
<code>(fn (x,y) =&gt; x + y) : int * int -&gt; int</code>.</p>
<p>A named function can be thought of as a lambda expression that has been &quot;identified&quot;.
The bindings to <code>add</code> identify (or name) an otherwise anonymous function.
Its value is the lambda expression it binds.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Value</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>add</code></td><td style="text-align: center"><code>(fn (x,y) =&gt; x + y)</code></td><td style="text-align: center"><code>int * int -&gt; int</code></td></tr>
<tr><td style="text-align: center"><code>(fn (x,y) =&gt; x + y)</code></td><td style="text-align: center"><code>(fn (x,y) =&gt; x + y)</code></td><td style="text-align: center"><code>int * int -&gt; int</code></td></tr>
<tr><td style="text-align: center"><code>add (3,4)</code></td><td style="text-align: center"><code>7</code></td><td style="text-align: center"><code>int</code></td></tr>
<tr><td style="text-align: center"><code>(fn (x,y) =&gt; x + y) (3,4)</code></td><td style="text-align: center"><code>7</code></td><td style="text-align: center"><code>int</code></td></tr>
</tbody></table>
<h4 id="patterns-and-case-expressions"><a class="header" href="#patterns-and-case-expressions">Patterns and Case Expressions</a></h4>
<p>Patterns are present in every lambda expression, <code>case</code> expression, <code>val</code>, and <code>fun</code> binding.
Every <code>fn</code> clause, <code>case</code> clause, and <code>fun</code> clause contains a pattern with a corresponding expression.
A clause is of the form: pattern, <code>=&gt;</code>, expression. Clauses are delimited by pipes <code>|</code>.</p>
<table>
<tr>
<th> Expression </th>
<th> Example Clause </th>
<th> Clause Pattern </th>
<th> Clause Expression </th>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn (x,y) =&gt; x + y)
</code></pre>
</td>
<td>
<p><code>(x,y) =&gt; x + y</code></p>
</td>
<td>
<p><code>(x,y)</code></p>
</td>
<td>
<p><code>x + y</code></p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn true  =&gt; 1 
  | false =&gt; 0)
</code></pre>
</td>
<td>
<p><code>true =&gt; 1</code></p>
</td>
<td>
<p><code>true</code></p>
</td>
<td>
<p><code>1</code></p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn 0 =&gt; true 
  | _ =&gt; false)
</code></pre>
</td>
<td>
<p><code>_ =&gt; false</code></p>
</td>
<td>
<p><code>_</code></p>
</td>
<td>
<p><code>false</code></p>
</td>
</tr>
</table>
<p>Lambda expressions and <code>case</code> expressions have the same clause syntax.
The clausal <em>patterns</em> must be able to match to the type of the expression being cased on.
The clausal <em>expressions</em> must all have the same type (which may be different from that of the expression cased on).</p>
<table>
<tr>
<th> Expression </th>
<th> Example Clause </th>
<th> Clause Pattern </th>
<th> Clause Expression </th>
</tr>
<tr>
<td>
<pre><code class="language-sml">(case () of 
      _ =&gt; ())
</code></pre>
</td>
<td>
<p><code>_ =&gt; ()</code></p>
</td>
<td>
<p><code>_</code></p>
</td>
<td>
<p><code>()</code></p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(case #&quot;A&quot; &lt; #&quot;a&quot; of 
      true  =&gt; &quot;:)&quot; 
    | false =&gt; &quot;:(&quot;)
</code></pre>
</td>
<td>
<p><code>true =&gt; &quot;:)&quot;</code></p>
</td>
<td>
<p><code>true</code></p>
</td>
<td>
<p><code>&quot;:)&quot;</code></p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(case Int.compare (1,0) of 
      LESS    =&gt; false 
    | EQUAL   =&gt; false 
    | GREATER =&gt; true)
</code></pre>
</td>
<td>
<p><code>GREATER =&gt; true</code></p>
</td>
<td>
<p><code>GREATER</code></p>
</td>
<td>
<p><code>true</code></p>
</td>
</tr>
</table>
<p>The wildcard pattern <code>_</code> will match to any type, but create no bindings (ignore it).</p>
<table><thead><tr><th style="text-align: right">Candidate</th><th style="text-align: left">Valid Pattern?</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>()</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>0</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>&quot;:)&quot;</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>true</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>EQUAL</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>3 + 4</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>&quot;:&quot; ^ &quot;)&quot;</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>3 &lt; 4</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>Int.compare (0,0)</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>Int.compare</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>0.0</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>(fn x =&gt; x)</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>x</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right">any variable name that is not a reserved word</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>_</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>(0,1)</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>(x,y)</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>(_,_)</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>(x,x)</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>[]</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>[x]</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>[[[]]]</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>([],[])</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>[] @ []</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>[x] @ xs</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>L @ R</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>x::xs</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>x::y::xs</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>_::_</code></td><td style="text-align: left">Yes</td></tr>
</tbody></table>
<p>A pattern that accounts for every possible value of the type it matches to is said to perform an exhaustive match. The match is nonexhaustive if and only if a possible value of that pattern's type is missed.</p>
<table>
<tr>
<th> Expression </th>
<th> Pattern Type </th>
<th> Exhaustive Match? </th>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn () =&gt; ())
</code></pre>
</td>
<td>
<p><code>unit</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn true =&gt; 1)
</code></pre>
</td>
<td>
<p><code>bool</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn true  =&gt; 1 
  | false =&gt; 0)
</code></pre>
</td>
<td>
<p><code>bool</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn LESS =&gt; ~1)
</code></pre>
</td>
<td>
<p><code>order</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn LESS  =&gt; ~1 
  | EQUAL =&gt; 0)
</code></pre>
</td>
<td>
<p><code>order</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn LESS    =&gt; ~1 
  | EQUAL   =&gt; 0 
  | GREATER =&gt; 1)
</code></pre>
</td>
<td>
<p><code>order</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn 0 =&gt; true)
</code></pre>
</td>
<td>
<p><code>int</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn 0 =&gt; true 
  | _ =&gt; false)
</code></pre>
</td>
<td>
<p><code>int</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn x::_ =&gt; x + 1)
</code></pre>
</td>
<td>
<p><code>int list</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn [] =&gt; 0 
  | x::_ =&gt; x + 1)
</code></pre>
</td>
<td>
<p><code>int list</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn (0,b) =&gt; true andalso b)
</code></pre>
</td>
<td>
<p><code>int * bool</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn (0,b) =&gt; true andalso b 
  | (n,_) =&gt; false)
</code></pre>
</td>
<td>
<p><code>int * bool</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
</table>
<p>Using a wildcard for the first clause's <em>entire</em> pattern produces an exhaustive match.</p>
<h4 id="recursive-function-binding"><a class="header" href="#recursive-function-binding">Recursive Function Binding</a></h4>
<p>The <code>rec</code> reserved word enables a lambda expression to self-reference within its body.
The <code>fun</code> reserved word allows self-reference by default.
The clause patterns and expressions in <code>fun</code> clauses are separated by <code>=</code> instead of <code>=&gt;</code>.</p>
<pre><code class="language-sml">val rec length : int list -&gt; int = fn [] =&gt; 0 | _::xs =&gt; 1 + length xs

fun length ([]    : int list) : int = 0
  | length (_::xs : int list) : int = 1 + length xs
</code></pre>
<p>As before, <em>both</em> <code>length</code> bindings have the same value. Don't forget about the lambda!</p>
<table>
<tr>
<th> Expression </th>
<th> Value </th>
<th> Type </th>
</tr>
<tr>
<td>
<p><code>length</code></p>
</td>
<td>
<pre><code class="language-sml">(fn [] =&gt; 0 | _::xs =&gt; 1 + length xs)
</code></pre>
</td>
<td>
<p><code>int list -&gt; int</code></p>
</td>
</tr>
<tr>
<td>
<p><code>length []</code></p>
</td>
<td>
<p><code>0</code></p>
</td>
<td>
<p><code>int</code></p>
</td>
</tr>
<tr>
<td>
<p><code>length [1,2,3,4]</code></p>
</td>
<td>
<p><code>4</code></p>
</td>
<td>
<p><code>int</code></p>
</td>
</tr>
</table>
<h4 id="conditional-expressions"><a class="header" href="#conditional-expressions">Conditional Expressions</a></h4>
<p>Require a condition that evaluates to <code>true</code> or <code>false</code>, after the <code>if</code>.
Two expressions of the same type — one for the <code>then</code>-branch, one for the <code>else</code>-branch.
Note that <code>if</code>-<code>then</code>-<code>else</code> expressions only evaluate one of its two branches — the one it takes.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>if 0 &lt;&gt; 1 then &quot;foo&quot; else &quot;bar&quot;</code></td><td style="text-align: center"><code>&quot;foo&quot;</code></td></tr>
<tr><td style="text-align: center"><code>if 0 = 1 then (if true then 1 else 2) else (if false then 3 else 4)</code></td><td style="text-align: center"><code>4</code></td></tr>
<tr><td style="text-align: center"><code>if true then 1 else (1 div 0)</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>if false then (1 div 0) else 0</code></td><td style="text-align: center"><code>0</code></td></tr>
</tbody></table>
<h4 id="op"><a class="header" href="#op">op</a></h4>
<p>The <code>op</code> keyword converts a binary infix operator to binary prefix operation. Priorities are kept the same as before.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>(op *) (8,3)</code></td><td style="text-align: center"><code>24</code></td></tr>
<tr><td style="text-align: center"><code>(op +) (3,4)</code></td><td style="text-align: center"><code>7</code></td></tr>
<tr><td style="text-align: center"><code>(op ^) (&quot;foo&quot;,&quot;bar&quot;)</code></td><td style="text-align: center"><code>&quot;foobar&quot;</code></td></tr>
<tr><td style="text-align: center"><code>(op ::) (1,[2,3,4])</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td></tr>
<tr><td style="text-align: center"><code>(op @) ([1,2],[3,4])</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td></tr>
</tbody></table>
<h4 id="as"><a class="header" href="#as">as</a></h4>
<p>If convenient, we can use the <code>as</code> keyword between a variable and a structured pattern to reference a structured value both as a whole and by its constituents. The pattern to the left of <code>as</code> must be a variable. It can be nested. It is always part of a pattern.</p>
<pre><code class="language-sml">val tuple as (a,b) : int * int = (1,2)
</code></pre>
<table><thead><tr><th style="text-align: center">Variable Name</th><th style="text-align: center">Bound To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>a</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>b</code></td><td style="text-align: center"><code>2</code></td></tr>
<tr><td style="text-align: center"><code>tuple</code></td><td style="text-align: center"><code>(1,2)</code></td></tr>
</tbody></table>
<pre><code class="language-sml">val outer as (inner as (a,b),c) : (int * int) * int = ((1,2),3)
</code></pre>
<table><thead><tr><th style="text-align: center">Variable Name</th><th style="text-align: center">Bound To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>outer</code></td><td style="text-align: center"><code>((1,2),3)</code></td></tr>
<tr><td style="text-align: center"><code>inner</code></td><td style="text-align: center"><code>(1,2)</code></td></tr>
<tr><td style="text-align: center"><code>a</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>b</code></td><td style="text-align: center"><code>2</code></td></tr>
<tr><td style="text-align: center"><code>c</code></td><td style="text-align: center"><code>3</code></td></tr>
</tbody></table>
<pre><code class="language-sml">val L1 as x1::(L2 as x2::(L3 as x3::L4)) : int list = [1,2,3]
</code></pre>
<table><thead><tr><th style="text-align: center">Variable Name</th><th style="text-align: center">Bound To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>L1</code></td><td style="text-align: center"><code>[1,2,3]</code></td></tr>
<tr><td style="text-align: center"><code>x1</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>L2</code></td><td style="text-align: center"><code>[2,3]</code></td></tr>
<tr><td style="text-align: center"><code>x2</code></td><td style="text-align: center"><code>2</code></td></tr>
<tr><td style="text-align: center"><code>L3</code></td><td style="text-align: center"><code>[3]</code></td></tr>
<tr><td style="text-align: center"><code>x3</code></td><td style="text-align: center"><code>3</code></td></tr>
<tr><td style="text-align: center"><code>L4</code></td><td style="text-align: center"><code>[]</code></td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../start/install.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../start/common.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../start/install.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../start/common.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
