<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SML Help</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A resource for learning SML">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Welcome!</a></li><li class="chapter-item expanded "><a href="start/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/install.html"><strong aria-hidden="true">1.1.</strong> Install & run SML</a></li><li class="chapter-item expanded "><a href="start/syntax.html"><strong aria-hidden="true">1.2.</strong> Syntax Cheatsheet</a></li><li class="chapter-item expanded "><a href="start/common.html"><strong aria-hidden="true">1.3.</strong> Common Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="types/index.html"><strong aria-hidden="true">2.</strong> Types & Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/type.html"><strong aria-hidden="true">2.1.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/bool.html"><strong aria-hidden="true">2.1.1.</strong> bool</a></li><li class="chapter-item expanded "><a href="types/int.html"><strong aria-hidden="true">2.1.2.</strong> int</a></li><li class="chapter-item expanded "><a href="types/real.html"><strong aria-hidden="true">2.1.3.</strong> real</a></li><li class="chapter-item expanded "><a href="types/string.html"><strong aria-hidden="true">2.1.4.</strong> string</a></li><li class="chapter-item expanded "><a href="types/function.html"><strong aria-hidden="true">2.1.5.</strong> function types</a></li><li class="chapter-item expanded "><a href="types/list.html"><strong aria-hidden="true">2.1.6.</strong> list</a></li><li class="chapter-item expanded "><a href="types/options.html"><strong aria-hidden="true">2.1.7.</strong> options</a></li></ol></li><li class="chapter-item expanded "><a href="types/sig.html"><strong aria-hidden="true">2.2.</strong> Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/basis.html"><strong aria-hidden="true">2.2.1.</strong> Basis Library Documentation</a></li><li class="chapter-item expanded "><a href="types/aux-lib.html"><strong aria-hidden="true">2.2.2.</strong> Auxiliary Library Documentation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="debugging/index.html"><strong aria-hidden="true">3.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="debugging/errors.html"><strong aria-hidden="true">3.1.</strong> Common Errors</a></li><li class="chapter-item expanded "><a href="debugging/hints.html"><strong aria-hidden="true">3.2.</strong> Debugging Hints</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/index.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/basic.html"><strong aria-hidden="true">4.1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/eval.html"><strong aria-hidden="true">4.1.1.</strong> Evaluation</a></li><li class="chapter-item expanded "><a href="concepts/eeq.html"><strong aria-hidden="true">4.1.2.</strong> Extensional Equivalence</a></li><li class="chapter-item expanded "><a href="concepts/patternmatch.html"><strong aria-hidden="true">4.1.3.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/recind.html"><strong aria-hidden="true">4.2.</strong> Recursion and Induction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/treeinduct.html"><strong aria-hidden="true">4.2.1.</strong> Tree Induction</a></li><li class="chapter-item expanded "><a href="concepts/tail.html"><strong aria-hidden="true">4.2.2.</strong> Tail Recursion</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/analysis.html"><strong aria-hidden="true">4.3.</strong> Asymptotic Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/workspan.html"><strong aria-hidden="true">4.3.1.</strong> Work and Span</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/datatypes.html"><strong aria-hidden="true">4.4.</strong> Datatypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/poly.html"><strong aria-hidden="true">4.4.1.</strong> Parametric Polymorphism</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/hofs.html"><strong aria-hidden="true">4.5.</strong> Higher Order Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/curry.html"><strong aria-hidden="true">4.5.1.</strong> Currying and Staging</a></li><li class="chapter-item expanded "><a href="concepts/common.html"><strong aria-hidden="true">4.5.2.</strong> Common HOFs and Partial Evaluation</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/control.html"><strong aria-hidden="true">4.6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/cps.html"><strong aria-hidden="true">4.6.1.</strong> Continuation Passing Style</a></li><li class="chapter-item expanded "><a href="concepts/exn.html"><strong aria-hidden="true">4.6.2.</strong> Exceptions</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/mods.html"><strong aria-hidden="true">4.7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/mods.html"><strong aria-hidden="true">4.7.1.</strong> Basics and Ascription</a></li><li class="chapter-item expanded "><a href="concepts/functors.html"><strong aria-hidden="true">4.7.2.</strong> Functors</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/apps.html"><strong aria-hidden="true">4.8.</strong> Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/sequences.html"><strong aria-hidden="true">4.8.1.</strong> Sequences</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/lazy.html"><strong aria-hidden="true">4.9.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="concepts/imperative.html"><strong aria-hidden="true">4.10.</strong> Imperative</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">5.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/basics.html"><strong aria-hidden="true">5.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="examples/recursion.html"><strong aria-hidden="true">5.2.</strong> Recursion & Induction</a></li></ol></li><li class="chapter-item expanded "><a href="about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SML Help</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome!</a></h1>
<p>Welcome to <code>smlhelp.github.io</code>! The goal of this site is to provide a convenient
resource for learning functional programming, particularly in the language of
Standard ML. You'll find various guides and references about the SML type system
&amp; functional programming concepts, as well as some worked examples and tutorials.
Click on the navigation links on the left to get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-smlnj"><a class="header" href="#installing-smlnj">Installing SML/NJ</a></h1>
<p><em>By Brandon Wu, May 2020</em>, <em>updated by Zach Battleman, April 2022</em></p>
<h2 id="installing-smlnj-on-afs"><a class="header" href="#installing-smlnj-on-afs">Installing SML/NJ on AFS</a></h2>
<p>To set up your SML/NJ environment on the Andrew File System (AFS), first you will need to log in to AFS.</p>
<p>You can do this by executing the command
<code>ssh &lt;andrew_id&gt;@unix.andrew.cmu.edu</code></p>
<p>You can do this from a terminal very straightforwardly on a Mac. If you are on a Windows machine, you may need to use an application such as Visual Studio Code or MobaXTerm to access a terminal.</p>
<p>Once you are in AFS, execute the command 
<code>/afs/andrew/course/15/150/bin/setup-path</code></p>
<p>Once the script has finished running, type in the command that it tells you to. It should look something like
<code>. '/afs/andrew.cmu.edu/usrc/&lt;andrew_id&gt;/.bashrc</code></p>
<p><strong>IMPORTANT:</strong> <em>Do not forget the . at the beginning!</em> This will cause the script to not work. </p>
<p>After finishing this, you should be able to type in <code>smlnj</code> from the command line and access the SML/NJ REPL.</p>
<h2 id="making-smlnj-a-bit-prettier"><a class="header" href="#making-smlnj-a-bit-prettier">Making SML/NJ a bit prettier</a></h2>
<p>Now that you've set up SML/NJ, you might want to make it a bit nicer to work with.</p>
<h3 id="vscode"><a class="header" href="#vscode">VSCode</a></h3>
<p>Simply install the Standard ML plugin. From the extensions window in VS Code, just type &quot;Standard ML&quot;
in the search and it should come up. If it does not, you can manually download the extension <a href="https://marketplace.visualstudio.com/items?itemName=freebroccolo.sml">here</a>
and install from the <code>.vsix</code> file. This can be done by clicking the three dots in the top right of the extensions menu
and clicking &quot;install from vsix&quot;. From there, simply provide the <code>.vsix</code> file you downloaded and now you're all set up!</p>
<h3 id="vim"><a class="header" href="#vim">Vim</a></h3>
<p>For the purposes of this document, I will provide instructions as if you 
are using regular Vim. If you are using neovim or some other vim derivative,
I'll provide links to the repositories I use, but <em>don't</em> run the exact commands -
they are for vim users specifically. Furthermore, this guide is for unix based machines -
not Windows. If you are on Windows, please check the associated repositories for instructions.
(Note, this will Work on WSL if you are using that, just not pure Windows)</p>
<h3 id="the-quick-and-easy-version"><a class="header" href="#the-quick-and-easy-version">The quick and easy version</a></h3>
<p>If all you care about is syntax highlighting outside of what the 15150 setup script
provides, simply add</p>
<pre><code>autocmd BufNewFile,BufRead *.fun set ft=sml
autocmd BufNewFile,BufRead *.sig set ft=sml
</code></pre>
<p>to your <code>.vimrc</code> file. You can find this file at <code>~/.vimrc</code>. You should now have syntax
highlighting on your <code>.sig</code> and <code>.fun</code> files!</p>
<h3 id="the-nitty-gritty-but-totally-worth-it-version"><a class="header" href="#the-nitty-gritty-but-totally-worth-it-version">The nitty gritty (but totally worth it) version</a></h3>
<h4 id="step-1-installing-a-plug-in-manager"><a class="header" href="#step-1-installing-a-plug-in-manager">Step 1) Installing a Plug-In manager</a></h4>
<p>If you already have one, feel free to skip this step!</p>
<p>There are many many choices for a Vim plugin manager, but I recommend using <a href="https://github.com/junegunn/vim-plug">Vim-Plug</a>. You can install it with:</p>
<p><code>curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></p>
<h4 id="step-2-modifying-your-vimrc"><a class="header" href="#step-2-modifying-your-vimrc">Step 2) Modifying your .vimrc</a></h4>
<p>Just slap this mess into your <code>.vimrc</code> (which can be found at <code>~/.vimrc</code>)</p>
<pre><code>call plug#begin()
Plug 'jez/vim-better-sml'

call plug#end()

augroup vimbettersml
  au!

  &quot; ----- Keybindings -----

  au FileType sml nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;leader&gt;t :SMLTypeQuery&lt;CR&gt;
  au FileType sml nnoremap &lt;silent&gt; &lt;buffer&gt; gd :SMLJumpToDef&lt;CR&gt;

  &quot; open the REPL terminal buffer
  au FileType sml nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;leader&gt;is :SMLReplStart&lt;CR&gt;
  &quot; close the REPL (mnemonic: k -&gt; kill)
  au FileType sml nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;leader&gt;ik :SMLReplStop&lt;CR&gt;
  &quot; build the project (using CM if possible)
  au FileType sml nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;leader&gt;ib :SMLReplBuild&lt;CR&gt;
  &quot; for opening a structure, not a file
  au FileType sml nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;leader&gt;io :SMLReplOpen&lt;CR&gt;
  &quot; use the current file into the REPL (even if using CM)
  au FileType sml nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;leader&gt;iu :SMLReplUse&lt;CR&gt;
  &quot; clear the REPL screen
  au FileType sml nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;leader&gt;ic :SMLReplClear&lt;CR&gt;
  &quot; set the print depth to 100
  au FileType sml nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;leader&gt;ip :SMLReplPrintDepth&lt;CR&gt;

  &quot; ----- Other settings -----

  &quot; Uncomment to try out conceal characters
  &quot;au FileType sml setlocal conceallevel=2

  &quot; Uncomment to try out same-width conceal characters
  &quot;let g:sml_greek_tyvar_show_tick = 1
augroup END
</code></pre>
<p>This configuration will setup a plugin called <a href="https://github.com/jez/vim-better-sml">vim-better-sml</a> with default keybindings (I’ll put notes on this at the bottom)</p>
<h4 id="step-3-open-vim-and-actually-install"><a class="header" href="#step-3-open-vim-and-actually-install">Step 3) Open vim and actually install</a></h4>
<p>When you open vim, type <code>:PlugInstall</code> and it should pop up a window where you see the plugin install. If so, congrats! 
You have syntax highlighting (and other cool features)</p>
<h4 id="step-4-optional-cool-stuff"><a class="header" href="#step-4-optional-cool-stuff">Step 4) Optional Cool stuff</a></h4>
<p>Conceal characters allow you to replace <code>fn</code> and <code>'a</code> with actual lambdas an alphas! It’s kind of hard to explain, but it's a really cool feature so try it!
Just uncomment the line (remove the quote at the front):</p>
<p><code>&quot;au FileType sml setlocal conceallevel=2</code></p>
<h4 id="step-5-keybindings"><a class="header" href="#step-5-keybindings">Step 5) Keybindings</a></h4>
<p>If you want to use some of the other features, just look at the keybind config. 
The most useful, in my opinion, 
is opening the REPL within vim which is by default <code>&lt;leader&gt; is</code>. I believe <code>&lt;leader&gt;</code> is <code>\</code> by default, so in order to open the REPL type <code>\is</code>. 
If this doesn’t work, you probably have a custom leader key which you can check with <code>:let mapleader</code>. Likewise,
to close the REPL is <code>&lt;leader&gt; ik</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sml-syntax-cheatsheet"><a class="header" href="#sml-syntax-cheatsheet">SML Syntax Cheatsheet</a></h1>
<p><em>By David Sun, February 2021</em></p>
<h4 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h4>
<p>Six of the built-in types commonly encountered:</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>0</code></td><td style="text-align: center"><code>int</code></td></tr>
<tr><td style="text-align: center"><code>&quot;foo bar&quot;</code></td><td style="text-align: center"><code>string</code></td></tr>
<tr><td style="text-align: center"><code>#&quot; &quot;</code></td><td style="text-align: center"><code>char</code></td></tr>
<tr><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>bool</code></td></tr>
<tr><td style="text-align: center"><code>1.0</code></td><td style="text-align: center"><code>real</code></td></tr>
<tr><td style="text-align: center"><code>()</code></td><td style="text-align: center"><code>unit</code></td></tr>
</tbody></table>
<h4 id="structured-types"><a class="header" href="#structured-types">Structured Types</a></h4>
<p>Make tuples and lists using built-in types and themselves.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>(15,150)</code></td><td style="text-align: center"><code>int * int</code></td></tr>
<tr><td style="text-align: center"><code>[1,2,3,4]</code></td><td style="text-align: center"><code>int list</code></td></tr>
<tr><td style="text-align: center"><code>[[&quot;foo&quot;,&quot;bar&quot;],[&quot;baz&quot;]]</code></td><td style="text-align: center"><code>string list list</code></td></tr>
<tr><td style="text-align: center"><code>((true,1),(false,0,()))</code></td><td style="text-align: center"><code>(bool * int) * (bool * int * unit)</code></td></tr>
<tr><td style="text-align: center"><code>[(0,1),(1,0)]</code></td><td style="text-align: center"><code>(int * int) list</code></td></tr>
<tr><td style="text-align: center"><code>([#&quot;a&quot;,#&quot;b&quot;],[3.14])</code></td><td style="text-align: center"><code>char list * real list</code></td></tr>
</tbody></table>
<p>Note: 1-tuples don't exist in Standard ML.</p>
<h4 id="operators"><a class="header" href="#operators">Operators</a></h4>
<p>Operators have different priority levels. Higher priority operations are performed before lower priority operations.
The operators <code>*</code>, <code>+</code>, and <code>-</code> work on both <code>int</code> and <code>real</code> types.</p>
<table><thead><tr><th style="text-align: center">Operator</th><th style="text-align: center">Meaning</th><th style="text-align: center">Priority</th><th style="text-align: center">Example Expression</th><th style="text-align: center">Evaluates To</th><th style="text-align: center">Notes</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>*</code></td><td style="text-align: center">numeric multiplication</td><td style="text-align: center">7</td><td style="text-align: center"><code>8 * 3</code></td><td style="text-align: center"><code>24</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>/</code></td><td style="text-align: center"><code>real</code> division</td><td style="text-align: center">7</td><td style="text-align: center"><code>3.0 / 2.0</code></td><td style="text-align: center"><code>1.5</code></td><td style="text-align: center">operands must be <code>real</code></td></tr>
<tr><td style="text-align: center"><code>div</code></td><td style="text-align: center">integer divison</td><td style="text-align: center">7</td><td style="text-align: center"><code>3 div 2</code></td><td style="text-align: center"><code>1</code></td><td style="text-align: center">operands must be <code>int</code></td></tr>
<tr><td style="text-align: center"><code>mod</code></td><td style="text-align: center">&quot;modulo&quot;</td><td style="text-align: center">7</td><td style="text-align: center"><code>8 mod 3</code></td><td style="text-align: center"><code>2</code></td><td style="text-align: center">operands must be <code>int</code></td></tr>
<tr><td style="text-align: center"><code>+</code></td><td style="text-align: center">numeric addition</td><td style="text-align: center">6</td><td style="text-align: center"><code>3 + 4</code></td><td style="text-align: center"><code>7</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>-</code></td><td style="text-align: center">numeric subtraction</td><td style="text-align: center">6</td><td style="text-align: center"><code>3 - ~2</code></td><td style="text-align: center"><code>5</code></td><td style="text-align: center"><code>~</code> denotes negative numbers, e.g. <code>~5</code></td></tr>
<tr><td style="text-align: center"><code>^</code></td><td style="text-align: center">string combination</td><td style="text-align: center">6</td><td style="text-align: center"><code>&quot;foo&quot; ^ &quot;bar&quot;</code></td><td style="text-align: center"><code>&quot;foobar&quot;</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>::</code></td><td style="text-align: center">list construction (&quot;cons&quot;)</td><td style="text-align: center">5</td><td style="text-align: center"><code>1 :: [2,3,4]</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td><td style="text-align: center">right-associative</td></tr>
<tr><td style="text-align: center"><code>@</code></td><td style="text-align: center">list combination (&quot;append&quot;)</td><td style="text-align: center">5</td><td style="text-align: center"><code>[1,2] @ [3,4]</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td><td style="text-align: center">right-associative</td></tr>
</tbody></table>
<p>Except for <code>::</code> and <code>@</code>, the remaining built-in operators above are left-associative.
Left-associative operations of equal priority implicitly evaluate from left to right.
Right-associative operations of equal priority implicitly evaluate from right to left.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Implicit Interpretation</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>3 - ~2 + ~5</code></td><td style="text-align: center"><code>((3 - ~2) + ~5)</code></td><td style="text-align: center"><code>0</code></td></tr>
<tr><td style="text-align: center"><code>1 :: 2 :: 3 :: []</code></td><td style="text-align: center"><code>1 :: (2 :: (3 :: []))</code></td><td style="text-align: center"><code>[1,2,3]</code></td></tr>
<tr><td style="text-align: center"><code>1 :: [] @ 2 :: [] @ 3 :: []</code></td><td style="text-align: center"><code>1 :: ([] @ (2 :: ([] @ (3 :: []))))</code></td><td style="text-align: center"><code>[1,2,3]</code></td></tr>
</tbody></table>
<h4 id="boolean-operation"><a class="header" href="#boolean-operation">Boolean Operation</a></h4>
<p>There are three main ones: <code>andalso</code>, <code>orelse</code> and <code>not</code>.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th><th style="text-align: center">Notes</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>false andalso true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>andalso</code> short-circuits if left operand evaluates to <code>false</code></td></tr>
<tr><td style="text-align: center"><code>true orelse false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>orelse</code> short-circuits if left operand evaluates to <code>true</code></td></tr>
<tr><td style="text-align: center"><code>not true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>not false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"></td></tr>
</tbody></table>
<p>Note: See the page about the <code>bool</code> type <a href="start/../types/bool.html">here</a> for more information on short-circuiting behavior.</p>
<p>There are built-in equality operators: <code>=</code> and <code>&lt;&gt;</code>.</p>
<table><thead><tr><th style="text-align: center">Operator</th><th style="text-align: center">Meaning</th><th style="text-align: center">Priority</th><th style="text-align: center">Example Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>=</code></td><td style="text-align: center">&quot;equal to&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>1+2 = 4-1</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>&lt;&gt;</code></td><td style="text-align: center">&quot;not equal to&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>&quot;a&quot; &lt;&gt; &quot;b&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
</tbody></table>
<p>These two operate on <em>equality types</em>, which include the built-in types mentioned before — and the structured types that can be made from them — <strong>excluding</strong> <code>real</code> and function types.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>(true,true) = (true,true)</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>0 = 1 andalso 1 = 1</code></td><td style="text-align: center"><code>false</code></td></tr>
<tr><td style="text-align: center"><code>0 &lt;&gt; 0 orelse 1 &lt;&gt; 1</code></td><td style="text-align: center"><code>false</code></td></tr>
<tr><td style="text-align: center"><code>[1,2,3,4] = [1,2,3,4]</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>(1,2,&quot;a&quot;,&quot;b&quot;) = (1,2,&quot;a&quot;,&quot;b&quot;)</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>([1,2,3,4],([&quot;a&quot;,&quot;b&quot;],[()])) = ([1,2,3,4],([&quot;a&quot;,&quot;b&quot;],[()]))</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>0.0 = 0.0</code></td><td style="text-align: center">N/A: Not Well Typed</td></tr>
</tbody></table>
<p>Note: See the page about the <code>real</code> type <a href="start/../types/real.html">here</a> for more information on why <code>0.0 = 0.0</code> is not allowed.</p>
<p>There are built-in comparison operators <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, and <code>&lt;=</code>.</p>
<table><thead><tr><th style="text-align: center">Operator</th><th style="text-align: center">Meaning</th><th style="text-align: center">Priority</th><th style="text-align: center">Example Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&gt;</code></td><td style="text-align: center">&quot;greater than&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>&quot;ba&quot; &gt; &quot;ab&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>&lt;</code></td><td style="text-align: center">&quot;less than&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>&quot;ab&quot; &lt; &quot;abc&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>&gt;=</code></td><td style="text-align: center">&quot;greater than or equal to&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>#&quot;a&quot; &gt;= #&quot;A&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>&lt;=</code></td><td style="text-align: center">&quot;less than or equal to&quot;</td><td style="text-align: center">4</td><td style="text-align: center"><code>&quot;cab&quot; &lt;= &quot;cba&quot;</code></td><td style="text-align: center"><code>true</code></td></tr>
</tbody></table>
<p>These have limited use; they operate on <code>int</code>, <code>string</code>, <code>char</code>, <code>real</code>.</p>
<p>To build good habits, please practice using the built-in comparison functions <code>Int.compare</code>, <code>String.compare</code>, <code>Char.compare</code>, and <code>Real.compare</code> to compare their corresponding types instead of exclusively using these equality and comparison operators.</p>
<h4 id="comparison-functions"><a class="header" href="#comparison-functions">Comparison Functions</a></h4>
<p>There is an <code>order</code> type with three values: <code>LESS</code>, <code>EQUAL</code>, and <code>GREATER</code>.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>LESS</code></td><td style="text-align: center"><code>order</code></td></tr>
<tr><td style="text-align: center"><code>EQUAL</code></td><td style="text-align: center"><code>order</code></td></tr>
<tr><td style="text-align: center"><code>GREATER</code></td><td style="text-align: center"><code>order</code></td></tr>
<tr><td style="text-align: center"><code>Int.compare</code></td><td style="text-align: center"><code>int * int -&gt; order</code></td></tr>
<tr><td style="text-align: center"><code>String.compare</code></td><td style="text-align: center"><code>string * string -&gt; order</code></td></tr>
<tr><td style="text-align: center"><code>Real.compare</code></td><td style="text-align: center"><code>real * real -&gt; order</code></td></tr>
</tbody></table>
<p>Example use:</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>Int.compare (~1,0)</code></td><td style="text-align: center"><code>LESS</code></td></tr>
<tr><td style="text-align: center"><code>Int.compare (0,0)</code></td><td style="text-align: center"><code>EQUAL</code></td></tr>
<tr><td style="text-align: center"><code>Int.compare (1,0)</code></td><td style="text-align: center"><code>GREATER</code></td></tr>
<tr><td style="text-align: center"><code>String.compare (&quot;abc&quot;,&quot;bac&quot;)</code></td><td style="text-align: center"><code>LESS</code></td></tr>
<tr><td style="text-align: center"><code>String.compare (&quot;cba&quot;,&quot;cb&quot;)</code></td><td style="text-align: center"><code>GREATER</code></td></tr>
<tr><td style="text-align: center"><code>Real.compare (0.0,0.0)</code></td><td style="text-align: center"><code>EQUAL</code></td></tr>
</tbody></table>
<p>Sometimes you want to compare data that is not of basic built-in types, e.g. when sorting lists of tuples. The built-in comparison operators by themselves will not work, but using the <code>order</code> type allows you to write a comparison function (perhaps using other comparison functions) that defines your own order over that data.</p>
<h4 id="comments"><a class="header" href="#comments">Comments</a></h4>
<p>Comments are denoted using <code>(* *)</code>.</p>
<pre><code class="language-sml">(* This is a comment. *)

(* This is another comment.
   Comments can span multiple lines!
 *)

(* This is (* a comment within *) a comment. *)
</code></pre>
<h4 id="value-binding"><a class="header" href="#value-binding">Value Binding</a></h4>
<p>Use the <code>val</code> keyword to create variables. It binds values to identifiers (variable names).</p>
<pre><code class="language-sml">val x : int = 5
val (a,b) : int * int = (1,2)
val L : int list = [3,4]
</code></pre>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>x</code></td><td style="text-align: center"><code>5</code></td></tr>
<tr><td style="text-align: center"><code>a</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>b</code></td><td style="text-align: center"><code>2</code></td></tr>
<tr><td style="text-align: center"><code>3 * x</code></td><td style="text-align: center"><code>15</code></td></tr>
<tr><td style="text-align: center"><code>2 * x * (5 + 2 * x)</code></td><td style="text-align: center"><code>150</code></td></tr>
<tr><td style="text-align: center"><code>a * x + b</code></td><td style="text-align: center"><code>7</code></td></tr>
<tr><td style="text-align: center"><code>a :: b :: L</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td></tr>
</tbody></table>
<h4 id="let-expressions"><a class="header" href="#let-expressions">Let-Expressions</a></h4>
<p>Create local bindings (local variables) to compute a <code>let</code>-expression.
Place declarations and bindings between the <code>let</code>-<code>in</code>; the <code>let</code>-expression between the <code>in</code>-<code>end</code>.
Can be nested.
The scope of the <code>let</code>-<code>in</code> declaration is that <code>let</code>-expression's expression.</p>
<head>
<style>
<p>table {
border-collapse: collapse;
width: 100%;
}</p>
<p>th {
background-color: #cccccc;
}</p>
<p>td {
border: 1px solid #dddddd;
}</p>
</style>
</head>
<table>
<tr>
<th> Expression </th>
<th> Evaluates To </th>
</tr>
<tr>
<td>
<pre><code class="language-sml">let
  val x : int = 25
  val x : int = x + 25 (* Shadows the previous x binding *)
  val y : int = x + 50
in
  x + y
end
</code></pre>
</td>
<td>
<pre><code class="language-sml">150
</code></pre>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">let
  val x : int = 25
in
  let
    val x : int = x + 25 (* Shadows the previous x binding *)
  in
    let
      val y : int = x + 50
    in
      x + y
    end
  end
end
</code></pre>
</td>
<td>
<pre><code class="language-sml">150
</code></pre>
</td>
</tr>
</table>
<h4 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h4>
<p>Write lambda expressions using the <code>fn</code> keyword — often verbalized as <strong>&quot;lambda&quot;</strong>.
A lambda expression is of the form: <code>fn</code>, pattern, <code>=&gt;</code>, expression.
The lambda expression itself is a value <a href="start/../assets/easteregg.jpg">—</a> a value of function type.
The <code>=&gt;</code> in lambda expressions correspond to the <code>-&gt;</code> in their types.
The <code>-&gt;</code> arrows are right-associative infix type constructors denoting function types.
Apply lambda expressions via prefix application — before the immediate operand.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>(fn (x : int,y : int) =&gt; x + y)</code></td><td style="text-align: center"><code>(fn (x : int,y : int) =&gt; x + y)</code></td><td style="text-align: center"><code>int * int -&gt; int</code></td></tr>
<tr><td style="text-align: center"><code>(3,4)</code></td><td style="text-align: center"><code>(3,4)</code></td><td style="text-align: center"><code>int * int</code></td></tr>
<tr><td style="text-align: center"><code>(fn (x : int,y : int) =&gt; x + y) (3,4)</code></td><td style="text-align: center"><code>7</code></td><td style="text-align: center"><code>int</code></td></tr>
</tbody></table>
<h4 id="function-binding"><a class="header" href="#function-binding">Function Binding</a></h4>
<p>Using a lambda expression more than once requires retyping it. We can give it a name instead.
The <code>val</code> and <code>fun</code> keywords bind a lambda expression to an identifier, creating a <em>named function</em>.
Take note that the <code>=</code> for binding differs from the <code>=&gt;</code> reserved word.</p>
<pre><code class="language-sml">(* add : int * int -&gt; int *)
val add : int * int -&gt; int = fn (x,y) =&gt; x + y

(* add : int * int -&gt; int *)
fun add (x : int,y : int) : int = x + y
</code></pre>
<p>Both function bindings for <code>add</code> above have the same value:
<code>(fn (x,y) =&gt; x + y) : int * int -&gt; int</code>.</p>
<p>A named function can be thought of as a lambda expression that has been &quot;identified&quot;.
The bindings to <code>add</code> identify (or name) an otherwise anonymous function.
Its value is the lambda expression it binds.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Value</th><th style="text-align: center">Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>add</code></td><td style="text-align: center"><code>(fn (x,y) =&gt; x + y)</code></td><td style="text-align: center"><code>int * int -&gt; int</code></td></tr>
<tr><td style="text-align: center"><code>(fn (x,y) =&gt; x + y)</code></td><td style="text-align: center"><code>(fn (x,y) =&gt; x + y)</code></td><td style="text-align: center"><code>int * int -&gt; int</code></td></tr>
<tr><td style="text-align: center"><code>add (3,4)</code></td><td style="text-align: center"><code>7</code></td><td style="text-align: center"><code>int</code></td></tr>
<tr><td style="text-align: center"><code>(fn (x,y) =&gt; x + y) (3,4)</code></td><td style="text-align: center"><code>7</code></td><td style="text-align: center"><code>int</code></td></tr>
</tbody></table>
<h4 id="patterns-and-case-expressions"><a class="header" href="#patterns-and-case-expressions">Patterns and Case Expressions</a></h4>
<p>Patterns are present in every lambda expression, <code>case</code> expression, <code>val</code>, and <code>fun</code> binding.
Every <code>fn</code> clause, <code>case</code> clause, and <code>fun</code> clause contains a pattern with a corresponding expression.
A clause is of the form: pattern, <code>=&gt;</code>, expression. Clauses are delimited by pipes <code>|</code>.</p>
<table>
<tr>
<th> Expression </th>
<th> Example Clause </th>
<th> Clause Pattern </th>
<th> Clause Expression </th>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn (x,y) =&gt; x + y)
</code></pre>
</td>
<td>
<p><code>(x,y) =&gt; x + y</code></p>
</td>
<td>
<p><code>(x,y)</code></p>
</td>
<td>
<p><code>x + y</code></p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn true  =&gt; 1 
  | false =&gt; 0)
</code></pre>
</td>
<td>
<p><code>true =&gt; 1</code></p>
</td>
<td>
<p><code>true</code></p>
</td>
<td>
<p><code>1</code></p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn 0 =&gt; true 
  | _ =&gt; false)
</code></pre>
</td>
<td>
<p><code>_ =&gt; false</code></p>
</td>
<td>
<p><code>_</code></p>
</td>
<td>
<p><code>false</code></p>
</td>
</tr>
</table>
<p>Lambda expressions and <code>case</code> expressions have the same clause syntax.
The clausal <em>patterns</em> must be able to match to the type of the expression being cased on.
The clausal <em>expressions</em> must all have the same type (which may be different from that of the expression cased on).</p>
<table>
<tr>
<th> Expression </th>
<th> Example Clause </th>
<th> Clause Pattern </th>
<th> Clause Expression </th>
</tr>
<tr>
<td>
<pre><code class="language-sml">(case () of 
      _ =&gt; ())
</code></pre>
</td>
<td>
<p><code>_ =&gt; ()</code></p>
</td>
<td>
<p><code>_</code></p>
</td>
<td>
<p><code>()</code></p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(case #&quot;A&quot; &lt; #&quot;a&quot; of 
      true  =&gt; &quot;:)&quot; 
    | false =&gt; &quot;:(&quot;)
</code></pre>
</td>
<td>
<p><code>true =&gt; &quot;:)&quot;</code></p>
</td>
<td>
<p><code>true</code></p>
</td>
<td>
<p><code>&quot;:)&quot;</code></p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(case Int.compare (1,0) of 
      LESS    =&gt; false 
    | EQUAL   =&gt; false 
    | GREATER =&gt; true)
</code></pre>
</td>
<td>
<p><code>GREATER =&gt; true</code></p>
</td>
<td>
<p><code>GREATER</code></p>
</td>
<td>
<p><code>true</code></p>
</td>
</tr>
</table>
<p>The wildcard pattern <code>_</code> will match to any type, but create no bindings (ignore it).</p>
<table><thead><tr><th style="text-align: right">Candidate</th><th style="text-align: left">Valid Pattern?</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>()</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>0</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>&quot;:)&quot;</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>true</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>EQUAL</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>3 + 4</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>&quot;:&quot; ^ &quot;)&quot;</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>3 &lt; 4</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>Int.compare (0,0)</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>Int.compare</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>0.0</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>(fn x =&gt; x)</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>x</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right">any variable name that is not a reserved word</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>_</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>(0,1)</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>(x,y)</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>(_,_)</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>(x,x)</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>[]</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>[x]</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>[[[]]]</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>([],[])</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>[] @ []</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>[x] @ xs</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>L @ R</code></td><td style="text-align: left">No</td></tr>
<tr><td style="text-align: right"><code>x::xs</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>x::y::xs</code></td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: right"><code>_::_</code></td><td style="text-align: left">Yes</td></tr>
</tbody></table>
<p>A pattern that accounts for every possible value of the type it matches to is said to perform an exhaustive match. The match is nonexhaustive if and only if a possible value of that pattern's type is missed.</p>
<table>
<tr>
<th> Expression </th>
<th> Pattern Type </th>
<th> Exhaustive Match? </th>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn () =&gt; ())
</code></pre>
</td>
<td>
<p><code>unit</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn true =&gt; 1)
</code></pre>
</td>
<td>
<p><code>bool</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn true  =&gt; 1 
  | false =&gt; 0)
</code></pre>
</td>
<td>
<p><code>bool</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn LESS =&gt; ~1)
</code></pre>
</td>
<td>
<p><code>order</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn LESS  =&gt; ~1 
  | EQUAL =&gt; 0)
</code></pre>
</td>
<td>
<p><code>order</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn LESS    =&gt; ~1 
  | EQUAL   =&gt; 0 
  | GREATER =&gt; 1)
</code></pre>
</td>
<td>
<p><code>order</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn 0 =&gt; true)
</code></pre>
</td>
<td>
<p><code>int</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn 0 =&gt; true 
  | _ =&gt; false)
</code></pre>
</td>
<td>
<p><code>int</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn x::_ =&gt; x + 1)
</code></pre>
</td>
<td>
<p><code>int list</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn [] =&gt; 0 
  | x::_ =&gt; x + 1)
</code></pre>
</td>
<td>
<p><code>int list</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn (0,b) =&gt; true andalso b)
</code></pre>
</td>
<td>
<p><code>int * bool</code></p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<pre><code class="language-sml">(fn (0,b) =&gt; true andalso b 
  | (n,_) =&gt; false)
</code></pre>
</td>
<td>
<p><code>int * bool</code></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
</table>
<p>Using a wildcard for the first clause's <em>entire</em> pattern produces an exhaustive match.</p>
<h4 id="recursive-function-binding"><a class="header" href="#recursive-function-binding">Recursive Function Binding</a></h4>
<p>The <code>rec</code> reserved word enables a lambda expression to self-reference within its body.
The <code>fun</code> reserved word allows self-reference by default.
The clause patterns and expressions in <code>fun</code> clauses are separated by <code>=</code> instead of <code>=&gt;</code>.</p>
<pre><code class="language-sml">val rec length : int list -&gt; int = fn [] =&gt; 0 | _::xs =&gt; 1 + length xs

fun length ([]    : int list) : int = 0
  | length (_::xs : int list) : int = 1 + length xs
</code></pre>
<p>As before, <em>both</em> <code>length</code> bindings have the same value. Don't forget about the lambda!</p>
<table>
<tr>
<th> Expression </th>
<th> Value </th>
<th> Type </th>
</tr>
<tr>
<td>
<p><code>length</code></p>
</td>
<td>
<pre><code class="language-sml">(fn [] =&gt; 0 | _::xs =&gt; 1 + length xs)
</code></pre>
</td>
<td>
<p><code>int list -&gt; int</code></p>
</td>
</tr>
<tr>
<td>
<p><code>length []</code></p>
</td>
<td>
<p><code>0</code></p>
</td>
<td>
<p><code>int</code></p>
</td>
</tr>
<tr>
<td>
<p><code>length [1,2,3,4]</code></p>
</td>
<td>
<p><code>4</code></p>
</td>
<td>
<p><code>int</code></p>
</td>
</tr>
</table>
<h4 id="conditional-expressions"><a class="header" href="#conditional-expressions">Conditional Expressions</a></h4>
<p>Require a condition that evaluates to <code>true</code> or <code>false</code>, after the <code>if</code>.
Two expressions of the same type — one for the <code>then</code>-branch, one for the <code>else</code>-branch.
Note that <code>if</code>-<code>then</code>-<code>else</code> expressions only evaluate one of its two branches — the one it takes.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>if 0 &lt;&gt; 1 then &quot;foo&quot; else &quot;bar&quot;</code></td><td style="text-align: center"><code>&quot;foo&quot;</code></td></tr>
<tr><td style="text-align: center"><code>if 0 = 1 then (if true then 1 else 2) else (if false then 3 else 4)</code></td><td style="text-align: center"><code>4</code></td></tr>
<tr><td style="text-align: center"><code>if true then 1 else (1 div 0)</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>if false then (1 div 0) else 0</code></td><td style="text-align: center"><code>0</code></td></tr>
</tbody></table>
<h4 id="op"><a class="header" href="#op">op</a></h4>
<p>The <code>op</code> keyword converts a binary infix operator to binary prefix operation. Priorities are kept the same as before.</p>
<table><thead><tr><th style="text-align: center">Expression</th><th style="text-align: center">Evaluates To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>(op *) (8,3)</code></td><td style="text-align: center"><code>24</code></td></tr>
<tr><td style="text-align: center"><code>(op +) (3,4)</code></td><td style="text-align: center"><code>7</code></td></tr>
<tr><td style="text-align: center"><code>(op ^) (&quot;foo&quot;,&quot;bar&quot;)</code></td><td style="text-align: center"><code>&quot;foobar&quot;</code></td></tr>
<tr><td style="text-align: center"><code>(op ::) (1,[2,3,4])</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td></tr>
<tr><td style="text-align: center"><code>(op @) ([1,2],[3,4])</code></td><td style="text-align: center"><code>[1,2,3,4]</code></td></tr>
</tbody></table>
<h4 id="as"><a class="header" href="#as">as</a></h4>
<p>If convenient, we can use the <code>as</code> keyword between a variable and a structured pattern to reference a structured value both as a whole and by its constituents. The pattern to the left of <code>as</code> must be a variable. It can be nested. It is always part of a pattern.</p>
<pre><code class="language-sml">val tuple as (a,b) : int * int = (1,2)
</code></pre>
<table><thead><tr><th style="text-align: center">Variable Name</th><th style="text-align: center">Bound To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>a</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>b</code></td><td style="text-align: center"><code>2</code></td></tr>
<tr><td style="text-align: center"><code>tuple</code></td><td style="text-align: center"><code>(1,2)</code></td></tr>
</tbody></table>
<pre><code class="language-sml">val outer as (inner as (a,b),c) : (int * int) * int = ((1,2),3)
</code></pre>
<table><thead><tr><th style="text-align: center">Variable Name</th><th style="text-align: center">Bound To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>outer</code></td><td style="text-align: center"><code>((1,2),3)</code></td></tr>
<tr><td style="text-align: center"><code>inner</code></td><td style="text-align: center"><code>(1,2)</code></td></tr>
<tr><td style="text-align: center"><code>a</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>b</code></td><td style="text-align: center"><code>2</code></td></tr>
<tr><td style="text-align: center"><code>c</code></td><td style="text-align: center"><code>3</code></td></tr>
</tbody></table>
<pre><code class="language-sml">val L1 as x1::(L2 as x2::(L3 as x3::L4)) : int list = [1,2,3]
</code></pre>
<table><thead><tr><th style="text-align: center">Variable Name</th><th style="text-align: center">Bound To</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>L1</code></td><td style="text-align: center"><code>[1,2,3]</code></td></tr>
<tr><td style="text-align: center"><code>x1</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center"><code>L2</code></td><td style="text-align: center"><code>[2,3]</code></td></tr>
<tr><td style="text-align: center"><code>x2</code></td><td style="text-align: center"><code>2</code></td></tr>
<tr><td style="text-align: center"><code>L3</code></td><td style="text-align: center"><code>[3]</code></td></tr>
<tr><td style="text-align: center"><code>x3</code></td><td style="text-align: center"><code>3</code></td></tr>
<tr><td style="text-align: center"><code>L4</code></td><td style="text-align: center"><code>[]</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-tasks-in-sml"><a class="header" href="#common-tasks-in-sml">Common Tasks in SML</a></h1>
<p><em>By Thea Brick, December 2021</em></p>
<h2 id="looping-and-iterating"><a class="header" href="#looping-and-iterating">Looping and Iterating</a></h2>
<p>Often times we want to iterate through each element in a list. The main way we
want to implement this in SML is via recursion. We can define this at on an
extremely abstract level as taking some base accumulator and combining it with
an element to make a new accumulator.</p>
<pre><code class="language-sml">(* some base accumulator *)
val acc = ...

(* some function which takes an element of the list and
 * and a accumulator and outputs an updated accumulator
 *)
fun combine (x, acc) = ...

fun iterate ([]) = acc
  | iterate (x::xs) =
    let
      val new_acc = iterate xs
    in
      combine (x, new_acc)
    end
</code></pre>
<p>To make this more concrete, we can imagine we are trying to sum an int list.
The base accumulator would be what the sum of the empty list is. The combine
function would be simply adding the element onto the accumulator.</p>
<pre><code class="language-sml">val acc : int = 0

fun combine (x : int, acc : int) : int = x + acc

fun iterate ([] : int list) : int = acc
  | iterate (x::xs : int list) =
    let
      val new_acc = iterate xs
    in
      combine (x, new_acc)
    end
</code></pre>
<p>Now iterate will sum up a list for us. Generally we simply our functions a bit,
so it might be more common to see something along the lines of:</p>
<pre><code class="language-sml">fun sum ([] : int list) : int = 0
  | sum (x::xs : int list) : int = x + (sum xs)
</code></pre>
<p>Observe that these are same, just we are removing the let expression and
simplifying some things for the sake of readability.</p>
<h2 id="searching"><a class="header" href="#searching">Searching</a></h2>
<p>Often times we may be given a list and we'd like to see if an element is in
said list. In this case we want <code>search (L, y)</code>to evaluate to <code>true</code> if <code>y</code> is
in <code>L</code> and <code>false</code> otherwise. We can do this with this same idea of iteration.</p>
<pre><code class="language-sml">fun search ([] : int list, y : int) : bool = false
  | search (x::xs : int list, y : int) : bool =
    if x = y
    then true (* we can stop iterating if we find the value *)
    else search (xs, y)
</code></pre>
<p>Alternatively we can write this as:</p>
<pre><code class="language-sml">fun search ([] : int list, y : int) : bool = false
  | search (x::xs : int list, y : int) : bool =
    (x = y) orelse (search (xs, y))
</code></pre>
<p>If we require that the list is sorted, then we can alter our function to stop
looking through the list once we pass where <code>y</code> should be:</p>
<pre><code class="language-sml">fun sortedSearch ([] : int list, y : int) : bool = false
  | sortedSearch (x::xs : int list, y : int) : bool =
    (x = y) orelse ((x &lt; y) andalso (sortedSearch (xs, y)))
</code></pre>
<h2 id="runtime-checks"><a class="header" href="#runtime-checks">Runtime checks</a></h2>
<p>If we ever wanted to ensure that we have some property at runtime, we can write
some thing of the following form:</p>
<pre><code class="language-sml">val _ = (condition_that_should_be_true) orelse (raise Fail &quot;Condition False!&quot;)
</code></pre>
<p>So for instance, suppose we wanted to enforce that our sortedSearch function
from before actually sorted int lists.</p>
<pre><code class="language-sml">fun isSorted ([] : int list) : bool = true
  | isSorted (x::[]) = true
  | isSorted (x1::x2::xs) = (x &lt; y) andalso (isSorted (x2::xs))

fun sortedSearch (L, y) =
  let
    val _ = (isSorted L) andalso (raise Fail &quot;Unsorted List!&quot;)
    (* we define a recursive helper function so that the runtime check
     * is only checked once rather than at every step. *)
    fun helper ([] : int list) : bool = false
      | helper (x::xs : int list) : bool =
        (x = y) orelse ((x &lt; y) andalso (helper xs))
  in
    helper L
  end
</code></pre>
<p>Importantly, we generally just assume that a function has an assumed property
when passed into the function (and we don't care about inputs that don't
satisfy this), so inserting runtime checks like these are mainly useful for
debugging.</p>
<h2 id="print-line-debugging"><a class="header" href="#print-line-debugging">Print-line Debugging</a></h2>
<p>SMLNJ defines the function <code>print : string -&gt; unit</code> which outputs the passed
string. We can use val declarations to in let expressiosn to print out a message
while we are computing some result:</p>
<pre><code class="language-sml">let
  ...
  val () = print &quot;some message&quot;
  ...
in ... end
</code></pre>
<p>In our search example, we can use the <code>Int.toString : int -&gt; string</code> function
to print every element we visit while we are searching:</p>
<pre><code class="language-sml">fun search ([] : int list, y : int) : bool = false
  | search (x::xs : int list, y : int) : bool =
    let
      val () = print (Int.toString x)
    in
      (x = y) orelse (search (xs, y))
    end
</code></pre>
<p>Alternatively, we can use the sequencing operator <code>;</code> to put the prints in line.</p>
<pre><code class="language-sml">fun search ([] : int list, y : int) : bool = false
  | search (x::xs : int list, y : int) : bool =
    (print (Int.toString x); (x = y) orelse (search (xs, y)))
</code></pre>
<p>It should be noted that <code>;</code> often doesn't ''play nice'' with many things in SML,
so it is best to enclose every sequence of expressions with parentheses as we did above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types--signatures"><a class="header" href="#types--signatures">Types &amp; Signatures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p><em>By Brandon Wu, May 2020</em></p>
<p>Types are a very fundamental concept to Standard ML (SML), and indeed, to functional programming in general. Most programming languages have some notion of type, with <code>int</code>, <code>float</code>, and data structures such as <code>array</code> being common examples, however they tend to be weakly enforced, only being verified at runtime. In SML, we employ a system of <em>strong typing</em> consisting of stricter typing rules — which allows us to catch errors earlier in program execution — at compile time.</p>
<h2 id="type-safety"><a class="header" href="#type-safety">Type Safety</a></h2>
<p>Oftentimes, data is separated into types so that we can differentiate different kinds of data from each other. For instance, it makes no sense to add a <code>string</code> and an <code>int</code>, though certain programming languages will try to make sense of it. Usually, when different data types are haphazardly intermingled, it is because someone wrote a bug. The philosophy behind SML's type system is to disallow such intermingling. In SML, every expression and every function has a specified type, which governs what interactions are possible with other expressions.</p>
<p>Consider the following code fragment in Python:</p>
<pre><code class="language-python">def foo(x):
    if x == 2:
        return 1
    elif x == &quot;bar&quot;:
        return True
    return None
</code></pre>
<p>What is the type of its output? The answer is &quot;it depends&quot;, as it is dependent on the value of <code>x</code> that is passed in. We could give <code>foo</code> any type of argument, and we can see that in the cases that we pass in <code>2</code> or <code>&quot;bar&quot;</code>, we could obtain an <code>int</code> or a <code>bool</code> as output, or even a <code>None</code> in any other case.</p>
<p>Consider the expression <code>foo(y) + 3</code>. Is it safe to evaluate? Again, the answer depends on what the value of <code>y</code> is, but we see the same answer of &quot;it depends&quot;. In some cases, depending on what the program has done up to this point, it may be safe; this is in the case where <code>y</code> is <code>2</code>, in which case <code>foo(y) + 3</code> would just be <code>4</code>. But if it wasn't, we may end up trying to add <code>True</code> or <code>None</code> to <code>3</code>, which clearly doesn't make sense. If we tried to add <code>None</code> to <code>3</code> we would encounter a <em>type error</em>. While a contrived piece of code, type errors such as this spring up in code all the time. Type errors are unsafe. Whoever wrote this program likely didn't intend to try and add a non-<code>int</code> to <code>3</code>, but it can be tricky to reason about whether or not such an outcome is truly possible.</p>
<p>In SML, our philosophy will be to make such uncertainties impossible. We impose a certain degree of <em>determinism</em> on our programs, such that the types of each expression and each step of evaluation throughout our program have a definite type that is known to the program. If a program tries to execute some computation that would use the wrong type somewhere, or otherwise cause types to mismatch, then we would call the program <em>ill-typed</em> or <em>not well-typed</em>, and it would be rejected before any evaluation. This process of verifying types is called <em>type-checking</em>, and occurs at <em>compile-time</em>, which stands opposed to <em>run-time</em>. Compile-time type-checking happens before any actual evaluation — before the program's run-time — and only upon passing the type-checking phase will the program actually execute. At this point, we say the program <em>type-checks</em>.</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type-Checking</a></h2>
<p>The most fundamental rule for type-checking is during <em>function application</em>, or the act of <em>applying</em> a function to its arguments. This is elaborated on further in the chapter on functions.</p>
<blockquote>
<p><strong>[APP]</strong> An expression <code>e1 e2</code> has type <code>t2</code> if and only if <code>e1 : t1 -&gt; t2</code> and <code>e2 : t1</code>.</p>
</blockquote>
<p>More specifically, for a function <code>f : t1 -&gt; t2</code>, if <code>x : t3</code> where <code>t3</code> is not the same type as <code>t1</code>, then the expression <code>f x</code> is not well-typed and therefore has no value. In other words, applying a function to an argument that does not match its argument type does not type-check — because doing that creates a type error — which will prompt the compiler to reject the program at compile-time during the type-checking process. We call an expression that does not encounter a type error <em>well-typed</em>. A program that passes the type-checking process is one that type-checks.</p>
<p>The majority of type errors will occur as a consequence of this rule. Since functions have definite return types, it is very straightforward to check if a program type-checks or not: simply evaluate the <em>types</em> of the expressions and see if any type errors are encountered. The type-checking phase is agnostic to the specific values of well-typed expressions. When given an expression — such as <code>1 + 2</code> — the compiler sees two expressions of type <code>int</code> being passed into a function of type <code>int * int -&gt; int</code> and knows that the result must be of type <code>int</code> — thus the entire expression <code>1 + 2</code> is well-typed.</p>
<p>Because of this, the well-typedness of expressions is independent of any run-time errors that may occur. For instance, the expression <code>1 div 0</code> clearly cannot give back a value of type <code>int</code>, as division by 0 is undefined. Instead, <code>1 div 0</code> will raise the exception <code>Div</code> during execution and try to terminate the execution of the program. From the perspective of the compiler's type-checking process, it only cares that all arguments to <code>div</code> are of the right type — it only cares that the types match. The second argument of <code>div</code> being <code>0</code> still type-checks. So even though <code>1 div 0</code> will not evaluate to a value, it also will not encounter a type error; therefore the expression <code>1 div 0</code> is well-typed and has the type <code>int</code>.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>SML's strong type system is a very powerful tool for ensuring the correctness of programs. The philosophy behind Standard ML is to push errors to compile-time — before a program is even run. In doing so, we ensure that unexpected errors do not arise during run-time, long after we've already proven that our code is correct. With strong typing and type-checking, we can guarantee that our code will be free of type errors, eliminating those bugs from our code at run-time. Later in this section, we will discuss some concrete types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool"><a class="header" href="#bool">Bool</a></h1>
<p><em>By Jacob Neumann, May 2020</em></p>
<p><code>bool</code> is the SML type of booleans. The <code>bool</code> type supports the usual constructs of boolean logic and &quot;conditionals&quot; (<code>if</code> expressions). <code>bool</code> is also the type produced when evaluating (in)equality between values of (suitable) types. </p>
<h2 id="values"><a class="header" href="#values">Values</a></h2>
<p>There are exactly two values of type <code>bool</code>, <code>true</code> and <code>false</code>.</p>
<pre><code class="language-sml">datatype bool = true | false
</code></pre>
<p>In addition to the constructs generally available in pattern matching (e.g. wildcards and identifier binding), booleans can be pattern-matched against using the constructors <code>true</code> and <code>false</code>.</p>
<pre><code class="language-sml">fun firstOrSecond ((x : int,y : int), true):int = x
  | firstOrSecond ((x,y), false) = y

val 2 = firstOrSecond((3,2),false)
</code></pre>
<p><code>bool</code> is pretty-printed by the <code>smlnj</code> REPL, so the actual values will display. This is demonstrated by the following <code>smlnj</code> REPL snippet.</p>
<pre><code class="language-sml">- val b = true orelse false;
val b = true : bool
</code></pre>
<h2 id="production"><a class="header" href="#production">Production</a></h2>
<p>Some common functions which produce booleans:</p>
<pre><code class="language-sml">(op =)  : ''a * ''a -&gt; bool
(op &lt;&gt;) : ''a * ''a -&gt; bool  (* Inequality *)

(* All of the following are overloaded and also work on values of type real *)
(op &lt;)  : int * int -&gt; bool
(op &gt;)  : int * int -&gt; bool
(op &lt;=) : int * int -&gt; bool
(op &gt;=) : int * int -&gt; bool
</code></pre>
<h2 id="elimination"><a class="header" href="#elimination">Elimination</a></h2>
<p>The principal use of booleans is for evaluating one of two possible expressions, conditional on a value of type <code>bool</code>:</p>
<pre><code class="language-sml">(* Evaluates to 5 *)
val res1 = if true then 5 else 2

(* Evaluates to 7 *)
val res2 = if false then 3+3 else 7
</code></pre>
<p>Note that the expression between <code>then</code> and <code>else</code> (the &quot;then branch&quot;) has the same type as the expression after the <code>else</code> (the &quot;else branch&quot;). This is necessary: the SML typechecker does not evaluate expressions, and so does not &quot;know&quot; that, for instance, <code>if false then e1 else e2</code> will always reduce to <code>e2</code>. As far as the typechecker knows, <code>if false then e1 else e2</code> could reduce to <code>e1</code>. So, in order for the typechecker to be able to assign a type to the expression <code>if false then e1 else e2</code>, it must be the case that <code>e1</code> and <code>e2</code> have the same type. More formally, </p>
<blockquote>
<p>[If-Then]  An expression <code>if b then e1 else e2</code> is well-typed (with type <code>t</code>) 
if and only if 
<code>b : bool</code> and <code>e1 : t</code> and <code>e2 : t</code>.</p>
</blockquote>
<p>It is worth noting that <code>if b then e1 else e2</code> is equivalent to the following expression, written using SML's <code>case</code> syntax.</p>
<pre><code class="language-sml">    case b of
      true =&gt; e1
    | false =&gt; e2
</code></pre>
<p>Which is also equivalent to</p>
<pre><code class="language-sml">    (fn true =&gt; e1 | false =&gt; e2) b
</code></pre>
<p><strong>NOTE:</strong> It's important to note that, in the evaluation of the expression <code>if true then e1 else e2</code>, the expression <code>e2</code> is <em>never</em> evaluated (and, analogously, <code>e1</code> never is evaluated in <code>if false then e1 else e2</code>). This is most evident when we look at the third syntax (with the lambda function): SML does not evaluate the body of a function <em>until the function is called</em>. So when <code>(fn true =&gt; e1 | false =&gt; e2)</code> gets applied to, say, <code>true</code>, then the evaluation steps immediately to <code>e1</code>, without ever evaluating <code>e2</code>. This point is explored more in a question below.</p>
<h2 id="combination"><a class="header" href="#combination">Combination</a></h2>
<p><code>bool</code> is an equality type, and may therefore be compared with <code>=</code>, producing another <code>bool</code>.</p>
<pre><code class="language-sml">val true = (true = true)
val false = (true = false)
val false = (false &lt;&gt; false)
</code></pre>
<p><code>bool</code> also comes equipped with the usual boolean operators,</p>
<pre><code class="language-sml">val true = true andalso true   (* andalso keyword, logical and *)
val true = false orelse true   (* orelse keyword, logical or *)
val false = not true           (* not:bool -&gt; bool, logical negation *)
</code></pre>
<p>An important note about <code>andalso</code> and <code>orelse</code>: the evaluation of <code>b1 andalso b2</code> has a behavior known as <em>short-circuiting</em>:<sup>[1]</sup> when evaluating this expression, SML will first attempt to evaluate <code>b1</code>. If <code>b1</code> raises an exception or loops behavior, then that will be the behavior of <code>b1 andalso b2</code> as a whole. If <code>b1</code> reduces down to the value <code>true</code>, then SML will then attempt to evaluate <code>b2</code>. However, if <code>b1</code> evaluates to the value <code>false</code>, then SML will <em>not evaluate <code>b2</code></em>. This is exhibited in the following code snippet.</p>
<pre><code class="language-sml">(* loops forever on any input *)
fun loop (x:int):bool = loop x

(* Evaluates to the value false, and doesn't loop *)
val false = false andalso (loop 3)
</code></pre>
<h2 id="from-the-structure"><a class="header" href="#from-the-structure">From the Structure</a></h2>
<p>The structure <code>Bool</code> is bound as part of the SML Basis. In addition to what's already been mentioned, it includes the utility function</p>
<pre><code class="language-sml">	Bool.toString : bool -&gt; string
</code></pre>
<p>This is useful (for instance) for print-debugging the value of a <code>bool</code>-valued variable.</p>
<h2 id="questions-to-consider"><a class="header" href="#questions-to-consider">Questions to Consider</a></h2>
<ol>
<li>Why are the following expressions <em>not</em> equivalent?</li>
</ol>
<pre><code class="language-sml">    (if b then e1 else e2)

    (fn (x,y) =&gt; if b then x else y) (e1,e2)
</code></pre>
<ol start="2">
<li>Why are the following expressions <em>not</em> equivalent?</li>
</ol>
<pre><code class="language-sml">    b1 andalso b2

    (fn (v1,v2) =&gt; v1 andalso v2) (b1,b2)
</code></pre>
<h4 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h4>
<p>[1]: This is why <code>andalso</code> and <code>orelse</code> are designated as <em>keywords</em> above: they are <em>not</em> infixed functions of type <code>bool*bool-&gt;bool</code>. Functions cannot exhibit this kind of &quot;shortcircuiting&quot; (evaluating one of their arguments and then deciding whether to evaluate the other): the integer addition <code>(op +) : int*int -&gt; int</code> must have both of its arguments fully evaluated before proceeding to add them. The keywords <code>andalso</code> and <code>orelse</code> must be built-in to the SML evaluator to achieve shortcircuiting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int"><a class="header" href="#int">Int</a></h1>
<p><em>By Brandon Wu, May 2020</em></p>
<p><code>int</code> is the SML type of integers.</p>
<h2 id="values-1"><a class="header" href="#values-1">Values</a></h2>
<p>The underlying representation of integers can be likened to the following:</p>
<pre><code class="language-sml">datatype int = ... | ~2 | ~1 | 0 | 1 | 2 | ...
</code></pre>
<p>This signifies that the type <code>int</code> is inhabited by infinitely many values, all corresponding to whole numbers. In particular, every integer forms its own <em>constant constructor</em> for the <code>int</code> type, meaning that they each individually can be pattern matched upon. Note that the use of <code>~</code> above denotes negativity. Additionally, <code>~</code> is a valid function of type <code>int -&gt; int</code> that negates a number.</p>
<p>While in practice, computers can only represent a finite number of integers, for the purposes of this class we will generally assume the integers to be unbounded. This means that we can do induction on SML integers in exactly the same way as we would do induction on the natural numbers, and that we do not have to worry about the consequences of edge case behavior. This allows us to ignore pedantic implementation details and explore mathematically interesting properties of programs.</p>
<h2 id="production-1"><a class="header" href="#production-1">Production</a></h2>
<p>Integers have all the familiar arithmetic operations available to them. Note that some of these functions are also overloaded to work with <code>real</code> types - this is further discussed in the Real page.</p>
<pre><code class="language-sml">(op +)   : int * int -&gt; int
(op -)   : int * int -&gt; int
(op *)   : int * int -&gt; int
(op div) : int * int -&gt; int
(op mod) : int * int -&gt; int
</code></pre>
<p>All of these functions are <em>infixed</em>, so instead of being applied as <code>+(2, 3)</code>, we write <code>2 + 3</code>. Additionally, <code>div</code> and <code>mod</code> are not defined when the second argument is 0, and will raise a <code>Div</code> exception.</p>
<h2 id="combination-1"><a class="header" href="#combination-1">Combination</a></h2>
<p>Integers are also eligible for comparison, including equality and inequality. (In other words, integers are an <em>equality type</em>).</p>
<pre><code class="language-sml">(op =)  : int * int -&gt; bool
(op &lt;&gt;) : int * int -&gt; bool (* Inequality *)

(op &lt;)  : int * int -&gt; bool
(op &gt;)  : int * int -&gt; bool
(op &lt;=) : int * int -&gt; bool
(op &gt;=) : int * int -&gt; bool
</code></pre>
<h2 id="from-the-structure-1"><a class="header" href="#from-the-structure-1">From the Structure</a></h2>
<p>The structure <code>Int</code> is bound as part of the SML Basis. It includes helpful functions such as</p>
<pre><code class="language-sml">Int.toString : int -&gt; string
Int.compare  : int * int -&gt; order
Int.min      : int * int -&gt; int
Int.max      : int * int -&gt; int
</code></pre>
<p>where <code>Int.toString</code> is the function that returns the string representation of a given integer, and <code>Int.compare</code> has return type <code>order</code>, which is inhabited only by values <code>LESS</code>, <code>EQUAL</code>, and <code>GREATER</code>. <code>Int.compare (x, y)</code> returns <code>LESS</code> only if x &lt; y, <code>EQUAL</code> if x = y, and <code>GREATER</code> if <code>x &gt; y</code>. Additionally, <code>Int.min</code> and <code>Int.max</code> are just the corresponding min and max functions for integers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real"><a class="header" href="#real">Real</a></h1>
<p><em>By Brandon Wu, May 2020</em></p>
<p><code>real</code> is the SML type of real or floating-point numbers. As in other programming languages, reals in SML are restricted to finite machine representations, which means that they cannot represent every real number with perfect precision. For this reason, generally in this course we will prefer the use of <code>int</code>s when performing numeric operations.</p>
<h2 id="values-2"><a class="header" href="#values-2">Values</a></h2>
<p>A real number is a sequence of numbers, followed by a decimal point, followed by another sequence of numbers. This includes examples such as <code>15.150</code>, <code>1.0</code>, and <code>3.14159</code>. Reals are noteworthy in that they are not <em>equality types</em>, which means that they cannot be compared for equality with the <code>=</code> operator. In addition, they cannot be pattern matched upon. This means that when designing programs with specific behavior based on equality with a specific real number, they should instead be written to operate within some <em>degree of precision</em> of the real number in question. For instance:</p>
<pre><code class="language-sml">val equalThreshold = 0.000001
fun isZero (x : real) : bool = Real.abs x &lt; equalThreshold
</code></pre>
<p>This function simply prespecifies a (small) range, within which a number can be considered to be &quot;equal&quot; to 0. It uses the function <code>Real.abs</code> to check if the real number in question is within that threshold of zero, in either direction. In this way, we can approximate some test for equality, up to some degree of acceptable precision.</p>
<h2 id="production-2"><a class="header" href="#production-2">Production</a></h2>
<p>Real numbers similarly have access to some of the basic arithmetic operations as integers. In particular, they have:</p>
<pre><code class="language-sml">(op +) : real * real -&gt; real
(op -) : real * real -&gt; real
(op *) : real * real -&gt; real
(op /) : real * real -&gt; real
</code></pre>
<p>Note that all but the last operator are also defined to work on <code>int</code> types. This may seem to violate type safety, however this is just an example of those functions being <em>overloaded</em>. There are two &quot;copies&quot; of, for instance, the <code>+</code> operator - one that has type <code>int * int -&gt; int</code> and one with type <code>real * real -&gt; real</code>. Notably, however, it only works on either both ints or both reals - it is not defined on both. As such, SML can infer from its arguments whether it should use the <code>int</code> or the <code>real</code> variant, and similarly for <code>-</code> and <code>*</code>. <code>div</code>, however, is only defined for integers - <code>/</code> is the counterpart for division on the real numbers.</p>
<h2 id="combination-2"><a class="header" href="#combination-2">Combination</a></h2>
<p>While not defined for equality, reals can still be compared to one another.</p>
<pre><code class="language-sml">(op &lt;)  : real * real -&gt; bool
(op &gt;)  : real * real -&gt; bool
(op &lt;=) : real * real -&gt; bool
(op &gt;=) : real * real -&gt; bool
</code></pre>
<p>These operations are similarly overloaded, and will also work on integers.</p>
<h2 id="from-the-structure-2"><a class="header" href="#from-the-structure-2">From the Structure</a></h2>
<p>The structure <code>Real</code> is bound as part of the SML Basis. It has access to a few useful functions, including:</p>
<pre><code class="language-sml">Real.toString : real -&gt; string
Real.compare  : real * real -&gt; order
Real.abs      : real -&gt; real
</code></pre>
<p>where <code>Real.toString</code> is the standard function that transforms a real number into its corresponding string representation, <code>Real.compare</code> on two reals returns <code>LESS</code>, <code>EQUAL</code>, or <code>GREATER</code> depending on their relative magnitudes, and <code>Real.abs</code> returns the absolute value of the real number in question.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<p><em>By Brandon Wu, May 2020</em></p>
<p><code>string</code> is the SML type of ordered collections of characters. </p>
<h2 id="values-3"><a class="header" href="#values-3">Values</a></h2>
<p>Any valid string literal is a value of type <code>string</code>. This means that examples such as <code>&quot;functional&quot;</code>, <code>&quot;15-150&quot;</code>, and <code>&quot;\n&quot;</code> are all valid strings, forming their own constant constructors that can thus be pattern matched upon.</p>
<pre><code class="language-sml">fun courseToNum (&quot;15-150&quot; : string) : int = 15150
  | courseToNum (&quot;15-151&quot; : string) : int = 15151
  | courseToNum (&quot;15-122&quot; : string) : int = 15122
</code></pre>
<h2 id="production-3"><a class="header" href="#production-3">Production</a></h2>
<p>Numerous types have their own <code>toString</code> functions that allow them to be easily converted to their string representations, including:</p>
<pre><code class="language-sml">Bool.toString : bool -&gt; string
Int.toString  : int -&gt; string
Real.toString : real -&gt; string
</code></pre>
<h2 id="combination-3"><a class="header" href="#combination-3">Combination</a></h2>
<p>Strings can be combined by means of the <code>^</code> operator, or &quot;concatenation&quot;. <code>^</code> takes two strings and joins them together, without creating any spaces. As such, if neither string contains spaces, then the resulting string will be attached directly. Specifically, the result of an operation such as <code>&quot;functional&quot; ^ &quot;programming&quot;</code> will be <code>&quot;functionalprogramming&quot;</code>.</p>
<pre><code class="language-sml">(op ^) : string * string -&gt; string
</code></pre>
<h2 id="from-the-structure-3"><a class="header" href="#from-the-structure-3">From the Structure</a></h2>
<p>The structure <code>String</code> is bound as part of the SML Basis. It contains several useful functions for dealing with strings, such as:</p>
<pre><code class="language-sml">String.explode : string -&gt; char list
String.implode : char list -&gt; string
</code></pre>
<p><code>String.explode</code> takes a string and converts it to a list of its constituent characters, in order as they appear in the string. <code>String.implode</code> is the opposite, taking in a list of characters and joining them to form a string. This means that:</p>
<pre><code class="language-sml">val [#&quot;1&quot;, #&quot;5&quot;, #&quot;1&quot;, #&quot;5&quot;, #&quot;0&quot;] = String.explode &quot;15150&quot;
val &quot;15150&quot; = String.implode [#&quot;1&quot;, #&quot;5&quot;, #&quot;1&quot;, #&quot;5&quot;, #&quot;0&quot;]
</code></pre>
<p>Note that the use of <code>#</code> is to denote that each element of the list is a <code>char</code> type, as opposed to a <code>string</code> of length 1.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p><em>By Brandon Wu, May 2020</em></p>
<p>Functions are a familiar concept in programming. In most languages, functions seem to capture a notion of a list of instructions to be carried out, with each invocation of the function resulting in another round of executing its instructions. In this class, however, we will take another perspective on functions - one that identifies the function more with the values that it outputs than the instructions that it executes.</p>
<h2 id="what-is-a-function"><a class="header" href="#what-is-a-function">What is a Function?</a></h2>
<p>What is a function? To most seasoned programmers, the definition given in the above section seems to be the most obvious. A function (or subroutine) is simply identified with the instructions that it executes, which have some <em>effect</em> on the state of the program as a whole, such as incrementing some variable, or setting some flag. </p>
<p>Before most programmers were programmers, however, they had a different notion of a function. To a mathematician, a function is something else entirely. Instead of being an algorithmic sequence of instructions, a function is simply an entity that maps inputs to outputs - for example, (f(x) = x + 1). Something rather notable is that mathematical functions are <em>pure</em> - given the same input, they always return the same output. So while it is a valid question in programming to ask how a function's behavior changes over time, this is a nonsensical question in terms of mathematical functions.</p>
<p>To be more concrete, let us consider a Python program.</p>
<pre><code class="language-python">x = 0
def f(y):
    x += 1
    return x + y
</code></pre>
<p>This program instantiates a variable <code>x</code> outside the scope of the function <code>f</code> (which takes a single argument <code>y</code>), and the behavior of <code>f</code> is to increment the value of <code>x</code>, then return the sum of <code>x</code> and <code>y</code>. What we would find is that the first time that we run <code>f(0)</code>, for instance, we obtain <code>1</code>. The second time that we run <code>f(0)</code>, it will return <code>2</code>, and so on and so forth. We cannot even say that <code>f(0) = f(0)</code>! The output behavior of this function changes every time that it is run. This makes it difficult to reason about the function - in order to do so, we must know the number of times that it has been called before, at a given step in the program. While this is a fairly tame example, this problem only compounds with more complicated functions.</p>
<p>Clearly, this function is <em>impure</em>. Can we do better?</p>
<h2 id="function-types-and-function-application"><a class="header" href="#function-types-and-function-application">Function Types and Function Application</a></h2>
<p>So far we have seen basic types such as <code>int</code> and <code>string</code>, among others. Functions allow us to compose types in new ways.</p>
<p>In SML, we denote the type of a function that has input type <code>t1</code> and output type <code>t2</code> (for some arbitrary, fixed <code>t1</code> and <code>t2</code>) to be <code>t1 -&gt; t2</code>. By SML's strict typing rules, functions of type <code>t1 -&gt; t2</code> can <em>only</em> take in inputs of type <code>t1</code> and return outputs of type <code>t2</code>, for any types <code>t1</code> and <code>t2</code>. Additionally, we write <code>e1 e2</code> for the expression consisting of the function <code>e1</code> being given as input the expression <code>e2</code> (so we may write the mathematical function (f(x)) instead as <code>f x</code>).</p>
<blockquote>
<p><strong>[APP]</strong> An expression <code>e1 e2</code> has type <code>t2</code> if and only if <code>e1 : t1 -&gt; t2</code> and <code>e2 : t1</code>.</p>
</blockquote>
<p>We call the above rule [APP] since it concerns the types of expressions during <em>function application</em>, or the process of applying a function to an argument. </p>
<p>Note that a function must always have type <code>t1 -&gt; t2</code> (for some types <code>t1</code> and <code>t2</code>, though <code>t1</code> and <code>t2</code> may be complicated types in their own right). As such, all functions in SML can only take in <em>one</em> input - though the input type <code>t1</code> may be one that &quot;contains&quot; multiple values. For instance, a function may have type <code>int * int -&gt; bool</code>. For such a function, it takes in only <em>one</em> argument (a tuple containing two integers).</p>
<h2 id="functions-in-sml"><a class="header" href="#functions-in-sml">Functions in SML</a></h2>
<p>We can declare a function with the <code>fun</code> keyword.</p>
<pre><code class="language-sml">fun fact (0 : int) : int = 1
  | fact (n : int) : int = n * fact (n - 1)
</code></pre>
<p>The above example serves to initialize a function that computes the factorial function, and then bind it to the identifier <code>fact</code>. Function declarations create a <em>closure</em> which includes all bound variables in the scope of the function when it was declared, so the behavior of <code>fact</code> will always be as if it was in the same environment as when it was first declared. As such, we can also declare functions such as:</p>
<pre><code class="language-sml">val x = 1
fun addX (n : int) : int = n + x
val x = 2
</code></pre>
<p>When <code>addX</code> is bound, it is bound in a closure that includes the binding of the value <code>1</code> to the identifier <code>x</code> (we may denote this as <code>[1/x]</code>). As such, even though the body of <code>addX</code> refers to the identifier <code>x</code>, it is not affected by the later re-binding of the value of <code>x</code>, since it only matters what the value of <code>x</code> was when <code>addX</code> was first bound. Seen in this way, then, reasoning about functions which use bound variables is very intuitive - you simply have to look up for the most recent time that that variable was bound.</p>
<p>We also can use <em>anonymous lambda expressions</em> to bind functions. These are denoted by the <code>fn</code> keyword, and are called lambda expressions for historical reasons having to do with a model of computation called the <em>lambda calculus</em>. For instance, we can declare:</p>
<pre><code class="language-sml">val addOne : int -&gt; int = fn x =&gt; x + 1
</code></pre>
<p>Lambda expressions can also be <em>multi-clausal</em>, by pattern matching to multiple different clauses. For instance, we can define the following function, which simply returns true when given 0 and 1, and false otherwise.</p>
<pre><code class="language-sml">val isBinary : int -&gt; bool = fn 0 =&gt; true | 1 =&gt; true | _ =&gt; false
</code></pre>
<p>Note that the right hand side of this declaration is an expression in its own right, and can be used independently of just being bound. The above binding simply binds the anonymous lambda expression (which simply increments an integer) to the identifier <code>addOne</code>. We could also do the following binding:</p>
<pre><code class="language-sml">val two : int = (fn x =&gt; x + 1) 1
</code></pre>
<p>where we bind the result of evaluating the expression <code>(fn x =&gt; x + 1) 1</code> to the identifier <code>two</code>. Clearly, this expression evaluates to <code>2</code>, as <code>1</code> is substituted in for the local variable <code>x</code>, and then simply summed with <code>1</code>. </p>
<p><strong>NOTE:</strong> <code>fun</code> and <code>fn</code> differ in that functions declared with <code>fun</code> can be recursive, whereas val bindings using <code>fn</code> <em>cannot</em>. As such, while we can define the function <code>fact</code> as we did above, using <code>fun</code>, the following code <em>does not</em> work:</p>
<pre><code class="language-sml">(* DOES NOT WORK *)
val fact : int -&gt; int = fn 0 =&gt; 1 | n =&gt; n * fact (n - 1)
</code></pre>
<p>We will explore later on in the course what lambda expressions are useful for. In the meantime, usage of <code>fun</code> is sufficient to declare any functions that you may need.</p>
<p>It is also important to note that SML is an <em>eager</em> language, or <em>call-by-value</em>. This means that functions evaluate their arguments before stepping into their function bodies. This is explored more in the article on evaluation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">List</a></h1>
<p><em>By Brandon Wu, May 2020</em></p>
<p>Lists are the SML type of ordered collections of objects. Notably, you can create lists of any kind of object, so <code>int list</code>, <code>string list</code>, and <code>bool list</code> are all valid types. <code>list</code> on its own is a type constructor (meaning that it makes new types out of old types), so it is not a valid type by itself, however. Lists are not, however, the same as arrays - they do not have constant-time access to any given index of the list. Indeed, they are best thought of as not analogous to arrays in other languages at all. Instead, you only have access to the elements located at the very beginning of the list, the <em>head</em>. Additionally, lists are more <em>restricted</em> than data structures in some other languages - a given list has a fixed type for its elements. All of the elements in a list must be of the same type. For the purposes of this document, we will discuss only int lists.</p>
<h2 id="values-4"><a class="header" href="#values-4">Values</a></h2>
<p>We write lists as a sequence of integers, separated by commas, all enclosed with two square brackets. So then we have valid int lists as <code>[1, 2, 3]</code>, <code>[1, 5, 1, 5, 0]</code>, and <code>[]</code>, with the latter representing the empty list. We also refer to the empty list as <em>nil</em> (in addition, you can type <code>nil</code> instead of <code>[]</code> in code). </p>
<p>The other essential component to lists is what is known as the <code>::</code> operator, referred to as &quot;cons&quot;. Cons can be used as a constructor for any fixed type of list, so we say that for any given type <code>t</code>:</p>
<pre><code class="language-sml">(op ::) : t * t list -&gt; t list
</code></pre>
<p>Cons takes in a value <code>v</code> of type <code>t</code> and <code>t list</code>, and prepends <code>v</code> to the front of the given list. For ints in particular, we have that <code>1 :: [2, 3]</code> steps to <code>[1, 2, 3]</code>. Additionally, cons is <em>right-associative</em>. This means that in a continuous stream of applications of cons, they are evaluated from <em>right-to-left</em>. This means that <code>1 :: 2 :: 3 :: []</code> is implicitly denoting <code>1 :: (2 :: (3 :: []))</code>, as the calls to cons associate to the right. So, similarly to before, a <code>1 :: [2, 3]</code>, <code>[1, 2, 3]</code>, and <code>1 :: 2 :: 3 :: []</code> are exactly equivalent, and denote the same list.</p>
<p>Cons is also a <em>constructor</em>, meaning that it can be used to pattern match and deconstruct lists. As such, we can write basic functions to compute the length of a list as follows:</p>
<pre><code class="language-sml">(* length : int list -&gt; int *)
(* REQUIRES: true *)
(* ENSURES: length L ==&gt; the length of L *)
fun length ([] : int list) : int = 0
  | length (x::xs : int list) : int = 1 + length xs
</code></pre>
<p>Given a non-empty list, this function simply binds the first element of the list to the identifier <code>x</code>, discards it, and then recursively calls <code>length</code> to find the length of the remaining list <code>xs</code>, adding 1 to the result.</p>
<p>The definition of an int list thus corresponds to:</p>
<pre><code class="language-sml">datatype int list = [] | :: of int * int list
</code></pre>
<p>where an int list can either be the empty list <code>[]</code>, or it can be <code>::</code> of a first element and the rest of the list (where <code>::</code> is an infix operator, so instead of being written as <code>::(x, xs)</code>, we have <code>x :: xs</code>). Note that this is not actually valid syntax, but you can think of the definition of int lists in this way.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Compared to other data structures, lists seem to have numerous disadvantages. As mentioned previously, they do not possess constant-time indexing like arrays in other languages - there is no way to instantly get the ith element of a list easily. Instead, you must &quot;cons off&quot; all the elements in front of that item in order to retrieve it - if you want to remove that item from the list, then you have to put the preceding elements <em>back</em> as well (and in the right order!). Lists are also inherently sequential - you cannot access multiple elements at one time. </p>
<p>The reason why we choose lists is that they have very nice mathematical properties. These &quot;disadvantages&quot; in the previous paragraph become strengths, when viewed in a certain manner. Lists are powerful for their simple, inductive definition (as shown in the previous section), which is sufficiently powerful to characterize many important principles in this class. Additionally, they are <em>persistent</em>, meaning that they cannot be mutated - any change to a list simply creates a new one instead, which is a very desirable property to have in functional programs. Though the interfacing behavior with these lists is limited, we will write programs where this limitation matters less. Our hope is that, throughout this course, you can begin to see that there is an elegance in simplicity.</p>
<blockquote>
<p><strong>[Case Study: Sorted Lists]</strong></p>
<p>Sorting is an important principle in computer science. Whether it's binary search trees or cataloguing data, sorting is a very prevalent concept when it comes to making algorithms more efficient. It's not always the most easy to reason about, however - how would you be able to formally prove that a sorting algorithm works? In this regard, lists turn out to have some very nice properties.</p>
<blockquote>
<p><strong>Definition : Sorted Int Lists</strong></p>
<ol>
<li><code>[] : int list</code> is sorted.</li>
<li>The singleton int list is sorted.</li>
<li>If <code>L : int list</code> is sorted, then if <code>x : int</code> is less than or equal to the first element of <code>L</code>, then <code>x :: L</code> is sorted.</li>
</ol>
</blockquote>
<p>This definition is naturally inductive, and follows very easily from the definition of sorting. In addition, it goes hand-in-hand with how we define lists - building them up from smaller parts one-by-one. Seen in this way, reasoning about and proving whether a list is sorted becomes very easy.</p>
</blockquote>
<h2 id="combination-4"><a class="header" href="#combination-4">Combination</a></h2>
<p>We have seen that cons is essential for constructing lists, and for deconstructing the constituent elements that comprise a given list. What about when dealing with multiple lists? We might want to <em>combine</em> the elements from several lists at once. A standard function for doing so is called the <code>@</code> operator, or &quot;append&quot;.</p>
<pre><code class="language-sml">infix @
fun ([] : int list) @ (R : int list) : int list = R
  | (l::ls : int list) @ (R : int list) : int list = l :: (ls @ R)
</code></pre>
<p>(Note that this is valid syntax to declare an infix function <code>@</code>, it just looks a little different than what we've seen thus far. In this case, we put the function name <em>between</em> the arguments).</p>
<p>This function essentially just takes off all the elements from the left list, then begins to add them back onto the right list. It is also infix, which means that the result of <code>[1, 2] @ [3, 4]</code> is <code>[1, 2, 3, 4]</code>, and in the function's code, <code>ls @ R</code> just means the resulting list from appending <code>ls</code> to <code>R</code>.</p>
<h2 id="questions-to-consider-1"><a class="header" href="#questions-to-consider-1">Questions to Consider</a></h2>
<ol>
<li>
<p>In the code above, why does <code>@</code> not reverse the left list?</p>
</li>
<li>
<p>How might you inductively define a list whose elements all satisfy some property <em>P</em>?</p>
</li>
<li>
<p>Write an SML function that reverses a list. </p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<p><em>By Jacob Neumann, June 2021</em></p>
<p><code>option</code> is a SML datatype for handling potential undefined values. Formally, the option type is parametrized by a single polymorphic type variable, so for every SML type <code>t</code>, there is a type <code>t option</code>. </p>
<p>The type <code>t option</code> represents the construction of &quot;either a value of <code>t</code>, or nothing&quot;. For instance, a value of type <code>bool option</code> is either true, false, or neither. A value of type <code>int option</code> is either some integer, or none. A function will return <code>t option</code> to represent the possibility that no acceptable value of type <code>t</code> can be identified to return, and have a value to return to signal this circumstance. See the &quot;Options-as-partiality&quot; HOFs section below for some functions elaborating on this understanding of options. </p>
<p>Options also function as a kind of &quot;container&quot;: a value <code>x : t option</code> either &quot;contains&quot; a value of type <code>t</code> (<code>x = SOME(z)</code>) or is an &quot;empty container&quot; with no values (<code>x = NONE</code>). We can therefore view <code>t option</code> as a degenerate version of <code>t list</code>, where the &quot;list&quot; is constrained to be length at most one. The notion of a &quot;container&quot; is made precise in functional programming with the idea of a &quot;monad&quot;. In Haskell (which makes much more explicit use of monads), options are known as the &quot;Maybe monad&quot;.</p>
<h2 id="values-5"><a class="header" href="#values-5">Values</a></h2>
<p>The type <code>t option</code> has exactly one more value than the type <code>t</code> itself. Formally,</p>
<pre><code class="language-sml">datatype 'a option = NONE | SOME of 'a
</code></pre>
<p>So for each value <code>v : t</code>, <code>SOME(v) : t option</code>. And <code>NONE</code> is a value of type <code>t option</code> for each type <code>t</code>, as required by the surrounding context. Options can be nested, e.g. <code>SOME(SOME(3)) : int option option</code>.</p>
<p><code>SOME</code> and <code>NONE</code> are the two constructors of the <code>t option</code> type, so, in addition to the constructs generally available in pattern matching (e.g. wildcards and identifier binding), we can pattern match against <code>SOME</code> and <code>NONE</code>.</p>
<pre><code class="language-sml">fun defaultToThree (NONE : int option):int = 3
  | defaultToThree (SOME x) = x

val 2 = defaultToThree(SOME 2)
val 3 = defaultToThree(NONE)

fun searchForEven [] = NONE
  | searchForEven (x::xs) = if (x mod 2)=0 then SOME(x) else searchForEven xs

val (SOME _) = searchForEven [1,2,3,4]
val NONE = searchForEven [1,3,5]
</code></pre>
<p>If <code>t</code> is pretty-printed by the <code>smlnj</code> REPL (like <code>int</code>,<code>bool</code>,<code>string list</code>, etc.), so too is <code>t option</code>. This is demonstrated by the following <code>smlnj</code> REPL snippet.</p>
<pre><code class="language-sml">- val k = SOME(SOME 5);
val k = SOME (SOME 5) : int option option
</code></pre>
<h2 id="production-4"><a class="header" href="#production-4">Production</a></h2>
<p>There are some basic SML functions which produce <code>option</code>s:</p>
<pre><code class="language-sml">    Int.fromString : string -&gt; int option
    Bool.fromString : string -&gt; bool option
</code></pre>
<p>Both of these functions are partial inverses to their respective <code>toString</code> functions (e.g. <code>Int.fromString(Int.toString(7)) == SOME 7</code>), but return an option so they can return <code>NONE</code> on strings which do not encode an <code>int</code> or <code>bool</code>, respectively.</p>
<h2 id="elimination-1"><a class="header" href="#elimination-1">Elimination</a></h2>
<p>Another option for casing on options is the function (provided in the <code>Option</code> structure - see below)</p>
<pre><code class="language-sml">    Option.getOpt : 'a option * 'a -&gt; 'a
</code></pre>
<p>which behaves as follows: <code>Option.getOpt(SOME x,y)</code> will evaluate to <code>x</code>, and <code>Option.getOpt(NONE,y)</code> will evaluate to <code>y</code>. When writing functions operating on options, it is still generally preferable that you use clausal pattern matching to break into the &quot;<code>SOME</code> case&quot; and &quot;<code>NONE</code> case&quot;, but there are situations where <code>Option.getOpt</code> is an elegant solution.</p>
<p>The <code>Option</code> structure also provides the &quot;join&quot; function</p>
<pre><code class="language-sml">    Option.join : 'a option option -&gt; 'a option
</code></pre>
<p>which sends <code>SOME(X)</code> to <code>X</code> and <code>NONE</code> to <code>NONE</code>. </p>
<h2 id="from-the-structure-4"><a class="header" href="#from-the-structure-4">From the Structure</a></h2>
<p>The <code>Option</code> structure (part of the SMLNJ basis) provides a number of useful utilities for working with <code>option</code>s.</p>
<p>In addition to the datatype <code>option</code> itself being available at top-level, the exception</p>
<pre><code class="language-sml">    exception Option
</code></pre>
<p>is available at top-level as well.</p>
<h3 id="basic-functions"><a class="header" href="#basic-functions">Basic Functions</a></h3>
<p>The <code>Option</code> structure provides <code>bool</code>ean-valued functions for detecting whether a given option value is <code>NONE</code> or <code>SOME</code>, and for extracting values from <code>SOME</code>.</p>
<pre><code class="language-sml">    Option.isSome : 'a option -&gt; bool
    Option.isNone : 'a option -&gt; bool
    Option.valOf : 'a option -&gt; 'a
</code></pre>
<p><code>Option.valOf NONE</code> raises the exception <code>Option</code>. <strong>NOTE:</strong> Do <em>not</em> use these fuctions in place of pattern-matching on an option value. Expressions like <code>if Option.isSome(X) then Option.valOf(X) else e2</code> are bad style.</p>
<h3 id="options-as-containers-hofs"><a class="header" href="#options-as-containers-hofs">&quot;Options-as-containers&quot; HOFs</a></h3>
<p>Options are an instance of a more general structure in functional programming known as a <em>monad</em>. Accordingly, there are a number of higher-order functions which we can define on options. In particular, <code>option</code> comes equipped with a <em>map</em> operation:</p>
<pre><code class="language-sml">    Option.map : ('a -&gt; 'b) -&gt; 'a option -&gt; 'b option
</code></pre>
<p>which does what you might expect, given its type: <code>Option.map f (SOME x)</code> evaluates to <code>SOME(f(x))</code>, and <code>Option.map f NONE</code> produces <code>NONE</code>. As usual with &quot;map&quot; functions, we generally require <code>f</code> to be total.</p>
<p>Options, as a &quot;container&quot; of data, also admit a <em>filtering</em> operation:</p>
<pre><code class="language-sml">    Option.filter : ('a -&gt; bool) -&gt; 'a option -&gt; 'a option
</code></pre>
<p>Which is implemented as</p>
<pre><code class="language-sml">fun filter p = fn NONE =&gt; NONE | (SOME x) =&gt; if p(x) then SOME x else NONE
</code></pre>
<p>i.e. it &quot;filters&quot; out the value <code>x</code> if <code>x</code> does not &quot;satisfy&quot; <code>p</code> (<code>p(x) == false</code>). As usual with &quot;filter&quot; functions, we generally require <code>p</code> to be total.</p>
<p>The <code>Option</code> structure also provides a utility for &quot;folding&quot; an option:</p>
<pre><code class="language-sml">    Option.fold : ('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a option -&gt; 'b
</code></pre>
<p>which we might implement as</p>
<pre><code class="language-sml">fun fold g z NONE = z
  | fold g z (SOME x) = g(x,z)
</code></pre>
<p>We often assume that <code>g</code> is total. In certain situations, we also want the two arguments of <code>g</code> to be the same type, and might assume that <code>g</code> is &quot;associative&quot; (in the sense that <code>g(x,g(y,z)) == g(g(x,y),z)</code> for all <code>x,y,z</code>) or that <code>z</code> is a &quot;unit&quot; for <code>g</code> (i.e. <code>g(x,z) == x == g(z,x)</code> for all <code>x</code>).</p>
<h3 id="options-as-partiality-hofs"><a class="header" href="#options-as-partiality-hofs">&quot;Options-as-partiality&quot; HOFs</a></h3>
<p>As mentioned above, options provide a way to represent partial functions: a function <code>f : t1 -&gt; t2 option</code> can be thought of as a function which is defined on some inputs (<code>f(x) == SOME(z)</code>) and not on others (<code>f(y) == NONE</code>). The <code>Option</code> structure provides several utilities consistent with this interpretation. First is composition of these &quot;partial functions&quot;.</p>
<pre><code class="language-sml">    Option.compose : ('a -&gt; 'c) -&gt; ('b -&gt; 'a option) -&gt; 'b -&gt; 'c option
    Option.composePartial : ('a -&gt; 'c option) -&gt; ('b -&gt; 'a option) -&gt; 'b -&gt; 'c option
</code></pre>
<p>So <code>(Option.compose (g,f))(x)</code> will return <code>NONE</code> if <code>f(x) == NONE</code>, and will return <code>SOME(g(y))</code> if <code>f(x) == SOME(y)</code>. <code>Option.composePartial</code> will behave similarly, except it will return <code>g(y)</code> in the <code>f(x) == SOME(y)</code> case, since <code>g</code> returns an option.</p>
<p>It also provides a &quot;partial&quot; version of its map function:</p>
<pre><code class="language-sml">    Option.mapPartial : ('a -&gt; 'b option) -&gt; 'a option -&gt; 'b option
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signatures"><a class="header" href="#signatures">Signatures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smlnj-basis-documentation"><a class="header" href="#smlnj-basis-documentation">SMLNJ Basis Documentation</a></h1>
<p><em>By Jacob Neumann, June 2021</em></p>
<p>This page collects some documentation of the SML Basis Library produced as part of the development of the <a href="https://github.com/smlhelp/aux-library">Auxiliary Library</a>. The documents linked below provide documentation of some (but definitely not all) of the SML Basis modules. Unless otherwise stated, the documentation is of the version of the basis implemented in SMLNJ v110.99.</p>
<p>This documentation is meant as a more accessible alternate to the more <a href="https://smlfamily.github.io/Basis/index.html">official documentation</a>. In places, it also includes explicit mathematical definitions, proofs by induction, asymptotic analyses, and evaluation traces.</p>
<h2 id="fn"><a class="header" href="#fn">Fn</a></h2>
<p>The <code>Fn</code> module provides basic combinators, including some of the fundamental operations in lambda calculus. This includes the composition operator, <code>o</code>, which is available at top-level.</p>
<p><a href="https://github.com/smlhelp/aux-library/blob/main/documentation/Fn.pdf">Documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auxiliary-library-documentation"><a class="header" href="#auxiliary-library-documentation">Auxiliary Library Documentation</a></h1>
<p><em>By Jacob Neumann, June 2021</em></p>
<p>This page collects the documentation of the <a href="https://github.com/smlhelp/aux-library">Auxiliary Library</a>. The purpose of this library &amp; its documentation is to serve as sample code, proofs, and worked examples for students learning functional programming and/or SML for the first time. Accordingly, this documentation also includes explicit mathematical definitions, proofs by induction, asymptotic analyses, and evaluation traces, as appropriate.</p>
<p>Unless otherwise stated, the documentation assumes SMLNJ v110.99. Some features (e.g. modifications of the pretty printer) might not work in other versions of SMLNJ.</p>
<p>All the documents &amp; code here should be considered &quot;work-in-progress&quot;. If you spot an error in either, you can report it <a href="https://forms.gle/yuyc17oBnT4JvG5h9">here</a>.</p>
<h2 id="trees"><a class="header" href="#trees">Trees</a></h2>
<p>Provides polymorphic binary trees in a structure <code>Tree</code>, with a couple basic methods for working with them. </p>
<p>In particular, this includes the functions <code>inord</code> and <code>foldr</code>, which are used in the <code>OrdTreeSet</code> functor (see <strong>Sets</strong> below) and critical to the associated representation independence result.</p>
<p><a href="https://raw.githubusercontent.com/smlhelp/aux-library/main/Tree.sml">Code</a></p>
<h2 id="timing"><a class="header" href="#timing">Timing</a></h2>
<p>The <code>Timing</code> module includes types for encoding years, months, days, times, time zones, etc., as well as numerous utilities for working with them. This module primarily serves as an extended example of how to use custom SML <code>datatypes</code> to encode data, and how to take advantage of pattern matching to write elegant code. This module includes some imperative features (achieved utilizing basis modules unique to SMLNJ), such as stopwatches, countdown timers, and functions which obtain the current time. </p>
<p><a href="https://raw.githubusercontent.com/smlhelp/aux-library/main/Timing.sml">Code</a></p>
<h2 id="permute"><a class="header" href="#permute">Permute</a></h2>
<p>The <code>Permute</code> module contains utilities for permutating and sorting lists. The functions in this module are polymorphic, and some of the sorting functions furthermore serve as examples of <em>currying</em>. </p>
<p><a href="https://github.com/smlhelp/aux-library/blob/main/documentation/permute.pdf">Documentation</a> -- <a href="https://raw.githubusercontent.com/smlhelp/aux-library/main/Permute.sml">Code</a></p>
<h2 id="cps-iterate"><a class="header" href="#cps-iterate">CPS Iterate</a></h2>
<p>The <code>CPSIterate</code> module allows for imperative-programming-esque loops, but defined entirely functionally and entirely in continuation passing style. </p>
<p><a href="https://github.com/smlhelp/aux-library/blob/main/documentation/cpsIterate.pdf">Documentation</a> -- <a href="https://raw.githubusercontent.com/smlhelp/aux-library/main/CPSIterate.sml">Code</a></p>
<h2 id="language"><a class="header" href="#language">Language</a></h2>
<p>The <code>Language</code> module provides combinators for working with &quot;languages&quot;: lists of values of some equality type <code>Sigma</code>. Connects to some of the classic theory of computation, as well as providing sufficient combinators to capture a fragment of the logic of regular expressions. Good showcase of Higher-Order Functions &amp; Combinators.</p>
<p><a href="https://github.com/smlhelp/aux-library/blob/main/documentation/language.pdf">Documentation</a> -- <a href="https://raw.githubusercontent.com/smlhelp/aux-library/main/Language.sml">Code</a></p>
<h2 id="regular-expressions"><a class="header" href="#regular-expressions">Regular Expressions</a></h2>
<p>The <code>Regexp</code> module implements regular expressions in Standard ML. Parametrizes over an &quot;alphabet&quot; (equality) type <code>Sigma</code>, and implements a type <code>''Sigma regexp</code> with a CPS/Exn-control-flow function <code>match</code> which performs regular expression matching. Includes a method for obtaining the <em>language</em> of a regular expression, implemented using the <code>Language</code> module (above).</p>
<p><strong>Requires:</strong> <code>Language.sml</code></p>
<p><a href="https://github.com/smlhelp/aux-library/blob/main/documentation/regexp.pdf">Documentation</a> -- <a href="https://raw.githubusercontent.com/smlhelp/aux-library/main/Regexp.sml">Code</a></p>
<h2 id="sets"><a class="header" href="#sets">Sets</a></h2>
<p>An implementation of sets in Standard ML. Includes <code>EQ</code> &amp; <code>ORD</code> typeclasses, the <code>SET</code> signature, and three implementations: <code>ListSet</code> (sets are unordered, duplicate free lists), <code>OrdListSet</code> (sorted, duplicate-free lists), and <code>OrdTreeSet</code> (sorted, duplicate-free trees). The latter two are equivalent (as proven by a representation independence proof), but the superior time bounds of <code>OrdTreeSet</code> are not realized unless we can maintain a balance invariant -- providing motivation for <em>red-black trees</em>.</p>
<p><strong>Requires:</strong> <code>Tree.sml</code></p>
<p><a href="https://raw.githubusercontent.com/smlhelp/aux-library/main/SET.sig">sig</a> -- <a href="https://raw.githubusercontent.com/smlhelp/aux-library/main/Set.sml">struct</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h1>
<p><em>By Eunice Chen, January 2021</em>. <em>Revised April 2022</em></p>
<p>In this section, we will explore some common mistakes and errors that may occur
when programming in Standard ML.</p>
<h2 id="casing-issues"><a class="header" href="#casing-issues">Casing Issues</a></h2>
<h3 id="match-nonexhaustive"><a class="header" href="#match-nonexhaustive">Match Nonexhaustive</a></h3>
<p>A Match Nonexhaustive warning occurs when your cases in a pattern matching expression, are, well, non-exhaustive. This means that
there is some case/combination of constructors, values, or other pattern that could appear as an input, but is not covered in your code.
A straightforward example would be a function like this:</p>
<pre><code class="language-sml">fun addList [] = 0
  | addList x::y::L = x + y + (addList L)
</code></pre>
<p>What would happen if we called <code>addList [5]</code>? We couldn't match on the first clause
because the list is non-empty, and we couldn't match on the second clause because
we only have one cons constructor (in particular <code>5::[]</code>). SML, understandably,
won't know what to do and will raise a nonexhaustive match exception and crash.</p>
<p>This can occur in other places besides function inputs. For example,
consider the following function:</p>
<pre><code class="language-sml">fun example x =
    case x of 
         5 =&gt; &quot;yay!&quot;
       | 6 =&gt; &quot;boo!&quot;
</code></pre>
<p>What would happen if we called <code>example 7</code>? Again, SML wouldn't know what to do (as 7 is not equal to 5 or 6) and would
again raise a nonexhaustive match error. That is to say, nonexhaustive match errors
can occur wherever you have some sort of pattern matched cases. In order to fix a match nonexhaustive
error, simply add the case(s) that you are missing.</p>
<h4 id="should-we-always-be-afraid-of-nonexhaustive-warnings"><a class="header" href="#should-we-always-be-afraid-of-nonexhaustive-warnings">Should we always be afraid of nonexhaustive warnings?</a></h4>
<p>It is ok to have a nonexhaustive
warning <em>if</em> you can prove that the nonexhaustive case will never occur.
An example of this is the following:</p>
<pre><code class="language-sml">fun NE_Match x =
  let
    val L = [1, 2]
  in
    case L of
         x::y::xs =&gt; &quot;at least two elements!&quot;
       | [] =&gt; &quot;empty!&quot;
  end
</code></pre>
<p>While this is certainly a contrived example, even though SML will warn us
of a nonexhaustive match, we have no reason to worry about it. As we can see, <code>L</code>
is bound to <code>[1, 2]</code> (which is equivalent to <code>1::2::[]</code>) and therefore will always match on the first case (it has at least two <code>cons</code> constructors).
This proves that <code>L</code> will always match to one of our patterns, and therefore will never raise 
a match nonexhaustive exception. Still, it is good style to cover all cases by using a wildcard (<code>_</code>).</p>
<h3 id="nested-cases"><a class="header" href="#nested-cases">Nested Cases</a></h3>
<p>When you nest case expressions within case expressions, it's good to wrap your case statements with parentheses. SML will continue to look for patterns to case on, so using parentheses will let it know when to &quot;stop&quot;.</p>
<p>For example, the following code will compile without warnings:</p>
<pre><code>case 0 of
     0 =&gt; (case &quot;x&quot; of _ =&gt; 3)
   | _ =&gt; 5
</code></pre>
<p>but this code will have a match redundant error and a match nonexhaustive error:</p>
<pre><code>case 0 of
     0 =&gt; case &quot;x&quot; of _ =&gt; 3
   | _ =&gt; 5
</code></pre>
<p>Obviously, this example is very contrived, but adding parens may help in nested case expressions.</p>
<h2 id="associativity-issues"><a class="header" href="#associativity-issues">Associativity Issues</a></h2>
<p>Since function application is left associative, making sure you have correct parenthesization is very important. It is almost always a good idea to double check your parenthesization in your code, since it can cause very confusing bugs, but can be fixed with a simple check.</p>
<p>For example, the following code will not compile:</p>
<pre><code>fun f [] = 0
  | f x::xs = 1
</code></pre>
<p>This fails to compile because function application is left-associative, so the SML compiler thinks that <code>x</code> is the only argument to the function <code>f</code>, and does not know how to parse the extra <code>::xs</code>. A fix for this issue would just to put parens around the <code>x::xs</code>, like so:</p>
<pre><code>fun f [] = 0
  | f (x::xs) = 1
</code></pre>
<p>Similarly, if some expression is an argument to another function, it is usually good to put parens around that expression. For example, suppose we had some functions <code>f</code> and <code>g</code> of type <code>int -&gt; int</code>, and we would like to apply the function <code>g</code> to the value <code>f 1</code>. Then, if we wrote <code>g f 1</code>, this would not typecheck, since function application is left-associative (writing <code>g f 1</code> would be the same thing as writing <code>((g f) 1)</code>). To fix this, we would write this as <code>g (f 1)</code> to fix the associativity issues.</p>
<h2 id="equality-type-warnings-ie-a-vs-a"><a class="header" href="#equality-type-warnings-ie-a-vs-a">Equality Type Warnings (i.e. <code>''a</code> vs <code>'a</code>)</a></h2>
<p>Sometimes, code will fail to typecheck because it expects something of type <code>'a</code> but instead gets something of type <code>''a</code> instead. A plain type variable like <code>'a</code> can be substituted with any type, but something like type <code>''a</code> (with two apostrophes in front) can only be substituted with an <em>equality</em> type. An <em>equality</em> type is a type that can use operators like <code>=</code> and <code>&lt;&gt;</code> to compare their values (<code>int</code>, <code>string</code>, and <code>bool</code> are good examples of equality types). Thus, if your code has an <code>''a</code> instead of an <code>a</code>, it is likely that you are using <code>=</code> or <code>&lt;&gt;</code> to compare values.</p>
<p>For example, the following function has type <code>''a list * 'a -&gt; bool</code>:</p>
<pre><code>fun contains (x, []) = false
  | contains (x, y::ys) = x = y orelse contains (x, ys)
</code></pre>
<p>Because <code>x</code> and <code>y</code> are compared by <code>=</code> in the function, then any inputs into the <code>contains</code> function must consist of equality types, so the type is <code>''a list * ''a -&gt; bool</code>.</p>
<p>However, we might want a function that takes in an <code>'a list</code> instead because it is more general. We still need some way of comparing whether two elements are equal or not, so we will pass in an extra parameter to compare two elements. We can rewrite the function as follows:</p>
<pre><code>fun contains (cmp, x, []) = false
  | contains (cmp, x, y::ys) =
    case cmp (x, y) of
      EQUAL =&gt; true
    | _ =&gt; contains (cmp, x, ys)
</code></pre>
<p>The type of the function will now be <code>('a * 'a -&gt; order) * 'a list * 'a -&gt; bool</code>.</p>
<p>In general, it's preferable to use <code>case</code> expressions instead of <code>if-then-else</code> statements with <code>=</code> in the condition.</p>
<h2 id="t-type-errors"><a class="header" href="#t-type-errors">?.t Type Errors</a></h2>
<pre><code>errors.sml:9.7-10.18 Error: right-hand-side of clause does not agree with function result type [tycon mismatch]
  expression:  ?.t
  result type:  ?.t
</code></pre>
<p>Clearly, this is not a very helpful error message. The code that induces this
error is shown below.</p>
<pre><code class="language-sml">signature T =
sig
  type t val x : t
end

functor Foo (structure A : T
             structure B : T) =
struct
  fun bar (0 : int) = A.x
    | bar n = B.x
end
</code></pre>
<p>The reason for this error is because the compiler does not distinguish (in terms
of name) structures that are given as argument to the functor <code>Foo</code>. Both are
referred to by <code>?</code>. In other words, it is saying that, on the second line of
<code>bar</code>, it expected a value of type <code>A.t</code> to be returned, but received one of
type <code>B.t</code>, namely <code>B.x</code>. Since <code>A</code> and <code>B</code> do not really have names, however,
it just referred to either structure as <code>?</code>, causing the confusing error.</p>
<p>If you receive this error, check your structures to make sure that you are not
conflating types from different structures.</p>
<h2 id="re-declaring-datatypes"><a class="header" href="#re-declaring-datatypes">Re-declaring Datatypes</a></h2>
<p>Some datatypes are already present in the SML Basis Library, meaning that you do
not have to declare them, as they are already present at the top level.
Re-declaring datatypes anyways, however, can cause type issues that are somewhat
difficult to debug. Consider the following code:</p>
<pre><code class="language-sml">fun opt_wrap x = SOME x

datatype 'a option = NONE | SOME of 'a

fun wrap_again (x : int) : int option = opt_wrap x
</code></pre>
<p>Although it looks innocuous, we will run into the following type error:</p>
<pre><code>errors.sml:5.5-5.51 Error: right-hand-side of clause does not agree with function result type [tycon mismatch]
  expression:  int ?.Assembly.option
  result type:  int option
</code></pre>
<p>The reason for this is because the declaration of <code>'a option</code> on the third line
creates a new type <code>'a option</code> that &quot;shadows&quot; the basis' definition. This means
that on line 1, <code>SOME</code> is of the type of the original option, whereas the
function <code>wrap_again</code> is type-annotated to expect a value of the type of the
<em>new</em> option.</p>
<p>In general, re-declaring datatypes is a bad idea that will cause conflicts down
the road, as it makes your code incompatible with any other code expecting the
original datatype, such as autograders. Be sure to not re-declare datatypes that
already exist to avoid this issue.</p>
<h2 id="forgetting-a-bar"><a class="header" href="#forgetting-a-bar">Forgetting a Bar</a></h2>
<p>Recall that a bar <code>|</code> is required to delimit different clauses in a function
definition. For instance, take the following (incorrect) implementation of the
<code>fact</code> function:</p>
<pre><code class="language-sml">fun fact (0 : int) : int = 1
    fact n = n * fact (n - 1)
</code></pre>
<p>Compiling this will result in the error:</p>
<pre><code>errors.sml:2.24 Error: unbound variable or constructor: n
errors.sml:2.14 Error: unbound variable or constructor: n
errors.sml:2.10 Error: unbound variable or constructor: n
errors.sml:1.29-2.30 Error: operator is not a function [overload - bad instantiation]
  operator: 'Z[INT]
  in expression:
    1 fact
errors.sml:1.6-2.30 Error: right-hand-side of clause does not agree with function result type [tycon mismatch]
  expression:  bool
  result type:  int
  in declaration:
    fact =
      (fn 0 : int =&gt;
            (1 fact) &lt;errorvar&gt; = &lt;errorvar&gt; * fact (&lt;errorvar&gt; - 1): int)
</code></pre>
<p>If you see <code>unbound variable or constructor</code> errors where they don't make sense,
and should not be unbound, it may be the case that you are having a deeper
syntax issue!</p>
<h2 id="let-in-without-an-end"><a class="header" href="#let-in-without-an-end">Let in without an end</a></h2>
<p>Consider the following code snippet:</p>
<pre><code class="language-sml">fun foo x =
  let
    val y =
      let
        val z = 3
      in
  in
    4
  end
</code></pre>
<p>Compiling this will result in the error:</p>
<pre><code>errors.sml:6.7-6.9 Error: syntax error: replacing  IN with  SEMICOLON
errors.sml:11.1 Error: syntax error found at EOF

uncaught exception Compile [Compile: &quot;syntax error&quot;]
  raised at: ../compiler/Parse/main/smlfile.sml:19.24-19.46
             ../compiler/TopLevel/interact/evalloop.sml:45.54
             ../compiler/TopLevel/interact/evalloop.sml:306.20-306.23
</code></pre>
<p>due to the missing <code>end</code> at the end of the inner <code>let</code>. In general, an error
that says &quot;replacing&quot; is trying to signal that you have probably put an
unexpected form of syntax where it shouldn't be - look at precisely what is
missing to determine what the error is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-hints-and-strategies"><a class="header" href="#debugging-hints-and-strategies">Debugging Hints and Strategies</a></h1>
<p><em>By Eunice Chen, January 2021</em></p>
<p>Debugging is often one of the hardest and most time-consuming parts of coding. Don't be frustrated if it takes longer than the actual coding at times; that is all part of the process! Luckily, SML is a type-safe language, so most errors are compilation errors (code does not typecheck) or errors in the logic of the code itself.</p>
<h2 id="debugging-compilation-errors"><a class="header" href="#debugging-compilation-errors">Debugging Compilation Errors</a></h2>
<h3 id="1-get-a-syntax-highlighter"><a class="header" href="#1-get-a-syntax-highlighter">1. Get a syntax highlighter</a></h3>
<p>Syntax highlighting is tremendously helpful from both a debugging and readability standpoint. Also, finding typos and syntax errors is much easier with syntax highlighting, simply because the code is much easier to read. Many code editors have syntax highlighting plugins for SML. (For example, in VSCode, there is an extension providing SML language support).</p>
<h3 id="2-anatomy-of-an-error-message"><a class="header" href="#2-anatomy-of-an-error-message">2. Anatomy of an error message</a></h3>
<figure class="aligncenter">
    <img src="debugging/../assets/errors.png" alt="Instructions" width="1500"/>
    <figcaption><b>Fig 1.</b> Sample error message with a brief explanation of each component of the message. </figcaption>
</figure>
<p>For more specific error messages, it may help to consult the errors page of this website.</p>
<h3 id="3-explicitly-type-annotate"><a class="header" href="#3-explicitly-type-annotate">3. Explicitly Type Annotate</a></h3>
<p>If things do not quite typecheck, one thing that often helps is explicitly type annotating each value used within the function. Sometimes, the type error looks like it occurs on one line, but the real issue may have occurred earlier in the code. Thus, type annotation often helps pinpoint the source of the error, since the explicitly annotated type will fail on whichever line the expected (type-annotated) type does not match the actual type. However, make sure that, in explicitly type-annotating, you do not accidentally restrict the generality of the types (i.e. putting an <code>int</code> where you should have an <code>'a</code>, which will work in the short term because <code>int</code> is more specific than <code>'a</code>, but may fail later when something of type <code>'a</code> is needed). This can cause more errors later down the line, even if they do work immediately.</p>
<h2 id="debugging-code-logic"><a class="header" href="#debugging-code-logic">Debugging Code Logic</a></h2>
<h3 id="1-start-with-small-test-cases"><a class="header" href="#1-start-with-small-test-cases">1. Start with small test cases</a></h3>
<p>First, you will want to write simple, small test cases, to test the most basic parts of your function. Identify the simplest combinations of inputs for your function, and test the behavior of the function on these small inputs. If you are working with lists, for example, you may want to write test cases involving <code>[]</code> and the singleton list, to test the <code>[]</code> and <code>x::xs</code> patterns, respectively. If you are working with ints, often the simplest inputs to your function may be <code>0</code> and <code>1</code>.</p>
<p>The basic structure of a test is as follows:</p>
<p>Suppose we are trying to debug function <code>f : int -&gt; int</code>, and we expect <code>f 1</code> to evaluate to <code>0</code>. Then, we would write our test case as</p>
<pre><code>val 0 = f 1
</code></pre>
<p>If <code>f 1</code> does not evaluate to <code>0</code>, then the SML compiler will raise the exception Bind when this code is run, since it will be unable to bind the result of <code>f 1</code> to the value <code>0</code>.</p>
<h3 id="2-write-more-comprehensive-tests"><a class="header" href="#2-write-more-comprehensive-tests">2. Write more comprehensive tests</a></h3>
<p>Once you have tested some of the most basic functions, you should write more comprehensive tests. Typically, this involves writing a test for each clause in the code. However, sometimes writing a test for each clause in the code is not enough, since the function may still evaluate to an incorrect value on more complicated outputs. A good rule of thumb is that you should, at minimum, write tests for each function clause, but you will probably have to write more tests depending on the situation.</p>
<h3 id="3-debug-bottom-up"><a class="header" href="#3-debug-bottom-up">3. Debug &quot;Bottom Up&quot;</a></h3>
<p>Often, your code will either call helper functions, or embed smaller functions within larger ones using <code>let</code> and <code>local</code> keywords. When debugging, first ensure these smaller, lower-level functions work before debugging top-level functions, as ensuring the correctness of these lower-level functions allows you to rely on their correctness when debugging top-level functions.</p>
<h3 id="4-step-through-code"><a class="header" href="#4-step-through-code">4. Step through code</a></h3>
<p>Often, simply just walking through each step in the code to ensure it evaluates in the way you expect is useful. Sometimes, it may help to print out values after a certain step in your code. However, print statements should not be your first choice in debugging, as printing has some limitations. Because the SML <code>print</code> function has the type <code>string -&gt; ()</code>, you can only print out strings. (Note: the <code>print</code> function causes <em>side effects</em>, i.e. the printing of its input in the REPL, which is why it evaluates to a unit. However, if you haven't learned what <em>side effects</em> are, don't worry- just know that the <code>print</code> function returns <code>()</code>). In order to print out values that are not strings, you have to convert the value to a string, either by using an SML library function (like <code>Int.toString</code>), or by writing your own <code>toString</code> function.</p>
<p>Suppose we want to see what some function <code>f : int -&gt; int</code> evaluates to on the input <code>1</code>. Then, we would write the following code:</p>
<pre><code>val () = print (Int.toString (f 1))
</code></pre>
<p>Then, once the code is compiled and run, the result of <code>f 1</code> will be printed out in the REPL.</p>
<p>If you decide to use print statements while stepping through code, you may have to add an extra <code>let</code> statement so that you can add the <code>val</code> declaration for printing.</p>
<p>In general, print statements in SML can be unwieldy and difficult to use, so print statements are generally not suggested as a way to debug. However, stepping through each line and clause of code is generally very helpful and highly encouraged.</p>
<h2 id="debugging-strategies"><a class="header" href="#debugging-strategies">Debugging Strategies</a></h2>
<h3 id="rubber-duck-method"><a class="header" href="#rubber-duck-method">Rubber Duck Method</a></h3>
<p>One useful method of debugging is called the &quot;rubber duck method,&quot; in which the programmer explains their code, line by line, to a rubber duck (though any object, inanimate or animate, will work equally as well). The premise of this method is that, by explaining what the code is supposed to do and seeing what it actually does, any incongruity between the two becomes apparent and the error is found. Also, this method is helpful because, through explaining, you gain a much better understanding of the concept/code being explained.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Standard ML is a <em>functional</em> programming language, meaning that we eschew the use of <em>side effects</em> and <em>state changes</em> to obtain programs that are easy to reason about, analogous to reasoning about mathematical expressions. Similarly to mathematics, we perform operations and view computation as a process of <em>simplification</em> (or <em>reduction</em>, as we will more commonly name it). Seen in this way, computation becomes an elaborate series of expression evaluations, and it is this concept that will permeate the course. In these notes, we will go further in detail about the basic concepts of SML.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h1>
<p><em>By Brandon Wu, May 2020</em></p>
<p>Evaluation is a commonplace idea. No matter what programming language you are in, it is a customary concept to invoke subroutines in order to obtain some kind of <em>final result</em>, which can be further used in order to achieve some later goal. To obtain such a result, however, programs must perform certain computations and carry out certain steps - in other words, they must <em>evaluate</em>. Ultimately, programs are complicated constructs whose main goal is to compute some value or achieve some effect - we will focus mainly on the first case here. </p>
<h2 id="expressions-and-values"><a class="header" href="#expressions-and-values">Expressions and Values</a></h2>
<p>Expressions in Standard ML are akin to mathematical expressions. They are built up from applications of certain operations, being subject to certain simplification rules that can be used to obtain a final answer. For instance, we would consider <code>2 + 2</code> an expression, similarly to other examples such as <code>1 div 0</code> and <code>Int.toString 2</code>.</p>
<p>The most fundamental building blocks in Standard ML are <em>values</em>. Values are the primordial units of a given type, being irreducible to any further simplified form. When trying to answer some computational problem, it is usually the case that we are looking for some kind of &quot;answer&quot;. As such, values are important to obtain, as we are usually looking for some kind of answer in &quot;simplest terms&quot;. Values in SML emcompass examples such as <code>2</code>, <code>true</code>, <code>&quot;foo&quot;</code>, <code>[1, 2, 3]</code> and <code>fn x =&gt; x + 1</code>.</p>
<blockquote>
<p><strong>[Value]</strong> A value is an expression <code>e</code> such that, for all <code>e'</code> such that <code>e ==&gt; e'</code>, <code>e' = e</code>. In other words, a value is an expression that only reduces to itself - there is no pending computation left to be done.</p>
</blockquote>
<p><strong>NOTE:</strong> The meaning of <code>==&gt;</code> in the above definition is <em>reduction</em>, which is further explained below. </p>
<p>A noteworthy distinction to make is that certain language constructs, such as an if-then-else expression, let-in-end expression, or case expression, are in fact <em>expressions</em>. This means that they can be passed around and evaluated just like any other expression. So for instance, the following code is a valid expression:</p>
<pre><code class="language-sml">(let
    val x = 5
in 
    x
end) + 2
</code></pre>
<p>and has the value of <code>7</code>. Similarly, the following code is also an expression:</p>
<pre><code class="language-sml">(if true then 15 else 150) * 2
</code></pre>
<p>and has a value of <code>30</code>. </p>
<h2 id="reduction"><a class="header" href="#reduction">Reduction</a></h2>
<p>We now define a notion of <em>reduction</em>, which corresponds to our notion of simplification. We write that <code>e ==&gt; e'</code> if the expression <code>e</code> <em>reduces to</em> the expression <code>e'</code>, which means that <code>e</code> produces <code>e'</code> from zero or more applications of some simplifying rule. For instance, we may say that <code>2 + 2 ==&gt; 4</code>, since by applying the function <code>(op +)</code>, we obtain <code>4</code>. Furthermore, we may say that <code>if true then &quot;good&quot; else &quot;bad&quot; ==&gt; &quot;good&quot;</code> by evaluation of the if-then-else expression, since the predicate (in this case <code>true</code>) is true.</p>
<p><strong>NOTE:</strong> <code>==&gt;</code> is <em>not</em> valid SML code, it is simply our shorthand for the idea of reduction.</p>
<blockquote>
<p><strong>[Valuable]</strong> An expression <code>e</code> is <em>valuable</em> if there exists a value <code>v</code> such that <code>e ==&gt; v</code>. Note that all values are by definition valuable.</p>
</blockquote>
<p>So valuable expressions include <code>2 + 2</code>, <code>4</code>, and <code>if true then 4 else 2</code> (and in fact all reduce to the same value!). An example of a <em>non</em>-valuable expression is <code>1 div 0</code>, which raises an exception <code>Div</code> when evaluated (since division by zero is undefined). Additionally, if we consider the following code fragment:</p>
<pre><code class="language-sml">fun loop (x : int) : int = loop x
</code></pre>
<p>This defines a function <code>loop : int -&gt; int</code> that loops forever, since it continuously calls itself forever. Thus, <code>loop x</code> for any <code>x : int</code> is also a non-valuable expression, since it never reduces down to a value. </p>
<p>In fact, what we will see is that this behavior is sufficient to characterize <em>all</em> well-typed expressions. We summarize it in the following:</p>
<blockquote>
<p><strong>[Behavior of Well-Typed Expressions]</strong> For any well-typed expression <code>e</code>, it either:</p>
<ol>
<li>
<p>Reduces to a value</p>
</li>
<li>
<p>Loops forever</p>
</li>
<li>
<p>Raises an exception</p>
</li>
</ol>
</blockquote>
<h2 id="eager-evaluation"><a class="header" href="#eager-evaluation">Eager Evaluation</a></h2>
<p>SML is an <em>eagerly evaluated</em><sup>[1]</sup> language. This stands opposed to other paradigms such as <em>lazy</em> evaluation, which is exhibited in languages such as Haskell. In an eagerly evaluated language, we evaluate arguments of functions even if we may not need them. While this arguably may be &quot;wasteful&quot; in some cases, we will find that this greatly simplifies work/span analysis, among other benefits.</p>
<blockquote>
<p><strong>[Eager Evaluation]</strong> In an eagerly evaluated language, arguments of functions are evaluated <em>before</em> stepping into the body of a function. For a function <code>f</code> and valuable expression <code>e</code>, when evaluating the expression <code>f e</code>, first <code>e</code> is evaluated to obtain the value <code>v</code> such that <code>e ==&gt; v</code>, then <code>f v</code> is evaluated.</p>
</blockquote>
<p>As an example of this, consider the function <code>fn x =&gt; x + 1</code>. If we were to try and evaluate <code>(fn x =&gt; x + 1) (2 * 3)</code>, first we would need to evaluate the function's arguments, that being <code>2 * 3</code>. As such, this entire expression would reduce to <code>(fn x =&gt; x + 1) 6</code>, which is <code>7</code>.</p>
<p>In an example like the previous one, it doesn't particularly matter where we evaluated <code>2 * 3</code> - we would have gotten the same result either way. This is not always the case. Consider the expression <code>(fn x =&gt; 2) (1 div 0)</code>. By eager evaluation, we should evaluate the argument first, which means that this entire expression should raise an exception. Raising an exception thus happens <em>before we even look at the body of the function</em>. For all intents and purposes, the body of the function does not exist to us until we actually enter it - which necessitates that the argument to the function is valuable. It is a black box that is &quot;locked&quot; behind the argument. </p>
<h4 id="footnotes-1"><a class="header" href="#footnotes-1">Footnotes</a></h4>
<p>[1]: In other languages, we may instead say <em>call-by-value</em>, which is a separate but closely related concept.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensional-equivalence"><a class="header" href="#extensional-equivalence">Extensional Equivalence</a></h1>
<p><em>By Brandon Wu, June 2020</em></p>
<p>Up to this point, we have been using terms such as &quot;equal&quot; and &quot;equivalent&quot;
rather casually. Such a notion of equality seems to be rather intuitive, at
first glance, not necessarily in need of more exposition. After all, it seems to
be our intuition that if two things are equal, we will &quot;know it when we see it&quot;.
When working in the realm of mathematical expressions, we have some nice
assumptions that lend credence to such a hypothesis - if we are evaluating the
cosine of a number, we don't expect that the cosine function might wait forever
before returning an answer to us. When working with SML code, this becomes a
valid concern, and requires that we have a more particular definition of
equivalence.</p>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>It is at this point that we will try to make the <em>reasons</em> for defining an idea
of extensional equivalence apparent. It has everything to do with the
<em>extensional</em> behavior of our programs - the outputs that it returns given
certain inputs.</p>
<p>Extensional equivalence comes into play when reasoning about the correctness of
programs. A large motive for why we write functional code is linked to an idea
of a <em>formal proof</em> - when writing code without side effects, it is far easier
to reason about the behavior of a program. We would like to be able to provide
some rigorous argument as to why a program is correct. </p>
<p>In imperative settings, it is quite difficult to go about doing so - when
problems of state are added in, a programmer now not only needs to think about
what step a particular program is in at a given moment, but also what the state
of the program is as well. By state, we usually mean the particular arrangement
of mutable data in the program's environment, such as the state of memory
allocation, variable contents, and other transient factors. The possible
configurations of such a state are generally infinite, which makes reasoning
rather more difficult. While one can generally be <em>reasonably</em> sure what the
state of a program should be, it does not always work out that way, as any
programmer who has written a bug can attest. In functional programs, we eschew
side effects for ease in reasoning about what a program truly outputs. Functions
have well-defined results.</p>
<p>Imperative programmers create functional programs. This is, at first, perhaps a
surprising claim, but we will soon delineate what precisely we mean. In making
this claim, we are only considering functions of a certain basic kind - that is,
functions that <em>compute</em>, rather than <em>create</em> or <em>modify</em>. For instance, a
program that generates the Fibonacci numbers, or computes the most efficient
path through a given graph, or encodes some kind of data. We do not consider
programs that, for instance, outputs to a file or prints the contents of the
directory that the program file lives in. In addition, we speak only of programs
that do not return <em>random results</em>, for instance random number generators or
other random selectors. </p>
<p>These programs have the characteristic that they are (in the general case)
<em>deterministic</em>. Given the same inputs, they should return the same output -
regardless of whether the language that they were implemented in is imperative
in nature. So for these varieties of programs (which are very common
computational problems), imperative programs make use of state to achieve a
program that is functional in nature - that is, having no overall visible effect
on the machine's state. Functional programming simply uses functional tools to
achieve the same result, in the end.</p>
<p>This is an important idea to cognize because it forms the basis for our concept
of <em>correctness</em>. We identify a program's correctness by its ability to return
the expected results when given some input. For instance, we know a factorial
function that returns 5 upon being given 3 is no good. Having functional
<em>components</em> helps us easily reason and build up functional <em>results</em> - that is,
an end program that returns the correct results.</p>
<p>As we will see, extensional equivalence will be a powerful tool when reasoning
about the correctness of our code. It lets us prove in a mathematical sense
whether functions are <em>correct</em>, as well as abstract between specific
implementations. We will go further into detail on this later in the chapter.</p>
<h2 id="the-definition"><a class="header" href="#the-definition">The Definition</a></h2>
<p>We will declare this definition of extensional equivalence for non-function
expressions first, and then explore the function case later.</p>
<blockquote>
<p><strong>[Extensional Equivalence (Non-Functions)]</strong> We say that two expressions <code>e : t</code> and <code>e' : t</code> for some type <code>t</code> are <em>extensionally equivalent</em> if they
exhibit any of these three behaviors:</p>
<ol>
<li>
<p>Reduce to the same value</p>
</li>
<li>
<p>Loop forever</p>
</li>
<li>
<p>Raise the same exception</p>
</li>
</ol>
<p>We will write <code>e == e'</code> to denote this.</p>
</blockquote>
<p><strong>NOTE:</strong> <code>==</code> is not valid SML code.</p>
<p>As such, clearly expressions such as <code>2 + 2</code> and <code>3 + 1</code> should be extensionally
equivalent, since they reduce to the same value, that being <code>4</code>. It is important
to note that reduction is a <em>stronger</em> relation than extensional equivalence -
if one expression reduces to another, then they must by definition be
extensionally equivalent. However, extensional equivalence does not imply
reduction. For instance, <code>4</code> does not reduce to <code>2 + 2</code>, since clearly <code>4</code> is
already in its most simplified form. This corresponds to our intuition about
traditional mathematical expressions, as we would expect that we could say that
\( -1 \) and \( \cos(\pi) \) are equal, since they have the same value.</p>
<p>With the second point, however, we depart from our normal mathematical
reasoning. It is generally the case that, given a mathematical expression, we
expect to be able to generate a result from it. That result may be undefined,
and it may take some time, but in many cases we don't expect to have to account
for a nonterminating computation. This is not the case in Standard ML. Now, any
given function call may loop forever, which plainly is problematic for
equivalence.</p>
<p>As such, we will add a stipulation that two expressions (of the same type) that
loop forever are extensionally equivalent. Note that even though two expressions
of dissimilar types that loop forever have the same &quot;behavior&quot;, they cannot be
extensionally equivalent by definition, as only expressions of the same type can
be extensionally equivalent. </p>
<p>The third case also arises from our usage of Standard ML, as expressions can
potentially raise exceptions in cases where computation is not feasible. Some
basic kinds of exceptions include <code>Div</code>, <code>Bind</code>, and <code>Match</code>. The precise
mechanism of exceptions is not important, since we will cover that in more
detail later on, but in order to maintain some notion of equivalence, we will
simply require that two same-typed expressions raise the <em>same</em> exception. As
such, expressions like <code>1 div 0</code> and <code>2 div 0</code> are extensionally equivalent,
whereas <code>1 div 0</code> and <code>let val [] = [1] in () end</code> are not.</p>
<p><strong>Note:</strong> It is not important to know specifically what the latter expression in
the last example is doing - just know that it raises the exception <code>Bind</code>.</p>
<p>In writing these definitions we have made a step towards cognizing extensional
equivalence, but in a sense we have taken a step back as well. We have committed
the same mistake by saying extensional equivalence holds when expressions
&quot;reduce to the same value&quot;. We required this more stringent definition of
extensional equivalence specifically because of callously using terms like
&quot;equal&quot; and &quot;equivalent&quot;, and now we've so unthinkingly used the term &quot;same&quot;.
But what does it mean for two values to be the &quot;same&quot;?</p>
<p>For many cases, our intuition will suffice. It is clear to say that <code>2</code> is the
same as <code>2</code>, and <code>2</code> is not the same as <code>&quot;two&quot;</code> (for any self-respecting
programming language, in any case). For one, the types must be the same, and
definitely one integer value should not be &quot;equal&quot; to any other separate integer
value. We might then claim that two values are only &quot;equivalent&quot; if they denote
the same literal value. </p>
<p><strong>NOTE:</strong> The perceptive reader may notice that again, we have used the words
&quot;same&quot; and &quot;separate&quot;. Unfortunately, there is only so far that we can dig this
rabbit hole - at this point, we will have to rely on our intuitions to tell us
that <code>2</code> is indeed the same value as <code>2</code>, and not the same value as <code>3</code> or <code>4</code>,
and call it a day.</p>
<p>This definition will suffice for most types. For functions, however, we will
have to take a different approach.</p>
<blockquote>
<p><strong>[Extensional Equivalence (Functions)]</strong> We say two expressions <code>e : t1 -&gt; t2</code> and <code>e' : t1 -&gt; t2</code> for some types <code>t1</code> and <code>t2</code> are extensionally
equivalent if for all values <code>x : t1</code>, <code>e x</code>\( \cong \)<code>e' x</code>.</p>
</blockquote>
<p>We see that this definition simply takes our previous definition and moves it
one step up. There is an interesting aspect of this rule that depends on a
concept that we have yet to learn, but we will cover that when we get there.
Seen in this way, we can say that two function values that are not the same
literal value may be extensionally equivalent, as their <em>extensional</em> behavior
(that is, their behavior when interacting with other objects) may be the same.</p>
<p>More concretely, let us consider the example of <code>fn x =&gt; x + x</code> and <code>fn x =&gt; 2 * x</code>. Recall from the previous chapter that <code>fn x =&gt; x + x</code> in particular does
<em>not</em> simplify to <code>fn x =&gt; 2 * x</code>, and is in fact itself a value - meaning that
it is in its terminal form, being irreducible to anything other than itself. The
right hand side of any lambda expression is, in a sense, <em>frozen</em> until the
function is given an argument. So then <code>fn x =&gt; x + x</code> and <code>fn x =&gt; 2 * x</code> are
different values, however it is obvious to see that on being given an input they
evaluate to extensionally equivalent values (specifically, the same integer). </p>
<p>As discussed before, our definition of &quot;equivalence&quot; identifies functions with
the values that they output. It should feel intuitively clear - two functions
are exactly equivalent if they return the same output for the same inputs. This
seems to be the definition of computing the &quot;same&quot; function. Notice that we omit
any mention of complexity or <em>how</em> the function goes about computing what it
computes - no matter what path is taken, all that is important is what values
are ultimately outputted. </p>
<h2 id="referential-transparency"><a class="header" href="#referential-transparency">Referential Transparency</a></h2>
<p>In this section we will introduce a powerful idea called <em>referential
transparency</em>, which follows as a direct consequence of our definition of
extensional equivalence.</p>
<blockquote>
<p><strong>[Referential Transparency]</strong> Consider an expression <code>e</code> that contains the
expression <code>e1</code> as a sub-expression. For any expression <code>e2</code>\( \cong \)<code>e1</code>, we
can produce the expression <code>e'</code> as the same expression as <code>e</code>, but with each
sub-expression <code>e1</code> replaced with <code>e2</code>, and we will have <code>e</code>\( \cong \)<code>e'</code>. In
words, for an expression <code>e</code> that contains <code>e1</code>, we can swap out <code>e1</code> for an
extensionally equivalent <code>e2</code> to obtain an expression extensionally equivalent
to <code>e</code>.</p>
</blockquote>
<p><strong>NOTE:</strong> The notion of a &quot;sub-expression&quot; here is not very well defined - we
will use our intuition here, similarly with what it means to be the &quot;same
expression&quot;. Gaining an intuition through examples will suffice.</p>
<p>To illustrate this, we might say that the expression <code>4 * (2 + 2)</code> has the
sub-expression <code>2 + 2</code>, and that <code>let val x = f (1 div 0) in x end</code> has <code>(1 div 0)</code> as a sub-expression. In the former case, we can use referential transparency
to say that <code>4 * (2 + 2)</code>\( \cong \)<code>4 * 4</code> and <code>let val x = f (1 div 0) in x end</code>\( \cong \)<code>let val x = f (2 div 0) in x end</code>, by replacing the aforementioned
sub-expressions with <code>4</code> and <code>2 div 0</code>, respectively.</p>
<p>Referential transparency will let us abstract away from the specific makeup of a
certain implementation or expression, instead replacing it as we see fit with
something known to be extensionally equivalent, while still allowing us to
maintain extensional equivalence. This comes in handy when proving that an
implementation of a particular function is correct, as we can simply prove that
it is extensionally equivalent to an existing, simpler implementation that is
already known to be correct. This has consequences for simplifying and
optimizing implementations.</p>
<p>Later on, we will explore specifically how we may go about proving extensional
equivalence. This will primarily take the form of mathematical or structural
induction.</p>
<h2 id="stepping-with-valuable-expressions"><a class="header" href="#stepping-with-valuable-expressions">Stepping with Valuable Expressions</a></h2>
<p>Recall from the previous article that SML uses eager evaluation. In other words,
the parameters of a function are evaluated before stepping into the function.</p>
<p>When proving extensional equivalence theorems about SML code, though, we often
end up in a situation where we want to step into a function, but the function is
being applied to an expression that isn't a value.</p>
<p>We will look at an example of this situation, involving the functions <code>@</code>
(append) and <code>rev</code>. The definition of <code>@</code> is as follows:</p>
<pre><code class="language-sml">fun [] @ L = L
  | (x::xs) @ L = x::(xs@L)
</code></pre>
<p>Now, suppose we want to show the following theorem:</p>
<p><code>(x::xs) @ (rev A)</code> \( \cong \) <code>x::(xs @ (rev A))</code></p>
<p>where <code>x : int</code>, <code>xs : int list</code>, and <code>A : int list</code> are all values. First, make
sure this &quot;feels right&quot; -- the left side of our theorem matches the second
clause of <code>@</code> with <code>rev A</code> bound to <code>L</code>.</p>
<p>However, notice that <code>rev A</code> is not a value. Since SML is eager, we cannot step
into the function <code>@</code> until we evaluate the expression <code>rev A</code>. In other words,</p>
<p>\[ <code>(x::xs) @ (rev A)</code> \not\Longrightarrow <code>x::(xs @ (rev A))</code> \]</p>
<p>So, we're stuck! D:</p>
<p>... or are we?</p>
<p>Let's assume that <code>rev A</code> is valuable, i.e. it evaluates to a value, and let's
give that value a name-- say, <code>v : int list</code>: \[ <code>rev A</code> \Longrightarrow <code>v</code> \]
With this value in hand, we can do what we wanted to do!</p>
<p>\[ <code>(x::xs) @ (rev A)</code> \Longrightarrow <code>(x::xs) @ v</code> \Longrightarrow <code>x::(xs @ v)</code>
\]</p>
<p>Notice that this complies with SML's eager evaluation, since we are fully
evaluating the parameters of <code>@</code> before stepping into the function.</p>
<p>And here's the kicker: we can also use <code>v</code> to evaluate the right hand side of
our theorem!</p>
<p>\[ <code>x::(xs @ (rev A))</code> \Longrightarrow <code>x::(xs @ v)</code>
\]</p>
<p>Again, this complies with SML's eager evaluation-- in this case, we never even
step into the definition of <code>@</code>. But, we've actually proven our theorem! We
showed that the LHS and the RHS both evaluate to the same expression, so by rule
1 of the definition of \( \cong \), the LHS and RHS must be extensionally
equivalent. We are done!</p>
<p>In this example, we got around SML's eager evaluation by assuming that our
parameter <code>rev A</code> is valuable, and as it turns out, this concept holds in the
general case. If we know the parameter of a function is <em>valuable</em>, then we can
step into the function <em>without</em> first evaluating that parameter. This
principle, which we will call (for lack of a better term) &quot;stepping with
valuable expressions,&quot; is one reason why valuable expressions are so important.</p>
<blockquote>
<p><strong>[Caution!]</strong> When stepping with <em>values</em>, we can use the reduction relation
\( \Longrightarrow \). When stepping with <em>valuable expressions</em>, this is not
always true (it certainly is not true in the example above). Stepping with
valuable expressions only preserves extensional equivalence \( \cong \).</p>
</blockquote>
<h2 id="totality"><a class="header" href="#totality">Totality</a></h2>
<p>As stated previously, frequently we will write proofs demonstrating the
extensional equivalence of two expressions. In order to do so, we often will
have to expand definitions, stepping through function bodies and applying
lemmas. In doing so, we will frequently need to do a <em>totality citation</em>, to
justify that making such steps is truly valid. While the name may seem
unfamiliar, it ultimately belies a concept that you already know - valuability.</p>
<blockquote>
<p><strong>[Total]</strong> We say that a function <code>f : t1 -&gt; t2</code> for some types <code>t1</code> and <code>t2</code>
is <em>total</em> if for all valuable expressions <code>x : t1</code>, <code>f x</code> is valuable. In
other words, for all valuable inputs to <code>f</code>, we get a valuable output.</p>
</blockquote>
<p>Examples of total functions include <code>fn x =&gt; x + 1</code>, <code>fn x =&gt; &quot;foo&quot;</code>, and the
length function for lists. Notably, however, the factorial function is <em>not</em>
total:</p>
<pre><code class="language-sml">fun fact (0 : int) : int = 1
  | fact (n : int) : int = n * fact (n - 1)
</code></pre>
<p>This function is not total because, while <code>fact n</code> is valuable for all
non-negative <code>n</code>, <code>fact n</code> for a negative <code>n</code> loops forever, as it decrements
infinitely, never finding a base case. Thus, <code>fact</code> is not total. Sometimes if a
function is valuable only on certain inputs, then we will say that a function is
&quot;total over&quot; some domain, even if it is not total in general. We may say that
<code>fact</code> is thus total over the non-negative integers, though this is not a common
practice.</p>
<p>We will now digress slightly to consider an example. What can we say of the
behavior of a function <code>fn x =&gt; 15150</code>? Well, we can characterize its behavior
in words - it returns <code>15150</code> on all inputs. We must be careful when linking our
intuition regarding this function to the actual evaluational semantics of SML -
however. Consider the expression <code>(fn x =&gt; 15150) (1 div 0)</code>. If we went along
with our previous conclusion, we might say that this is <code>15150</code>. This
contradicts what we learned in the previous section, however. Since SML is
eagerly evaluated, this expression should raise an exception and never reach the
function body at all. </p>
<p>This is an easy mistake to catch when considering an explicit, definite input
like <code>1 div 0</code>, but oftentimes we will be considering inputs that might be
&quot;unspecified&quot; in some sense. They may be the result of computations that we are
not fully convinced of, which could return an expression with any kind of
behavior. Suppose we were wondering the behavior of <code>(fn x =&gt; 15150) (f y)</code>, for
some function <code>f</code> and value <code>y</code>. Now, we aren't sure at all if this expression
does what we think it might do, which is return <code>15150</code> - that depends entirely
on the definition of <code>f</code> and the value of <code>y</code>.</p>
<p>This is where totality comes in. Totality is oftentimes like a sledgehammer,
being far more brutish and exhaustive than its use cases necessitate. It is
undeniably useful, however. With totality, we do not have to reason about the
behavior of a function on any specific inputs - we can just handwave them all
and say that no matter what, it must return a valuable output, which is what we
really care about. If we revisit the expression <code>(fn x =&gt; 15150) (f y)</code> with the
totality of <code>f</code> in hand, now reasoning about it is very simple. We know that <code>y</code>
is a value, and that <code>f</code> is total, so by definition <code>f y</code> is valuable. This
means that, regardless of what value <code>f y</code> <em>actually</em> evaluates to, we can step
into the body of <code>(fn x =&gt; 15150)</code>, and thus conclude that the expression
reduces to <code>15150</code>.</p>
<p>More generally, suppose we have the following definition:</p>
<pre><code class="language-sml">fun f (x : int) : int = e
</code></pre>
<p>where <code>e</code> denotes some expression that we will leave unspecified for the moment.
Thus, <code>f</code> is a function that takes in some input of type <code>int</code>, and produces a
val binding to bind it to the identifier <code>x</code>, and then evaluates the expression
of <code>e</code> in the scope of that binding. Note that such a binding is truly a <em>val</em>
binding - since we have eager evaluation, the input must first be evaluated to a
value, and then bound to the identifier <code>x</code>.</p>
<p>Then, consider the expression <code>f (g y)</code>, where <code>g</code> is some other function and
<code>y</code> is some value. Oftentimes, we would like to just step through the definition
of <code>f</code> in some proof, and say that <code>f (g y)</code> reduces to the expression <code>e</code> in
the scope of the binding <code>[(g y)/x]</code> (recall that this is our notation for
&quot;binding the value of <code>g y </code> to the identifier <code>x</code>). This is not always possible
in general, however. Recall that a well-typed expression either reduces to a
value, loops forever, or raises an exception. If <code>g y</code> were to loop forever,
would we be able to enter the function body of <code>f</code>, and evaluate <code>e</code>? </p>
<p>Of course we would not - this is just another consequence of eager evaluation.
Evaluation of <code>f (g y)</code> would get &quot;stopped at the door&quot;, so to speak. We would
not be able to enter <code>f</code> because <code>g y</code> does not reduce to a value. Since the
input to <code>g</code> is arbitrary, in this case, to be able to claim that <code>f (g y)</code>
enters the function body of <code>f</code> requires that we know the totality of <code>g</code>. We
thus use totality as a <em>tool</em> to get at what is really important - the
valuability of the arguments to <code>f</code>, which in this case is <code>g y</code>. As such, while
we may refer to such citations as &quot;totality citations&quot;, and name this idea of
totality, do not forget that this is all just a consequence of eager evaluation.
We are really looking for <em>valuability of arguments</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p><em>By Kaz Zhou, September 2020</em>. <em>Revised May 2021</em></p>
<p>Patterns take on many appearances, such as:</p>
<ul>
<li>Constants: <code>150</code></li>
<li>Variables: <code>x</code></li>
<li>Wildcard: <code>_</code></li>
<li>Tuples: <code>(true, _)</code></li>
<li>Constructors (which may contain other patterns):
<ul>
<li>Lists: <code>x::xs</code></li>
<li>Other datatypes: <code>Node(L,x,R)</code></li>
</ul>
</li>
</ul>
<p>Patterns can be matched against values to form bindings. Consider the following declaration:</p>
<p><code>val (x,y) = (1,2)</code></p>
<p>The result is that <code>1</code> gets bound to <code>x</code>, and <code>2</code> gets bound to <code>y</code>.</p>
<p>Pattern matching may fail. For example, the following raises exception <code>Bind</code>.</p>
<p><code>val 10 = 9</code></p>
<p>Besides <code>val</code> declarations, pattern matching is also used in function declarations, lambda expressions, and case expressions.</p>
<h2 id="function-declarations"><a class="header" href="#function-declarations">Function declarations:</a></h2>
<pre><code>fun fact 0 = 1
  | fact n = n * fact(n-1)
</code></pre>
<p>The function <code>fact</code> is given an <code>int</code> as input. If the input successfully matches the pattern <code>0</code>, then the function returns <code>1</code>. Otherwise, the input is matched with the pattern <code>n</code>, binding the input to <code>n</code>. For example, if we evaluate <code>fact 5</code>, then <code>5</code> is bound to <code>n</code>, so the expression becomes <code>5 * fact(4)</code>. </p>
<p>Each clause of the function declaration tells <code>fact</code> what it should do, depending on the input. The bar, <code>|</code>, acts as a separator between the two clauses. </p>
<p>Note that it's important for your patterns to be <em>exhaustive</em>. The above function is fine, because all values of type <code>int</code> can match with either <code>0</code> or <code>n</code>. However, suppose we had the following function:</p>
<pre><code>fun fiction 1 = 1
  | fiction 2 = 2
  | fiction 3 = 6
</code></pre>
<p>There are many inputs which do not match with either <code>1</code>, <code>2</code>, or <code>3</code>. For example, <code>fiction 4</code> would raise exception <code>Match</code>.</p>
<p>A more subtle bug is when patterns are redundant. The following example has the clauses of <code>fact</code> swapped.</p>
<pre><code>fun factloop n = n * factloop(n-1)
  | factloop 0 = 1
</code></pre>
<p>The second clause of <code>factloop</code> never gets executed! When evaluating <code>factloop 0</code>, SML will try to match <code>0</code> to each pattern, <em>in order</em>. Therefore, <code>factloop 0</code> steps to <code>0 * factloop(-1)</code>, because <code>0</code> can match to <code>n</code>. Convince yourself that <code>factloop k</code> will loop forever for any <code>k</code> of type <code>int</code>!</p>
<h2 id="lambda-expressions-1"><a class="header" href="#lambda-expressions-1">Lambda expressions:</a></h2>
<p><code>(fn [] =&gt; false | x::xs =&gt; true) [1,2,3]</code></p>
<p>The lambda expression is similar to a function, as it turns an input into an output. In the example above, <code>[1,2,3]</code> is the input. It doesn't match with <code>[]</code>, but it does match with <code>x::xs</code>. Namely, <code>1</code> gets bound to <code>x</code>, and the list <code>[2,3]</code> gets bound to <code>xs</code>. As a result of this successful pattern matching, the lambda expression returns <code>true</code>. </p>
<p>You should still make sure your patterns are exhaustive. For example, the following expression raises exception <code>Match</code>:</p>
<p><code>(fn [] =&gt; false) [1,2,3]</code></p>
<h2 id="case-expressions"><a class="header" href="#case-expressions">Case expressions:</a></h2>
<pre><code>fun fact' x =
    case x of
        0 =&gt; 1
      | n =&gt; n * fact' (n-1)
</code></pre>
<p>First, note that <code>fact'</code> does the same thing as <code>fact</code>. However, it uses an extra <code>case</code> expression.</p>
<p>Let's consider what happens when we evaluate <code>fact' 5</code>. First, <code>5</code> gets bound to <code>x</code>. Then, the <code>case</code> expression tries to match <code>5</code> to a pattern. In this scenario, <code>5</code> successfully pattern matches with <code>n</code>, so <code>5</code> gets bound to <code>n</code>. Therefore, <code>fact' 5</code> evaluates to <code>5 * fact' 4</code>. </p>
<p>As usual, the patterns in <code>case</code> expressions should be exhaustive.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion-and-induction"><a class="header" href="#recursion-and-induction">Recursion and Induction</a></h1>
<p><em>By Jacob Neumann and Kaz Zhou, May 2022</em></p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Functional programmers have a particular affinity for the technique of <strong><em>recursion</em></strong>. Recursion is a way of writing functions: a given SML function either will or won't be <em>recursive</em>, and you can tell by looking at its declaration. Most of the main functions (i.e. the ones doing the &quot;real work&quot; of a problem) you write when programming in a functional style will be recursive, and <em>thinking recursively</em> is an essential skill for functional programming. Indeed, many of the features of functional programming languages like SML are designed to facilitate writing recursive functions. And — as we discuss more in <a href="concepts/datatypes.html">the page about datatypes</a> — we'll also be designing our data to make it easier to define recursive functions.</p>
<p>Going hand-in-hand with recursion is the proof technique of <strong><em>induction</em></strong>. Induction is a tool used throughout mathematics, and will form the basis for the mathematical analysis of functional programming. To prove the correctness of a recursive function, the natural (and often the only) choice is to make use of an inductive argument. Moreover, the form of the recursive function will suggest to us the structure of the inductive proof. In this article, we'll develop this connection for natural numbers and integer lists. The connection between recursion and induction for trees is explored <a href="concepts/treeinduct.html">here</a>, and for general datatypes <a href="concepts/datatypes.html">here</a>. A specific kind of recursion, called <em>tail recursion</em>, is discussed <a href="concepts/tail.html">here</a>.</p>
<h2 id="iterative-versus-recursive-thinking"><a class="header" href="#iterative-versus-recursive-thinking">Iterative versus Recursive Thinking</a></h2>
<p>Here's a simple programming problem: write a function <code>exp</code> which takes in a natural number (an integer greater than or equal to zero) and returns the quantity 2<sup>n</sup>. Of course, 2<sup>n</sup> is just the quantity 2 multiplied by itself n times (e.g. 2<sup>3</sup> is 2 times 2 times 2), with the edge case of 2<sup>0</sup>=1. Now, if we were asked to solve this problem in an <em>imperative programming language</em> (like Python or C), our first instinct might be to do something like this:</p>
<pre><code>int exp (int n) { 
    // requires: n&gt;=0
    i = 0;
    res = 1;
    while (i&lt;n) {
        res = res * 2;
        i = i+1;
    }
    return res;
}
</code></pre>
<p>This code directly solves the problem by &quot;multiplying by 2, n times&quot;: it establishes a &quot;result&quot; <code>res</code>, and then repeatedly mutates <code>res</code> by multiplying by 2. The counter <code>i</code> and the loop guard are there to make sure that we do this exactly n times, giving 2<sup>n</sup>. This is what's called an <strong><em>iterative solution</em></strong>: it consists of initializing our data (in this case, the values stored in <code>res</code> and <code>i</code>), performing a carefully-chosen sequence of mutations to it (doubling <code>res</code> and incrementing <code>i</code>), and then reading off the result (the value in <code>res</code>). It is this style of thinking which plays a central role in imperative programming. </p>
<p>Such a solution is not possible when doing functional programming. Indeed, pure functional programming languages (by definition[1]) do not have data &quot;cells&quot; which can be repeatedly modified (as <code>i</code> and <code>res</code> are in the preceding example): everything in a functional programming language is <strong><em>immutable</em></strong>. If <code>i</code> is a &quot;variable&quot; in a functional programming language, <code>i</code> has just one value and will never have a different value. So we must find a different way to solve this problem. Our solution will be to use <strong><em>recursion</em></strong>.</p>
<p>The following is a correct SML implementation of <code>exp</code>. Type annotations have been omitted, for clarity.</p>
<pre><code class="language-sml">(* exp : int -&gt; int
 * REQUIRES: n&gt;=0 
 * ENSURES: exp n == 2^n
 *)
fun exp 0 = 1
  | exp n = 2 * exp(n-1)
</code></pre>
<p>In the above code, we specify the <strong><em>base case</em></strong> that \( 2^0 = 1 \). Then, for inputs greater than 0,
we first compute \(2^{n-1} \) recursively, and then multiply 2 to it.
By &quot;recursively&quot;, we are assuming our code works for smaller inputs.
You can trace through a few test cases to convince yourself that these elegant two lines of code
indeed implement <code>exp</code>.</p>
<h2 id="proof-by-induction"><a class="header" href="#proof-by-induction">Proof by Induction</a></h2>
<p>Perhaps test cases are not enough for you, or you would like to see the deep connection
between induction and recursion. We can use the principle of mathematical induction to
<strong><em>prove</em></strong> that our <code>exp</code> code works. Here is the theorem we want to show. Recall that we use
<code>==</code> to denote two expressions being extensionally equivalent.</p>
<p><strong>Theorem:</strong> <code>exp n ==</code> \(2^n\) for all integer values \( n \geq 0 \).</p>
<p><strong>Proof:</strong> We use the principle of mathematical induction on <code>n</code>.</p>
<p><strong>Base case:</strong> We prove the theorem for <code>n = 0</code>.</p>
<p><code>exp 0 == 1</code> (by clause 1 of <code>exp</code>)</p>
<p><code>1 ==</code> \(2^0\) (math)</p>
<p>When dealing with arithmetic, we may justify proof steps by &quot;math&quot;.
Also, unless stated otherwise, we may assume SML implements basic mathematical operations correctly,
such as <code>+</code> and <code>*</code>.</p>
<p><strong>Inductive step:</strong> Let \( k \geq 0 \) be fixed. </p>
<p>Induction hypothesis: Assume that <code>exp k ==</code> \( 2^k \).</p>
<p>We want to show the theorem for <code>k+1</code>.</p>
<p><code>exp (k+1) == 2 * exp (k+1-1)</code> (by clause 2 of <code>exp</code>)</p>
<p><code>== 2 * exp k</code> (by math, \(k+1-1 \) <code>==</code> \(k \) )</p>
<p><code>== 2 *</code> \(2^k \) (by IH)</p>
<p><code>==</code> \(2^{k+1} \) (math)</p>
<p>This concludes the inductive step. </p>
<p>There are some things to note about this proof. First, every time we are evaluating SML code,
we justify which line of code allows us to make a particular step.
For example, when evaluating <code>exp (k+1)</code>, clause 2 of <code>exp</code> tells us that expression is
extensionally equivalent to <code>2 * exp (k+1-1)</code>. In fact, we can say <code>exp (k+1)</code> <strong><em>steps to</em></strong>
<code>2 * exp (k+1-1)</code>.</p>
<p>Second, we've abbreviated the induction hypothesis citation as &quot;IH&quot;. Furthermore, note how
we quantified the induction hypothesis: we are not assuming the theorem is true for all
natural numbers. Rather, we assume the theorem is true for some fixed <code>k</code> (which is \( \geq 0 \) ).</p>
<p>The principle of mathematical induction works due to a sort of domino effect. Let's notate
that the theorem is true for an integer \( n \) with \( P(n) \). In the above proof, we've shown
\( P(0) \), and that \( P(k) \implies P(k+1) \) for all \(k \geq 0 \).</p>
<p>For example, suppose we wanted to show \( P(2) \). We begin with \( P(0) \), and from the inductive step get
\( P(1) \). Then we apply the inductive step again to get \( P(2) \).</p>
<h2 id="the-type-of-natural-numbers"><a class="header" href="#the-type-of-natural-numbers">The &quot;Type&quot; of Natural Numbers</a></h2>
<p>We can <em>inductively</em> define the natural numbers using Peano's axioms:</p>
<p>\( 0 \) is a natural number.
For every natural number \( n \), \( S(n) \) is a natural number.</p>
<p>We call \( S(n) \) the successor of \( n \). It's just a fancy term for saying &quot;add 1&quot;.
Using these axioms, we can create a datatype that encapsulates natural numbers:</p>
<p><code>datatype nat = Zero | Succ of nat</code></p>
<p>This is essentially saying that <code>Zero : nat</code>, and
if some expression <code>e : nat</code>, then <code>Succ e</code> also has type <code>nat</code>.
For example, the number 3 corresponds to <code>Succ (Succ (Succ Zero))</code>.</p>
<p>Using this datatype, we can view the principle of mathematical induction merely as
<strong><em>structural induction</em></strong> on the <code>nat</code> datatype. As an example, let us rewrite <code>exp</code> as:</p>
<pre><code class="language-sml">(* exp' : nat -&gt; int
 * REQUIRES: true 
 * ENSURES: exp' n == 2^n
 *)
fun exp' Zero = 1
  | exp' (Succ n) = 2 * exp' n
</code></pre>
<p>The <code>ENSURES</code> is a bit sloppy because we haven't defined taking exponents of values of type <code>nat</code>,
but hopefully it has meaning for the code's reader. Now, if we wanted
to prove the correctness of this version of <code>exp'</code>, our base case would be showing
<code>exp' Zero == </code> \( 2^0 \). The inductive step would be showing that if <code>exp' n == </code> \( 2^n \), then
<code>exp' (Succ n) == </code> \( 2^{n+1} \). We'll omit the proof's details.</p>
<p>It may seem pointless to write the above code (indeed, it is not that practical). But, there
are two advantages: we don't need to restrict the inputs to <code>exp'</code> anymore, because negative numbers
are not natural numbers! So, we won't need to worry about looping forever, which would happen
in the earlier version of <code>exp</code> if we tried evaluating <code>exp ~1</code>. Also, the code portrays how
<strong><em>structural induction</em></strong> is basically an overpowered version of the principle of mathematical induction.</p>
<h2 id="strong-induction"><a class="header" href="#strong-induction">Strong induction</a></h2>
<p>For proofs on natural numbers, we can also make use of <strong><em>strong induction</em></strong>. With strong induction, the
inductive step is showing that for an arbitrary \( k &gt; 0 \),
\( P(0), P(1), \cdots, P(k-1) \) all together imply \( P(k) \). In other words, we can make use of
the theorem being true on all previous natural numbers, as our induction hypothesis.</p>
<p>With <code>exp</code>, the recursive case only references <code>exp (n-1)</code>, so the principle of mathematical induction
(also known as simple induction) is sufficient. But for code which references not just the previous number,
strong induction will be useful in proofs. For example, let us rewrite <code>exp</code> one last time:</p>
<pre><code class="language-sml">(* exp'' : int -&gt; int
 * REQUIRES: n &gt;= 0
 * ENSURES: exp'' n == 2^n
 *)
fun exp'' 0 = 1
  | exp'' 1 = 2
  | exp'' n = exp'' (n-1) + 2 * exp'' (n-2)
</code></pre>
<p>This code is needlessly complicated and inefficient, but it works.
It only exists for us to illustrate strong induction. The recursive case uses both <code>n-1</code> and <code>n-2</code>,
so we'll need strong induction to prove the correctness of <code>exp''</code>.</p>
<p>In addition, <strong>the proof mirrors the code.</strong> What we mean by this is, there should be a different case
for each clause of the function. Our proof would have a base case for both <code>n = 0</code> and <code>n = 1</code>, because
the first two clauses of <code>exp''</code> deal with those cases. Again, we omit the details of proving <code>exp''</code>'s correctness.</p>
<h2 id="list-recursion"><a class="header" href="#list-recursion">List Recursion</a></h2>
<p>Let's first define lists. Here are some examples of <code>int list</code>s:</p>
<pre><code class="language-sml">[1,5,1,5,0]
[42,~42]
[]
</code></pre>
<p>The last one is called the empty list.
We can also build lists containing other types:</p>
<pre><code class="language-sml">[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
</code></pre>
<p>Let <code>t</code> be some type. Intuitively, a value of type <code>t list</code> has a bunch of values of type <code>t</code> inside it (or is the empty list).
We can readily access the first element of the list (also called the <strong><em>head</em></strong>) by pattern matching with
the <code>::</code> operator (pronounced &quot;cons&quot;).</p>
<p>We can build lists using the constructors <code>[]</code> and <code>::</code>. The empty list, <code>[]</code>, is the base case.
The inductive case is <code>::</code>, which is an infix operator that takes in <code>t * t list</code> and creates a <code>t list</code>.
For example, <code>1::[]</code> is the list <code>[1]</code>, and <code>1::[2,3]</code> is the list <code>[1,2,3]</code>. It adds an element to
the front of a list.</p>
<p>The inductive definition of lists means that it's natural to write recursive functions on lists.
We can write a function that computes the length of a list as follows:</p>
<pre><code class="language-sml">(* length : int list -&gt; int
 * REQUIRES: true
 * ENSURES: length L returns the number of values in L.
 *)
fun length [] = 0
  | length (x::xs) = 1 + length xs
</code></pre>
<p>Our function takes in an <code>int list</code>, and outputs an <code>int</code>. For the empty list, we return 0 straight away.
A nonempty list has the form <code>x::xs</code>, where <code>x</code> is the first element of the list, and <code>xs</code> is the rest of the list.
(Perhaps <code>xs</code> means there are many <code>x</code>'s, or it's a homophone of &quot;excess&quot;. We will never know.)
In the recursive case, we calculate the length of the rest of the list by evaluating <code>length xs</code>,
and then add 1 to account for <code>x</code> being in the original list as well.</p>
<p>Now, let's write a slightly more complex function, <code>@</code>, which appends together two lists. It is an infix operator,
and to notate this we write <code>infix @</code>. Here are examples of using <code>@</code>:</p>
<pre><code class="language-sml">[1,2,3] @ [4,5,6] == [1,2,3,4,5,6]
[&quot;s&quot;, &quot;o&quot;] @ [&quot;u&quot;, &quot;p&quot;] == [&quot;s&quot;, &quot;o&quot;, &quot;u&quot;, &quot;p&quot;]
[] @ [] == []
</code></pre>
<p>Here is the implementation:</p>
<pre><code class="language-sml">(* @ : int list * int list -&gt; int list
 * REQUIRES: true
 * ENSURES: A @ B evaluates to a list with 
 * all the elements of A, then all the elements of B
 *)
infix @

fun [] @ B = B
  | (x::xs) @ B = x::(xs @ B)
</code></pre>
<p>Our <code>@</code> function recurses on the left list. If it's empty, we just return the right list.
If it's nonempty, we evaluate <code>xs @ B</code>, and then tack on <code>x</code> to the beginning.</p>
<h2 id="list-induction"><a class="header" href="#list-induction">List Induction</a></h2>
<p>Let's consider proofs by structural induction on lists. Let's say we want to show that some property \( P \)
is true for all values of type <code>t list</code>. It suffices to show the following:</p>
<p><strong>Base case:</strong> \( P( \) <code>[]</code> \() \). In other words, we show the theorem holds for the empty list.</p>
<p><strong>Inductive step:</strong> For any value <code>xs : t list</code>, and any value <code>x : t</code>,
\( P( \) <code>xs</code> \() \implies P( \) <code>x::xs</code> \() \).</p>
<p>For example, if the type <code>t</code> is <code>int</code>, then \( P( \) <code>[1,2]</code> \( ) \) is true because
the base case tells us \( P( \) <code>[]</code> \( ) \), and then one application of the inductive step gets us
\( P( \) <code>2::[]</code> \( ) \), and one more application of the inductive step gets us
\( P( \) <code>1::2::[]</code> \( ) \). Remember that <code>1::2::[]</code> is the same thing as <code>[1,2]</code>.</p>
<h3 id="proving-the-totality-of-length"><a class="header" href="#proving-the-totality-of-length">Proving the totality of <code>length</code></a></h3>
<p>Recall the code of <code>length</code>, which has type <code>int list -&gt; int</code>:</p>
<pre><code class="language-sml">fun length [] = 0
  | length (x::xs) = 1 + length xs
</code></pre>
<p><strong>Theorem:</strong> for all values <code>L : int list</code>, <code>length L</code> evaluates to a value.</p>
<p>In other words, the theorem states that the function <code>length</code> is <strong><em>total</em></strong>.
We'll use <code>==&gt;</code> throughout the proof to denote &quot;steps to&quot;, as we are trying to show <code>length L</code>
evaluates to a value. </p>
<blockquote>
<p>Be careful not to mix up <code>==&gt;</code> and <code>==</code>. For example, <code>4 == 2+2</code> is true
because the expressions are extensionally equivalent, but no compiler in their right mind would
step <code>4</code> to <code>2+2</code>. Therefore <code>4 ==&gt; 2+2</code> is nonsense.)</p>
</blockquote>
<blockquote>
<p>Furthermore, &quot;steps to&quot;, or <code>==&gt;</code>, is very different from \( \implies \). 
<code>==&gt;</code> is used when talking about expressions in SML.
\( \implies \) is not particular to SML, since it's the symbol for logical implication.</p>
</blockquote>
<p><strong>Proof:</strong> We'll use structural induction on <code>L</code>.</p>
<p><strong>Base case:</strong> We prove the theorem when <code>L</code> is <code>[]</code>.</p>
<p><code>length [] ==&gt; 0</code> by clause 1 of <code>length</code>. <code>0</code> is a value, as desired.</p>
<p><strong>Inductive step:</strong> Let <code>xs</code> be some value of type <code>int list</code>.</p>
<p>Induction hypothesis: Assume that <code>length xs</code> evaluates to a value.</p>
<p>Let <code>x : int</code> be an arbitrary value. We want to show that <code>length (x::xs)</code> evaluates to a value.</p>
<p><code>length (x::xs) ==&gt; 1 + length xs</code> (by clause 2 of <code>length</code>)</p>
<p><code>==&gt; 1 + v</code> (by IH, <code>length xs ==&gt; v</code> for some value <code>v</code>)</p>
<p>Now, <code>1 + v</code> evaluates to a value (we assume that SML implements operators like <code>+</code> correctly, and we
do not care about overflow). This concludes the inductive step.</p>
<p>Note how powerful structural induction is! We've proven a fact about <em>all</em> values of type <code>int list</code>
(there are very many such values). To conquer the infinite, we only needed to prove a base case
and the inductive step, due to the inductive nature of lists.</p>
<p>Let's now sketch out a proof that <code>@</code> is total (that is, for all values <code>A : int list</code> and <code>B : int list</code>,
<code>A @ B</code> evaluates to a value). Recall the code of <code>@</code>:</p>
<pre><code>fun [] @ B = B
  | (x::xs) @ B = x::(xs @ B)
</code></pre>
<p>Note that the code of <code>@</code> does not care what the right list, <code>B</code>, looks like!
We only case on whether the left list is empty or nonempty.
As such, it makes sense that a proof about <code>@</code> would use structural induction on the left list, <code>A</code>.
(Again, <strong>the proof mirrors the code</strong>!)</p>
<p>The base case would involve proving <code>[] @ B</code> evaluates to a value, for any <code>B : int list</code>.</p>
<p>The inductive step would roughly be: given an arbitrary <code>xs : int list</code> and <code>x : int</code>, prove that
for all <code>B : int list</code>, the fact that <code>xs @ B</code> evaluates to a value implies that 
<code>(x::xs) @ B</code> evaluates to a value.</p>
<p>We leave the proof's details as an exercise, but they are quite similar to the proof that <code>length</code> is total.
The main difference is we are letting <code>B</code> be an arbitrary value of type <code>int list</code> throughout the entire proof.</p>
<h2 id="takeaways"><a class="header" href="#takeaways">Takeaways</a></h2>
<p>Functional programming lends itself very nicely to recursive code, rather than iterative code.
Induction is a powerful technique for proving theorems about recursive functions.
There are different types of induction, useful for functions on various types.
For natural numbers, we may use simple or strong induction. (Or, we can be fancy
and consider the datatype of natural numbers, <code>nat</code>, and use structural induction.)
For lists and other recursively defined datatypes, structural induction is the way to go.</p>
<blockquote>
<p>Not all proofs about SML code need induction!
Recursion and induction go hand in hand. So, if you were tasked with
proving a theorem on a <em>non-recursive</em> function, there will be no need for induction!</p>
</blockquote>
<p>We also saw how <strong>proofs mirror the code</strong>. Non-recursive clauses in functions (that is,
where the function does not call itself) correspond to base cases in proofs. Recursive clauses
in functions correspond to inductive steps. (When we move into more complex datatypes
than lists, which may have multiple inductive cases, there may be multiple inductive steps!)
The deep connection between recursion and induction is just another example of how
the fields of computer science and mathematics are closely tied.</p>
<h3 id="footnotes-2"><a class="header" href="#footnotes-2">Footnotes</a></h3>
<ul>
<li>[1] SML actually does have mutable data cells called <code>ref</code>s. For this reason, SML is not (strictly speaking) a <em>pure</em> functional programming language. But we primarily program with the parts of SML which are pure, and therefore don't have to worry about <em>side effects</em>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thinking-about-recursion-inductively"><a class="header" href="#thinking-about-recursion-inductively">Thinking About Recursion Inductively</a></h1>
<p><em>By Len Huang, August 2020</em></p>
<p>There's a strong association between mathematical induction and recursion, especially in SML. Often times, we'll be able to use similar vocabularies when describing SML problems and mathematical induction. In particular, we're going to be use the words <strong>base case, induction hypothesis, and induction step</strong> to describe both types of problems.</p>
<h2 id="inductive-intuition"><a class="header" href="#inductive-intuition">Inductive Intuition</a></h2>
<p>Approaching induction proofs can fall along the following line of logic:</p>
<ol>
<li>Solve the <strong>base cases</strong>.</li>
<li>Define the <strong>inductive hypothesis</strong>.</li>
<li>Assume the correctness of the <strong>inductive hypothesis</strong> to show the correctness of the <strong>inductive step</strong>.</li>
</ol>
<p>We can similarly apply this line of logic to solving problems with SML functions! Let's take a look at a common recursive problem. <code>treeSum</code> takes an int tree and returns the sum of all the integers in that tree. By the end of this, we'll be able to implement recursive functions with the following inductive logic:</p>
<pre><code class="language-sml">fun treeSum (Empty : int tree) : int = 0
  | treeSum (Node(L,x,R)) = treeSum(L) + treeSum(R) + x
</code></pre>
<blockquote>
<p>The <strong>base case</strong> for <code>treeSum</code> is that an <code>Empty</code> tree has a sum of 0. Let's define the <strong>inductive hypothesis</strong> to be that for some tree <code>T</code>, that <code>treeSum</code> is correct for its left subtree and right subtree. Define my <strong>inductive step</strong> to be for a tree <code>T = Node(L,x,R)</code>. By the definition of trees, I know that all integers in <code>T</code> are represented by the integers in <code>L</code>, <code>R</code>, and the integer <code>x</code>. If I sum all of these, I will get <code>treeSum(T)</code>. By assuming the <strong>IH</strong>, I can say that <code>treeSum L</code> and <code>treeSum R</code> are correct. Therefore, by math, I will say that <code>treeSum T = (treeSum L) + (treeSum R) + x</code> is correct by the above reasoning. As such, I've shown my <strong>IS</strong> to be correct, and thus the theorem that <code>treeSum T</code> is correct for all <code>T : int tree</code>.</p>
</blockquote>
<h2 id="an-exploration-of-tree-sums"><a class="header" href="#an-exploration-of-tree-sums">An Exploration of Tree Sums</a></h2>
<p>Let's define <code>treeSum</code>. This function should take in an <code>int tree</code> and return the sum of all the integers in that tree.</p>
<pre><code class="language-sml">datatype int tree = Empty | Node of int tree * int * int

fun treeSum (T : int tree) : int = ...
</code></pre>
<p>Note that in SML, the <code>tree</code> datatype is recursively defined. This is a good hint that we should be using recursive/inductive strategies to approach this problem. Consider the proof of the following theorem:</p>
<blockquote>
<p><strong>Theorem:</strong> For all <code>T : int tree</code>, <code>treeSum T</code> is correct.</p>
</blockquote>
<p>Let's not worry about formalizing this proof too much so that we can focus on the <strong>inductive intuition</strong> of it. If we were to prove this using induction, we'll need a <strong>(1) base case, (2) induction hypothesis, and (3) induction step.</strong></p>
<h3 id="1-solving-for-the-base-cases"><a class="header" href="#1-solving-for-the-base-cases">1. Solving for the Base Cases</a></h3>
<p>Let's first think about proving the base case: <code>T = Empty</code>. What does it mean for <code>treeSum Empty</code> to be correct? Well, an <code>Empty</code> tree does not have any nodes, and if there are no nodes, there are no <code>int</code> values. The sum of nothing is 0. Let's write that in a proof-like manner:</p>
<blockquote>
<p><strong>Base Case:</strong> <code>T = Empty</code></p>
<ul>
<li><code>treeSum(Empty) ==&gt; 0</code> because an <code>Empty</code> int tree does not have an int value.</li>
</ul>
</blockquote>
<p>That wasn't so bad! If we have an empty node, we can't have a value there, and so the sum is 0. Before we move on to solving the recursive step, let's tie in this idea of how recursion and induction are related. In our proof, we say that <code>treeSum Empty</code> is correct when it evaluates to 0. Let's use this as an answer to how to define the base case of our function:</p>
<pre><code class="language-sml">fun treeSum (Empty : int tree): int = 0
</code></pre>
<p>Nice job! We've leveraged inductive reasoning to help us define the base case for our recursive problem. Let's move on to something a little harder and may be less obvious than what we've done here.</p>
<h3 id="2-define-the-inductive-hypothesis"><a class="header" href="#2-define-the-inductive-hypothesis">2. Define the Inductive Hypothesis</a></h3>
<p>The next step in our proof is to define the inductive hypothesis. Here, we'll assume the correctness of a smaller part, then use that to prove the correctness of a bigger part. More specifically, we'll be using some ideas of <a href="https://smlhelp.github.io/#todolinktostructuralinductionsection">structural induction</a> for this problem. Let's elaborate more on that:</p>
<blockquote>
<p><strong>Induction Hypothesis:</strong> Assume for all <code>L : int tree</code> and <code>R : int tree</code> that <code>treeSum L</code> is correct and <code>treeSum R</code> is correct.</p>
</blockquote>
<p>Because we've shown our base case to be true, let's assume tha for the recursive structures (the left subtree <code>L</code> and the right subtree <code>R</code>), <code>treeSum</code> is correct. Just like how in induction we can use these nuggets of information to help us prove our <strong>inductive step</strong>, we can do the same to help us solve the SML function.</p>
<h3 id="3-assume-the-inductive-hypothesis-to-show-the-inductive-step"><a class="header" href="#3-assume-the-inductive-hypothesis-to-show-the-inductive-step">3. Assume the Inductive Hypothesis to Show the Inductive Step.</a></h3>
<p>What nuggets of information do we know from the previous step, and how can we use that to help us with inductive step? We assume that both <code>treeSum L</code> and <code>treeSum R</code> are correct by the <strong>inductive hypothesis (IH)</strong>. Since they are correct, their outputs represent the sum of all the integers in them. For <code>treeSum L</code> is the sum of all integers in the int tree <code>L</code> and for <code>treeSum R</code> is the sum of all integers in the int tree <code>R</code>.</p>
<p>We also know that since <code>L</code> and <code>R</code> are the left and right subtrees of <code>T</code>, by definition, they represent all nodes of <code>T</code> (except the root node). Then, to get sum of <code>T</code>, we just need the sum of <code>L</code>, <code>R</code>, and the value of the root node! Let's proof-ify this line of thought a bit more:</p>
<blockquote>
<p><strong>Inductive Step:</strong> <code>T = Node(L,x,R)</code></p>
<ul>
<li><code>treeSum L</code> is correct by <strong>IH</strong></li>
<li><code>treeSum R</code> is correct by <strong>IH</strong></li>
<li>&quot;All integers in <code>T</code>&quot; are represented by &quot;all integers in <code>L</code>&quot;, &quot;all integers in <code>R</code>&quot;, and <code>x</code> by definition of trees.</li>
<li>The sum of &quot;all integers in <code>T</code>&quot; is the sum of &quot;all integers in <code>L</code>, &quot;all integers in <code>R</code>&quot;, and the integer <code>x</code>.</li>
<li><code>treeSum T = (treeSum L) + (treeSum R) + x</code> by definition of <code>treeSum</code>.</li>
<li><code>(treeSum L) + (treeSum R) + x</code> is correct by math and above logic.</li>
<li><code>treeSum T</code> is correct by substitution.</li>
</ul>
</blockquote>
<p>Using the logic needed to complete the proof, we were able to arrive at how to implement our function! Let's translate the above logic into SML:</p>
<pre><code class="language-sml">fun treeSum (Empty : int tree) : int = 0
  | treeSum (Node(L,x,R)) = (treeSum L) + (treeSum R) + x
</code></pre>
<h2 id="qed"><a class="header" href="#qed">QED</a></h2>
<p>And like that, we're able to leverage mathematical induction to help us find the solution to part of an SML function. For some, this intuition is obvious. But for others, it isn't! A deep spiral of pure math and proving every single aspect of your code isn't usually needed. <strong>BUT</strong>, it will definitely be helpful to adopt this style of thinking when approaching more difficult and advanced recursion problems. Whenever you're trying to implement a recursive function in SML, remember to think inductively!</p>
<ol>
<li>Solve the <strong>base cases</strong>.</li>
<li>Define the <strong>inductive hypothesis</strong>.</li>
<li>Assume the correctness of the <strong>inductive hypothesis</strong> to show the correctness of the <strong>inductive step</strong>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tail-recursion"><a class="header" href="#tail-recursion">Tail Recursion</a></h1>
<p><em>By Eunice Chen and Brandon Wu, December 2020. Revised March 2022</em></p>
<p>In programs, functions often make calls to either themselves (recursive calls) or other functions. There are two types of function calls: non-tail calls, and <strong>tail calls</strong>. A function call is called a <strong>tail call</strong> if the caller does not modify or examine the result of the function call.</p>
<p>If every recursive call made by a function is a <strong>tail call</strong>, that function is called <strong>tail recursive</strong>. Put another way, a function is <strong>tail recursive</strong> if the last operation performed by the function is the recursive call.</p>
<p>Suppose we have the following function to sum the elements of a list:</p>
<pre><code class="language-sml">fun sum [] = 0
  | sum (x::xs) = x + (sum xs)
</code></pre>
<p>This function is not tail-recursive, because after the recursive call is evaluated, we add the result to <code>x</code>. Similarly, if we were to case on <code>sum xs</code> or did any other operation on its result, then this function would not be tail-recursive.</p>
<p>In order to write the <code>sum</code> function in a tail-recursive manner, we know that the last computation that we can do is the recursive call to <code>sum</code>. But, we also need some way to keep track of the sum of the list elements and add to it, since we no longer can add things after the recursive call. We will make an accumulator variable, <code>acc</code>, that will keep track of the sum of list elements we have exposed so far, and pass that down through the recursive calls. In our base case, we know we have seen every element in the list and there are no more elements to add, so our base case looks like this:</p>
<pre><code class="language-sml">fun tsum ([], acc) = acc
</code></pre>
<p>In our recursive case, we want to use our accumulator to account for the top element of our list, then pass down that accumulator to the recursive calls. We can do that as follows:</p>
<pre><code class="language-sml">fun tsum (x::xs, acc) = tsum (xs, x + acc)
</code></pre>
<p>Because SML evaluates the function arguments before evaluating the function call, <code>x + acc</code> is performed before <code>sum</code> is called, and then this updated accumulator value is passed down to the recursive <code>sum</code> call on <code>xs</code>. Thus, the last operation performed is the recursive call, making this a tail-recursive function.</p>
<p>Because we now have the accumulator variable, we must pass in <code>0</code> as the accumulator for <code>tsum</code> to behave as expected. In addition, because we have changed the type of <code>sum</code>, we can rewrite the original <code>sum</code> function by using the tail-recursive version as a helper.</p>
<p>Putting these parts together, we have:</p>
<pre><code class="language-sml">fun tsum ([], acc) = acc
  | tsum (x::xs, acc) = tsum (xs, x + acc)

fun sum L = tsum (L, 0)
</code></pre>
<p>Why do we care about tail recursion? One reason is that the tail-recursive version of functions uses less space on the call stack. (The call stack is what keeps track of function calls- in this case, the call stack keeps track of the recursive calls and the work left to do after the recursive calls.)</p>
<p>Consider the following stack trace of the <code>sum</code> function, which is not tail-recursive:</p>
<pre><code class="language-sml">sum [3, 2, 1]
=&gt; 3 + (sum [2, 1])
=&gt; 3 + (2 + (sum [1]))
=&gt; 3 + (2 + (1 + (sum [])))
=&gt; 3 + (2 + (1 + (0)))
=&gt; 3 + (2 + (1))
=&gt; 3 + (3)
=&gt; 6
</code></pre>
<p>In this stack trace, we can see that the sum function takes linear space. (By stack space, we mean the space around the recursive call). Assuming an input list of length <code>n</code>, the stack will have <code>n</code> additions at its largest, giving us a stack of size <code>n</code>.</p>
<p>Now, consider a stack trace of the tail-recursive <code>sum'</code> function:</p>
<pre><code class="language-sml">sum ([3, 2, 1], 0)
=&gt; sum ([2, 1], 3)
=&gt; sum ([1], 5)
=&gt; sum ([], 6)
=&gt; 6
</code></pre>
<p>Notice that the stack trace does not get any wider: we do not need any memory space to store &quot;what is left to do,&quot; so this takes constant space.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's try to turn the function to calculate the nth Fibonacci number into a tail-recursive function.</p>
<pre><code class="language-sml">fun fib 0 = 1
  | fib 1 = 1
  | fib n = fib (n-1) + fib (n-2)
</code></pre>
<p>Note that there are two recursive calls that we add together. In order to be tail-recursive, we can only make one recursive call (if there are two recursive calls, then one must be evaluated before the other, making the first recursive call not a tail call).</p>
<p>What if, instead of computing the nth Fibonacci number, we calculate the <code>n</code>th and the (<code>n-1</code>)th Fibonacci number together? (When <code>n</code> is <code>0</code>, we can just define the (<code>n-1</code>)th Fibonacci number to be <code>0</code>).</p>
<pre><code class="language-sml">fun fib 0 = (1, 0)
  | fib 1 = (1, 1)
  | fib n =
    let
      val (a, b) = fib (n-1)
    in
      (a + b, a)
    end
</code></pre>
<p>This is closer, but we still are doing computation after the recursive call: we add the results of the recursive call to each other, then return. Let's try to use the accumulator idea we had earlier in the <code>sum</code> function, but this time, since we calculate the <code>n</code>th and (<code>n-1</code>)th Fibonacci number, we will pass in two accumulators. Accumulator <code>a</code> will hold the <code>n</code>th Fibonacci number, and accumulator <code>b</code> will hold the (<code>n-1</code>)th Fibonacci number.</p>
<pre><code class="language-sml">fun fib' (0, a, b) = a
  | fib' (n, a, b) = fib' (n-1, a + b, a)
</code></pre>
<p>And if we call <code>fib' (n, 1, 0)</code>, observe that we will indeed get the correct result.</p>
<h1 id="further-practice"><a class="header" href="#further-practice">Further Practice</a></h1>
<p>For even further practice, try to write a tail-recursive function of the list-reversing function on your own.</p>
<pre><code class="language-sml">fun rev [] = []
  | rev (x::xs) = (rev xs) @ [x]
</code></pre>
<h2 id="answers"><a class="header" href="#answers">Answers</a></h2>
<p>If we want to do this tail-recursively, we add an accumulator variable and proceed as usual. If we want to use the same types as the original <code>rev</code> function, we can call our tail-recursive version, as we did in our <code>sum</code> example.</p>
<pre><code class="language-sml">fun trev ([], acc) = acc
  | trev (x::xs, acc) = trev (xs, x::acc)

val rev = fn L =&gt; trev (L, [])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asymptotic-analysis"><a class="header" href="#asymptotic-analysis">Asymptotic Analysis</a></h1>
<p><em>By Brandon Wu, May 2020</em></p>
<p>We have now dedicated a significant amount of discussion towards how to reason about the correctness of programs. Correctness, however, is not the end-all-be-all. In many cases, we would like to be able to think about the <em>complexity</em> of our programs - that is, the amount of resources that it takes to run it on certain inputs. Such resource concerns may include time, space, and energy usage. For the purposes of this book, our principal resource of interest will be <em>time</em>.</p>
<h2 id="the-reality"><a class="header" href="#the-reality">The Reality</a></h2>
<p>It is, however, hopefully clear that this question is rather ill-founded. For one thing, hardware limitations mean that running the same program on different machines may yield differing results, based on the performance ability of individual machines. Indeed, even running the same program on the same machine may yield different results, based on the the computer's current workload. We want a metric that is somehow agnostic to these implementation details, that can give us an idea of how efficient an algorithm is. </p>
<p>Additionally, we are usually not just interested in a program's runtime based on a single input, but its behavior across a wide range of inputs. Additionally, the possibility of infinitely many inputs makes empirical methods like taking an average rather infeasible. Generally, programs also tend to have &quot;worse&quot; inputs than others. It is not necessarily fair to compare the time it takes to compute the millionth Fibbonaci number with the time it takes to compute the second. We will have to do better.</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>We will generally turn to <em>asymptotic analysis</em> to solve these issues. It provides a nice mathematical definition that conveniently takes care of many of the points previously mentioned.</p>
<blockquote>
<p><strong>[Big-O]</strong> We say that a function \( f : \mathbb{R}^+ \rightarrow \mathbb{R}^+ \) is in big-O of another function \( g : \mathbb{R}^+ \rightarrow \mathbb{R}^+ \) (write \( f(n) = O(g(n) \) or \( f(n) \in O(g(n)) \)) if there exist constants \( c, n_0 &gt; 0 \) such that for all \( n \geq n_0 \), \( f(n) \leq cg(n) \). In words, \( f(n) = O(g(n)) \) if there exists a point beyond which \( f(n) \) can be upper bounded by \( g(n) \), amplified by some constant factor.</p>
</blockquote>
<p>In intuitive terms, we can think of a function \( f \) as being in big-O of another function \( g \) if it is &quot;less than or equal to&quot; that function, in terms of the complexity class that it belongs to. For instance, \( 2x \) is \( O(x^2) \), and also \( O(x) \), the former being because a quadratic function grows faster than a linear function by a factor of \( x \), and the latter being because we effectively do not care about constant factors. Note that for that example, we can choose \( c = 2 \), which makes \( f(n) = cg(n) = 2x \), which clearly makes \( f(n) \leq cg(n) \) true.</p>
<p>Asymptotic analysis allows us a convenient notion of what the runtime of a function really is in terms of the <em>size of the input</em>. We will usually define what metric this takes, but common measures include the length of a list, the number of nodes in a tree, or something similar. If we let \( T(n) \) denote the function that maps input sizes to worst-case &quot;runtimes&quot; (that is, \( T(x) \) is the maximum number of steps it takes to run on an input of size \( x \)), then we are usually interested in <em>upper bounding</em> \( T(n) \) - that is, determining what complexity class it falls into. Note, however, that we are simply finding upper bounds - the idea is that this \( T(n) \) function cannot be determined exactly, but its <em>approximate asymptotic behavior</em> can be upper bounded by a different, more defined function. We also care about achieving a <em>tight</em> upper bound - one that is not unnecessarily large. For instance, we could say that <em>many</em> functions are in \( O(2^{2^n}) \) - but this is not particularly useful information. You must be careful to perform analyses without being <em>too</em> liberal.</p>
<p><strong>NOTE:</strong> By &quot;number of steps&quot;, we usually mean some idealized notion of some &quot;step of computation&quot; that an algorithm takes, such as the number of comparisons that it takes to run a quicksort algorithm, or the number of times that we cons an element on or off a list. This lets us abstract away from how long it <em>actually</em> takes a computation to run, ignoring the physical machines used. We only care about the high-level &quot;steps&quot; that an algorithm takes, which is the same regardless of platform.</p>
<p>In a world with an incredible amount of data being processed and transmitted in our daily lives, asymptotic analysis forms a nice metric for the efficiency of algorithms. Most of the specific content that has been discussed so far is beyond the scope of this book, but it is good to have an intuitive understanding of asymptotic analysis nonetheless. </p>
<h2 id="asymptotic-analysis-at-a-glance"><a class="header" href="#asymptotic-analysis-at-a-glance">Asymptotic Analysis at a Glance</a></h2>
<p>Oftentimes, one will have to &quot;eyeball&quot; the complexity of their function or program. This really just amounts to knowing what operations that it executes, and how many times they are executed.</p>
<p>For instance, consider the following function:</p>
<pre><code class="language-sml">fun foo (0 : int) : int = 0
  | foo (n : int) : int = n + foo (n - 1)
</code></pre>
<p>Clearly, this function simply computes the sum of the first \( n \) nonzero numbers upon being given \( n \) as an input. What it does is not important, but if we were to try and quantify the complexity of <code>foo</code>, we might say that it is \( O(n) \) in \( n \), the value of the number given as input. This is because we can consider arithmetic operations to be constant-time (that is, running in \( O(1) \)), and we know that the function should recurse \( n \) times. </p>
<p>But now let us consider how long it might take to run the following code fragment:</p>
<pre><code class="language-sml">fun bar (0 : int) : int = 0
  | bar (n : int) : int = (foo n) + bar (n - 1)
</code></pre>
<p>Now, instead of adding <code>n</code>, each computation in the recursive step instead adds <code>foo i</code>, invoking the previous function. </p>
<p>This becomes slightly harder to eyeball. We can eyeball this as upper boundable by \( O(n^2 \), though we would desire some more justification than just what it &quot;seems to be.&quot; We will need to turn to more sophisticated methods to analyze this more formally, which we will cover in the next chapter. The general idea of estimating complexity, however, is simply to look at programs in terms of their components - how many times instructions run, and what the cost of each instruction's individual cost is. This becomes a very powerful method of reasoning that we will explore more later when we discuss sequences, though we will introduce a way to do so in a slightly more rigorous manner.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.aligncenter {
    text-align: center;
}
</style>
<h1 id="work-and-span"><a class="header" href="#work-and-span">Work and Span</a></h1>
<p><em>By Aditi Gupta and Brandon Wu, May 2020</em>. <em>Revised September 2020</em></p>
<p>We will now turn towards a more robust notion of <em>work</em> and <em>span</em> that let us
analyze our conception of asymptotic runtime more effectively. It is still
dependent on asymptotic analysis, but merely involves being more involved with
how we go about generating the asymptotic bound for a function from the code
itself. Additionally, we will not only analyze the approximate <em>number of steps</em>
of the program (which corresponds to the <em>runtime</em> of the program, given
sequential execution), but also the approximate <em>longest chain of dependencies</em>
that exists in the program, assuming that computations can be run in parallel.
We will elaborate more on this idea in this chapter.</p>
<h2 id="parallel-computing"><a class="header" href="#parallel-computing">Parallel Computing</a></h2>
<p>It is intuitive to view things occurring sequentially. Whether it is reading a
tutorial, writing a list of instructions, or making a plan for the future,
sequential actions are very easy to think about. Even programs are written in a
stepwise manner, with computations happening one after the other in a prescribed
way. It seems to be in our nature to impose some kind of order on a list of
actions.</p>
<p>Despite that, however, sequential evaluation is not always the most <em>efficient</em>.
Sequential evaluation introduces <em>dependencies</em> where other subtasks cannot be
started until we have finished the current subtask, which has the effect of
potentially inducing wait times where none exist. For instance, if your plan is
to do the laundry and your homework, it might not be the most time-efficient to
wait until the washer is done before get started on your work. There is no
dependency between laundry and homework - there is no logical reason why you
should have to wait for one before the other, so you could do them both at the
<em>same time</em>, or in <em>parallel</em>.</p>
<p>Parallel computing is a principle that is becoming more and more important as
time goes on. Computers now more frequently have multiple cores in their
processors, which means that tasks can be subdivided and assigned out to
independent acting agents. </p>
<p>The benefits of doing so are clear. Suppose that we are stacking a shelf with
merchandise. If the shelf is tall, this may take us a while - roughly linear in
the height of the shelf, we can imagine (supposing we have an infinite stock of
items, and that climbing a ladder somehow isn't a factor). If we had a person to
dedicate to each shelf, however, then we could stock the shelves in &quot;constant&quot;
time - independent of the number of shelves that there actually are. This will
be a driving idea behind how we look at parallelism.</p>
<p>While we will not delve into the implementation details of parallel computing
(which is more apt for a systems perspective), we will perform basic analysis of
asymptotic complexity based on that premise. These take the form of <em>work</em> and
<em>span</em>, fundamental ideas that will drive the next section.</p>
<h2 id="theory"><a class="header" href="#theory">Theory</a></h2>
<p>First, let us consider what we will term a <em>task dependency graph</em>. This is not
so important of a concept to memorize, but it will help in conceptualizing work
and span. A task dependency graph is a directed acyclic graph (that is, a graph
whose edges are one-way, and there exist no loops) that represents the
dependencies when trying to perform a set of tasks. Each node is a task,
labelled with the time that it takes to execute it (which is a singular unit,
unable to be reduced otherwise), as well as edges that represent the
dependencies in the graph. Any task cannot be started until all of the tasks
that have edges directed towards it are finished - that is, all of a task's
inbound edges denote its prerequisites.</p>
<p>With this knowledge, we will be able to define what we mean by work and span.</p>
<blockquote>
<p><strong>[Work]</strong> The <em>work</em> of a computation denotes the number of steps it takes to
run, assuming access to only a single processor. Work thus represents the
worst-case sequential evaluation time, and can be upper bounded with
asymptotic analysis.</p>
</blockquote>
<blockquote>
<p><strong>[Span]</strong> The <em>span</em> of a computation denotes the number of steps that it
takes to run, assuming access to infinitely many processors that allow us to
run tasks in parallel. Span thus represents the worst-case parallel evaluation
time, and can be upper bounded with asymptotic analysis.</p>
</blockquote>
<p>What we find is that work directly corresponds to our previous intuition of the
complexity of a computation, since our previous analyses have always been
sequential. Span, however, is not quite as easy to eyeball. Now, we are really
looking for the <em>longest chain of dependencies</em>, that is, the longest sequence
of tasks that <em>must</em> be run sequentially, since everything else can be run
concurrently. Infinitely many processors, while obviously unrealistic, helps to
simplify our analysis, and provides us a &quot;target&quot; for the efficiency of a
<em>fully</em> parallel algorithm.</p>
<p>We illustrate these concepts with the following graph.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/graphTransCropped.png" alt="Process Graph" width="1000"/>
    <figcaption><b>Fig 1.</b> Task dependency graph illustrating dependencies between tasks and task durations</figcaption>
</figure>
<p>So in this example, the work of our graph would be \( 1+3+6+2+5+9+3+3+10 = 42 \),
since with a single processor, the dependencies don't really matter to us. We
have no choice but to complete every task, and the precise order doesn't matter.
That isn't to say that we can execute the tasks in any order, that plainly isn't
true - we simply mean that there is no order that can change what our runtime
is.</p>
<p>On the other hand, for span we must consider the length of the <em>longest path</em>.
The span of this graph would thus be \( 1 + 3 + 6 + 9 + 10 = 29 \), since that is
the longest path. Even being able to execute everything else in a parallel way,
we cannot avoid the fact that these nodes must follow one after the other. This
path is thus the limiting factor in our runtime - ultimately it constrains the
amount of time that we expend.</p>
<p>Task dependency graphs are a concept that we discuss purely for theoretically
being able to understand the idea of work and span. We will look at examples in
terms of actual SML code in the next section, which will be primarily where we
do our work/span analysis.</p>
<h2 id="workspan-analysis-of-code"><a class="header" href="#workspan-analysis-of-code">Work/Span Analysis of Code</a></h2>
<p>The previous example was rather contrived. For one thing, it is <em>prespecified</em> -
we already knew all of the tasks that there were, along with its dependencies
and task times. As such, we could compute a simple, numerical answer. This will
likely not be the case. We are interested in work/span analysis of <em>algorithms</em>,
which will yield us <em>another</em> function - one describing the runtime complexity
of the algorithm as a function of some notion of input size.</p>
<p>For recursive functions, work/span analysis is very easy to do. We characterize
it in terms of <em>recurrence relations</em>, which are themselves recursive functions
describing the work or span of some code. Then, we simply solve for the closed
form of the recurrence relation and estimate a Big-O bound to arrive at our
desired complexity.</p>
<p>Consider the following example:</p>
<pre><code class="language-sml">fun length ([] : int list) : int = 0
  | length (x::xs : int list) : int = 1 + length xs
</code></pre>
<p>The first step to determining the work and span of such a function is to write a
recurrence relation. These steps are explicit - the code should determine the
recurrence relation, and the recurrence relation should determine the Big-O
bound. We will first analyze this function's work complexity, then move on to
span.</p>
<p>First, we should fix some notion of input size. This will differ based on what
our recurrence is recursing on, but in this example it seems to be the size of
the input list. Note that this follows directly from the code - if this were the
factorial function, we may say that the recurrence is in terms of the value of
the input, and as we will later see, if the input was a tree, we may write the
recurrence in terms of the number of nodes in the tree.</p>
<p>So we can write the following recurrence for work. We will explain soon what
exactly it means, and how to arrive at it:</p>
<center> \( W_{length}(n) = c_0 + W_{length}(n-1) \) </center>
<center> \( W_{length}(0) = c_1 \) </center>
<p>This recurrence is made of two parts - the recursive case and the base case. The
first equation for \( W_{length}(n) \) simply denotes what the work for an input
size of \( n \) should be - defined recursively. The second equation for
\( W_{length}(0) \) defines what the work for an input size of \( 0 \) should be.
This directly corresponds to our code, which has two clauses for a list of
length \( 0 \) (that being <code>[]</code>), and for the general case. This is an important
observation to make, that the recurrence follows directly from the code.</p>
<p>The recursive case says that, for an input of size \( n \), the work done is \( c_0 + W_{length}(n-1) \). 
Here, \( c_0 \) denotes <em>some</em> constant. This is supposed to correspond to the recursive case of 
the function, and if we look at it, we have a recursive call <code>length xs</code>, as well as some 
other work of adding one. Adding one, being an arithmetic operation, is a constant-time 
process, meaning that it takes a non-zero constant amount of time. This is what \( c_0 \) is supposed to
represent - the constant amount of non-recursive work that must be done, after
the recursive call has finished. It is not important what \( c_0 \) is, just that
it is some unspecified amount of work that is not a function of \( n \).</p>
<p>Conversely, \( W_{length}(n-1) \) represents exactly the amount of work done by
the recursive call, since it is literally defined to be the amount of work done
by an input of size \( n-1 \), which is exactly what happens when we call <code>length xs</code>, where <code>xs</code> has length \( n-1 \).</p>
<p><strong>NOTE:</strong> Even if we did not have the addition operation, we would still have
\( c_0 \). This is because merely entering the function and figuring out which
case to execute takes some non-zero amount of work - it is impossible to run the
recursive call perfectly with no other time expense. As such, we would see
exactly the same recurrence even if the recursive case was <code>length (x::xs : int list) : int = length xs</code> (which would also be a very bad length function).</p>
<p>For the base case, we have that \( W_{length}(0) = c_1 \), since in the base case
we just return 0. This has a constant amount of work associated with it, as
argued previously, so we use the constant \( c_1 \) to denote that, since the
amount of work is likely not the same constant as that in the recursive case,
when adding 1. </p>
<p>So this is how we arrive at the work recurrence for <code>length</code>. We will now turn
to the span recurrence, which we obtain as:</p>
<center> \( S_{length}(n) = c_0 + S_{length}(n-1) \) </center>
<center> \( S_{length}(0) = c_1 \) </center>
<p>Note that the span recurrence is exactly the same as the work recurrence. This
should make sense, because there is no opportunity for parallelism in the
<code>length</code> function - we can only pop off elements one by one from the list. In
the recursive case, we must wait for the result of the recursive call on <code>xs</code>,
which means we unavoidably must expend the span of \( S_{length}(n-1) \) -
additionally, we have a data dependency. We cannot execute the addition in <code>1 + length xs</code> until we obtain the result for <code>length xs</code>, which means that we must
sum the time it takes to compute <code>length xs</code> (that being \( S_{length}(n-1) \))
and the time it takes to carry out the addition operation (that being \( c_1 \)).</p>
<p>Now we will begin the task of actually solving the recurrence. They are the same recurrence, so without loss of generality we will solve just the work recurrence.</p>
<p>We know that it has the form of \( W_{length}(n) = c_0 + W_{length}(n-1) \), and
eventually reaches a base case at \( W_{length}(0) = c_1 \). We can &quot;unroll&quot; the
recurrence a few times to see if we can see a pattern, and then arrive at our
answer.</p>
<p>So we start out with \( W_{length}(n) = c_0 + W_{length}(n-1) \), but if we invoke
the definition of \( W_{length}(n-1) \), we can produce \( c_0 + c_0 +
W_{length}(n-2) \), since \( W_{length}(n-1) = c_0 + W_{length}(n-2) \). By doing
the same for \( W_{length}(n-2) \), we get \( c_0 + c_0 + c_0 + W_{length}(n-3) \).
It seems we've hit upon a pattern - each time we &quot;unroll&quot; the definition of
\( W_{length}(n) \), for progressively lower \( n \), we get another \( c_0 \) term
back out. Then, we know that the recurrence should eventually solve to:</p>
<center> \( W_{length}(n) = (\sum_{i=1}^n c_0) + c_1 \) </center>
<p>We will usually omit the \( c_1 \), since it does not matter asymptotically. Then, clearly this is equivalent to \( nc_0 + c_1 \). We see that this closed-form solution is linear in \( n \) - so 
then we have that the work and span of this function is in \( O(n) \), which is consistent with what we would expect if we had &quot;eyeballed&quot; it.</p>
<h2 id="workspan-analysis-trees"><a class="header" href="#workspan-analysis-trees">Work/Span Analysis: Trees</a></h2>
<p>First, we will discuss the definition of a binary tree in SML:</p>
<pre><code class="language-sml">datatype tree = Empty 
              | Node of tree * int * tree
</code></pre>
<p>This denotes that a tree is either the constant constructor <code>Empty</code> denoting the empty tree, or a <code>Node</code> that contains an integer value, as well as two <code>tree</code> children, that can themselves be <code>Node</code>s or <code>Empty</code>.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/treeTrans.png" alt="Tree" width="500"/>
    <figcaption><b>Fig 2.</b> Sample binary tree</figcaption>
</figure>
<p>So for instance, we may represent the above tree with <code>Node(Node(Node(Empty, 4, Empty), 3, Empty), 1, Node(Empty, 2, Empty))</code>. Put more fancily:</p>
<pre><code class="language-sml">Node(
    Node(
        Node(
            Empty,
            4,
            Empty
        ),
        3,
        Empty
    ),
    1,
    Node(
        Empty,
        2,
        Empty
    )
)
</code></pre>
<p>Now we will analyze the complexity of finding the size of a tree. Consider the
following implementation for doing so:</p>
<pre><code class="language-sml">fun size (Empty : tree) : int = 0
  | size (Node (L,x,R) : tree) : int = size L + 1 + size R
</code></pre>
<p>First convince yourself that it actually works. It simply recursively finds the
size of the left and right tree, then adds one for the node that it is currently
at. In the empty case, we consider the empty tree to have a size of 0.</p>
<p>The major difference between this function and the previous <code>length</code> function
was that <code>length</code> had one recursive call - <code>size</code> has two. We will need to
reflect this change when we write our recurrences. Additionally, we need a new
variable for our recurrence - we no longer have a list whose length we can
induct on. A similar analogue will be \( n \), the number of nodes in the tree, so
we will take that as our recurrence variable. We will focus first on work.</p>
<p>We will obtain the following work recurrence:</p>
<center> \( W_{size}(n) = c_0 + W_{size}(n_l) + W_{size}(n_r) \) </center>
<center> \( W_{size}(0) = c_1 \) </center>
<p>where we define the number of nodes in the tree \( n = 1 + n_l + n_r \), and
\( n_l \) and \( n_r \) denote the number of nodes in the left and right subtree,
respectively. This follows similarly to our recurrence for <code>length</code> in the
previous part, where <code>c_0</code> is just some constant amount of work that we
necessarily have to do, and the two \( W_{size} \) calls are from the two
recursive calls we make to <code>L</code> and <code>R</code>. </p>
<p>Now, we don't know precisely how big \( n_l \) and \( n_r \) are, with respect to
\( n \). This makes our analysis a little more tricky, but essentially all we need
to do is think of the <em>worst case</em>, as we are interested in the worst-case
asymptotic complexity of this function. For work, however, there is no
worst-case - no matter how the tree is structured, we must visit every node
once, doing a constant amount of work each time. So we should obtain, in the
end, \( W_{size}(n) = nc_0 + c_1 \), which we know is \( O(n) \). So in this case,
we didn't have to think about the structure of the tree. In the next section, it
will matter.</p>
<h2 id="workspan-analysis-balanced-vs-unbalanced-trees"><a class="header" href="#workspan-analysis-balanced-vs-unbalanced-trees">Work/Span Analysis: Balanced vs Unbalanced Trees</a></h2>
<p>We will revisit the same example, except from the perspective of span.</p>
<p>The important point to note is that, now, we have two separate recursive calls
that are happening in the recursive call of <code>size</code>. These recursive calls have
no data dependency - neither running depends on the other. This means that they
can be run in <em>parallel</em>, which means that the total span that we compute should
just be the max over both. This is because we can imagine that both of them lead
to different &quot;paths&quot; in our task-dependency graph - we are only interested in
the maximum-length path. So we will run both results, and whichever one takes
longer to return an answer to us is the &quot;limiting reagent&quot; of our computation.</p>
<p>So we will write the span recurrence as follows:</p>
<center> \( S_{size}(n) = c_0 + max(S_{size}(n_l), S_{size}(n_r)) \) </center>
<center> \( S_{size}(0) = c_1 \) </center>
<p>Now note that we are taking the max over the two recursive calls. Now, we cannot
handwave the structure of the tree like we did in the previous part - if one
path is significantly longer than the other, then it will stall the computation
for longer. We still must visit every node, but some of them can occur in
parallel.</p>
<p>We will consider the first case - if we have an unbalanced tree. Suppose that
the tree is heavily unbalanced - akin to a (diagonal) linked list. Without loss
of generality, let it be &quot;pointing&quot; to the left. Then, \( n_l = n - 1 \), and
\( n_r = 0 \). Then, the max over both recursive calls should clearly be that of
\( S_{size}(n-1) \), since it has to compute the size of a larger tree.</p>
<p>So we can update our recurrence and obtain:</p>
<center> \( S_{size}(n) = c_0 + S_{size}(n-1) \) </center>
<center> \( S_{size}(0) = c_1 \) </center>
<p>This recurrence is exactly the same as that of <code>length</code>, so we know that we will
get that \( S(n) \in O(n) \). This should make sense intuitively, since the depth
of the tree is \( n \), and there are dependencies between each level - we cannot
go to the next level until we are done with the current one. So we cannot avoid
having to visit every level sequentially, which results in \( O(n) \) span.</p>
<p>Now, what if we consider a balanced tree? Well, the balanced case would be if
the number of nodes in the left and right subtrees are roughly equal - that is,
\( n_l = n_r = \frac{n}{2} \). We will consider them exactly equal to simplify our
analysis, but we will obtain the same asymptotic answer. Then, we know that the
maximum is just any one of them, since they will have the same span.</p>
<p>So we can update our recurrence and obtain:</p>
<center> \( S_{size}(n) = c_0 + S_{size}(\frac{n}{2}) \) </center>
<center> \( S_{size}(0) = c_1 \) </center>
<p>This is slightly different than our <code>length</code> recurrence. We will try unrolling
to make sense of this recurrence.</p>
<p>We have that \( S_{size}(n) = c_0 + S_{size}(\frac{n}{2}) \). Plugging in the
recursive definition of \( S_{size}(\frac{n}{2}) \), we get that this expands to
\( c_0 + c_0 + S_{size}(\frac{n}{4}) \), which by the same trick expands to \( c_0+ c_0 + c_0 + S_{size}(\frac{n}{8}) \), 
and so on and so forth. We note that we
are dividing the number of nodes by 2 each time - and we know that we can divide
\( n \) by two roughly \( \log_2(n) \) times. So in total, we can solve the
summation of \( S_{size}(n) \) as \( S_{size} = (\sum_{i=1}^{\log_2(n)} c_0) +
c_1 \).</p>
<p>So then this simplifies to \( S_{size}(n) = \log_2(n)c_0 + c_1 \). This is a
logarithmic function of \( n \), so we get that the span of <code>size</code> is in \( O(\log
n) \). Thus, we obtain a different span for balanced trees versus unbalanced
trees - balanced trees are more efficient and parallelism-friendly.</p>
<h2 id="workspan-analysis-size-dependent-operations"><a class="header" href="#workspan-analysis-size-dependent-operations">Work/Span Analysis: Size-dependent Operations</a></h2>
<p>In these past two examples, we have only seen examples that did a constant
amount of non-recursive work. We will now analyze a function that does
non-recursive work that is a function of the input size \( n \). This will result
in different kinds of recurrences. First, however, we will digress briefly to motivate the example that we will analyze.</p>
<blockquote>
<p><strong>[Case Study: Tree Traversal]</strong></p>
<p>When analyzing trees, it is often prudent to utilize <em>tree traversal</em>, or a
systematic way of enumerating the elements in a tree. There are multiple
different ways to do this, depending on what your intentions are - a few namely
being preorder, inorder, and postorder traversal.</p>
<p>With these different methods of traversal, we can turn a tree into a different
kind of ordered data structure, such as a list or sequence. This can come in
handy when we desire future fast access to any arbitrarily ranked node in the
tree, or if we want to convert it for purposes of printing, for instance.</p>
<p>Each traversal is characterized by a certain &quot;strategy&quot; of traversal, depending
on how it ranks the three possible directions that it can go - root, left, and
right. Inorder traversal, for instance, is characterized by left-root-right
prioritization - this means that it goes left first, and if it can't go left,
then it visits the root node, and otherwise it goes right. Note that this does
not mean that it visits the root of the left subtree first - it simply reruns
the same process on the entire left subtree. No matter what the traversal
strategy is, a node is never actually visited until the &quot;root&quot; action is taken.
Preorder traversal is root-left-right, and postorder is left-right-root.
Examples of preorder and inorder traversals (the most common you will see in
this book) are below.</p>
</blockquote>
<figure class="aligncenter">
    <img src="concepts/../assets/traversals.png" alt="traversal" width="650"/>
    <figcaption><b>Fig 3.</b> An example of a preorder traversal (left) and inorder traversal (right) of a binary tree, with visited nodes labeled in ascending order </figcaption>
</figure>
<blockquote>
<p>Tree traversals can also come in handy when generating different notations for
mathematical expressions when represented in the form of an <em>binary expression
tree</em>, which has nodes that consist of either a <em>numeric constant</em>, which has
no children, a <em>unary operation</em> with a single child, or a <em>binary operation</em>
with two children. For instance, a binary expression tree for the mathematical
expression \( (4-1) * 2 \) is shown below.</p>
</blockquote>
<figure class="aligncenter">
    <img src="concepts/../assets/optree.png" alt="optree" width="500"/>
    <figcaption><b>Fig 4.</b> A binary expression tree for the expression \( (4-1) * 2 \)</figcaption>
</figure>
<blockquote>
<p>With inorder traversal of this expression tree, we can generate the constants
and symbols in exactly the same order as \( (4-1) * 2 \), which is how we would
normally interpret it. Preorder and postorder traversal, however, result in an
interesting interpretation - what is known as <em>prefix</em> (or <em>Polish</em>) and <em>postfix</em> (or <em>Reverse Polish</em>) notation.</p>
<p>In prefix notation, by using preorder traversal, we obtain the expression \( * - 4 1 2 \), which is how we would interpret the same expression if all of our operators appeared before their operands. Similarly, with postorder traversal, we obtain the expression \( 4 1 - 2 * \) in postfix notation. Prefix and postfix notation have significance in their lack of ambiguity - while infix notation is easy for humans to read, it requires parentheses sometimes to denote how operator precedence takes place. Prefix and postfix notation have no such flaw - they are unambiguous in how operations take place. In programming language interpreters, such notations are sometimes used to represent mathematical expressions.</p>
</blockquote>
<p>Such a digression serves as motivation for the next function that we will analyze - which is writing the preorder traversal of a tree in SML. The code looks like this:</p>
<pre><code class="language-sml">fun preord (Empty : tree) : int list = []
  | preord (Node(L, x, R) : tree) : int list = x :: (preord L @ preord R)
</code></pre>
<p>We can readily see that this follows the root-left-right order that we specified
earlier for preorder traversal. Recall that <code>@</code> is the function for list
concatenation, and has a complexity of \( O(n_l) \) in \( n_l \), the size of the
left input list. Thus, as stated before, this function has a non-constant amount
of work at each recursive call - we must evaluate <code>@</code> of the result of <code>preord L</code> and <code>preord R</code>, which is a function of \( n \), the number of nodes in the
tree.</p>
<p>We will analyze only the balanced case for this function. We invite the reader
to think about the unbalanced case on their own.</p>
<p>For the recursive case, we know that \( W_{preord}(n) \) will take the form of 
\( c_0 + W_@(n_l) + W_{preord}(n_l) + W_{preord}(n_r) \). By our balanced assumption, 
we know \( n_l = n_r = \frac{n}{2} \), so we can write our work recurrence as:</p>
<center> \( W_{preord}(n) = c_0 + \frac{n}{2}c_1 + 2W_{preord}(\frac{n}{2}) \) </center>
<center> \( W_{preord}(0) = c_2 \) </center>
<p>Note that the term \( W_@(n_l) \) is a recurrence in terms of \( n \), the size of the left list given as input to <code>@</code>. 
Since we know that the work complexity of <code>@</code> is \( O(n) \), we can replace \( W_@(\frac{n}{2}) \) with \( \frac{n}{2}c_1 \), 
which is simply some constant \( c_1 \), scaled by a linear factor of the input \( \frac{n}{2} \). This is how we will generally 
deal with analyzing the complexity of functions that make use of helper functions.</p>
<p>We will make use of a new method to solve this recurrence - the Tree Method.</p>
<blockquote>
<p><strong>[Tree Method]</strong> The <em>tree method</em> is a method for solving recurrences of certain recurrences that sum to the same quantity across levels, and usually have multiple recursive calls. In essence, if each level has the same amount of computation, then the recurrence solves to the (number of levels) * (amount at each level).</p>
</blockquote>
<p>The below diagram illustrates the Tree Method.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/treemethodTrans.png" alt="Tree method" width="1200"/>
    <figcaption><b>Fig 5.</b> An illustration of the Tree Method for the recurrence of preord.</figcaption>
</figure>
<p>We will now explore exactly how we arrived at this conclusion.</p>
<p>First, note that this tree exists as a result of the recurrence. We used the
code to specify the recurrence, and then the recurrence itself described this
tree. It has a branching factor of 2 (that is, two children of each node that
are non-leaves) since the recursive case of the recurrence has two recursive
calls, and at each level the size of the input changes. Since the recursive
calls are called on inputs of size \( \frac{n}{2} \), each level results in a
division by two of the input size.</p>
<p>Additionally, we know that the amount of work at each node (of input size \( n \))
is necessarily \( c_1 \frac{n}{2} \). There is technically also a \( c_0 \) term,
but we will omit it since it is asymptotically dominated by \( c_1 \frac{n}{2} \).
The precise non-recursive work done by each &quot;node&quot; is specified slightly down
and to the left of each node. Individually, they don't look very nice to sum
over - at level \( i \), it appears the work at each node is \( c_1
\frac{n}{2^{i+1}} \). However, level \( i \) also has \( 2^i \) nodes, by the
branching nature of the recurrence tree. As such, the total amount of work done
at level \( i \) is just \( c_1 \frac{n}{2^{i+1}} * 2^i = c_1 \frac{n}{2} \), which
is not a function of the level \( i \).</p>
<p>As such, each level has the same amount of work - which is very convenient, as
we can now just take that quantity and multiply it by the number of levels. So
in total, when we solve out the recurrence, we should obtain that \( W(n) =
(\sum_{i=1}^{\log_2(n)} c_1\frac{n}{2}) + c_2n \), since the \( c_2n \) term is
separately obtained from the base level, due to the \( n \) leaves that each have
\( c_2 \) work. </p>
<p>The term \( \sum_{i=1}^{\log_2(n)} c_1\frac{n}{2} \) thus goes to \( \frac{c_1}{2}
n\log_2(n) \), so in total we obtain that \( W(n) = \frac{c_1}{2} n\log_2(n) +
c_2n \), which is in \( O(n \log n) \). So we're done.</p>
<p>The tree method is really nothing more than just a visual way to view the
recurrence - it is possible to achieve the same effect by just writing a
summation. It is sometimes more intuitive to try and visualize, however, and for
recurrences where the levels sum to the same amount, the tree method is very
effective. However, not all recurrences exhibit such behavior, and it's hard to
know <em>a priori</em> whether a given recurrence is such a one. Nevertheless, it is a
powerful method and sufficient for many purposes.</p>
<p>We omit the span analysis of this function for the reader.</p>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<p>Asymptotic analysis is a very important technique for attempting to categorize the efficiency of programs. Moreover, it is not enough to simply find the asymptotic <em>sequential</em> complexity of a function - parallel computation is becoming increasingly more important, and purely sequential analyses are not representative of real-world algorithms. Work and span analyzed through recurrence relations form a powerful framework for examining the complexity of recursive functions, which is robust enough to classify many kinds of algorithms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datatypes"><a class="header" href="#datatypes">Datatypes</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<h2 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h2>
<p><em>Main Article</em>: <a href="concepts/poly.html">Parametric Polymorphism</a></p>
<h2 id="recursion-and-induction-1"><a class="header" href="#recursion-and-induction-1">Recursion and Induction</a></h2>
<p><em>Main Articles</em>: <a href="concepts/recind.html">Recursion &amp; Induction</a>, <a href="concepts/treeinduct.html">Tree Induction</a></p>
<h2 id="syntax-and-examples"><a class="header" href="#syntax-and-examples">Syntax and Examples</a></h2>
<h2 id="recursion-and-induction-on-datatypes"><a class="header" href="#recursion-and-induction-on-datatypes">Recursion and Induction on Datatypes</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parametric-polymorphism"><a class="header" href="#parametric-polymorphism">Parametric Polymorphism</a></h1>
<p><em>By Brandon Wu, September 2020</em></p>
<p>Type safety is a very powerful concept, one that lets us pin down the space of
allowable inputs to only a narrow space of values. In this way, we can ensure
that the function is only allowed to be applied to those arguments that we are
interested in, making any other computations illegal. Sometimes, however, we are
interested in making a function more <em>general</em>, with arguments that can somehow
<em>range over types</em>. We will see how SML achieves this with <em>parametric
polymorphism</em>, which is a separate concept than other forms of polymorphism that
you may have seen before.</p>
<h2 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h2>
<p>Suppose that we wanted to write a length function for lists.</p>
<p>Well first, we might want to specify. What <em>type</em> of list? Let's say that we
first have int lists.</p>
<p>Well, the implementation is easy:</p>
<pre><code class="language-sml">fun lengthInt ([] : int list) : int = 0
  | lengthInt (x::xs : int list) : int = 1 + lengthInt xs
</code></pre>
<p>But suppose that we don't only want the length of int lists, but also the length
of string and char lists. Well then, we'll need to define a few more functions:</p>
<pre><code class="language-sml">fun lengthString ([] : string list) : int = 0
  | lengthString (x::xs : string list) : int = 1 + lengthString xs

fun lengthChar ([] : char list) : int = 0
  | lengthChar (x::xs : char list) : int = 1 + lengthChar xs
</code></pre>
<p>This becomes unnecessarily tedious. As we can see, other than the name of the
function and the type annotations, these functions have exactly the same code.
Nothing about the functions themselves make use of the fact that the lists in
question contain ints, strings, or chars - they are merely manipulated as
arbitrary elements. We would like to be able to write a <code>length</code> function that
works on a list of any type.</p>
<h2 id="the-idea"><a class="header" href="#the-idea">The Idea</a></h2>
<p>We've seen something similar to this - we know that lists of all kinds exist. No
matter whether it is an <code>int list</code>, a <code>string list</code>, or a <code>char list</code>, we know
that <code>::</code> is always valid to use when consing an element onto a list of the
appropriate type. Indeed, we say that <code>::</code> has type <code>t * t list -&gt; t list</code> for
all types <code>t</code>. Cons is thus <em>polymorphic</em>, it can be used on many different
types (though never two at the same time, for instance <code>1::[&quot;hello&quot;]</code> is still
ill-typed). </p>
<p>This has been something of an alternative definition for what we will be
discussing in this chapter - parametric polymorphism. Seen in this way, all
polymorphic functions are <em>parameterized</em> by a <em>type variable</em> that ranges over
types. We will go more in depth into this idea.</p>
<blockquote>
<p><strong>[Type variable]</strong> A type variable is a type that is quantified over types -
that is, it can specifically take on the form of many types. They are
enumerated as <code>'a</code>, <code>'b</code>, <code>'c</code>, and so on, and they are referred to by Greek
letters. For instance, <code>'a</code> is &quot;alpha&quot;, <code>'b</code> is &quot;beta&quot;, <code>'c</code> is &quot;gamma&quot;, and
so on.</p>
</blockquote>
<p>Type variables are themselves valid types. As such, we can rewrite <code>length</code> as:</p>
<pre><code class="language-sml">fun length ([] : 'a list) : int = 0
  | length (x::xs : 'a list) : int = 1 + length xs
</code></pre>
<p><code>'a</code> is quantified over all types, so <em>no matter</em> what type the input list to
<code>length</code> is, it will work correctly, as SML will use <em>type inference</em> to
determine what the proper type of the <code>length</code> function should be, in any given
context. Note that <code>'a</code> is a <em>variable</em>, and as always, in proofs, we must
quantify our variables. <code>'a</code> and other type variables thus implicitly correspond
to having a &quot;for-all&quot; quantifier in front of it - so we say that an expression of type <code>'a</code> has type <code>t</code>, for all types <code>t</code>. We further note that this is really syntactic sugar for the notation:</p>
<pre><code class="language-sml">fun 'a length ([] : 'a list) : int = 0
  | length (x::xs : 'a list) : int = 1 + length xs
</code></pre>
<p>This specifies that the length function itself is parameterized over <code>'a</code>.
Although <code>'a</code> is a &quot;parameter&quot; of <code>length</code>, it is not truly an argument - we do
not explicitly pass in the type to <code>length</code>. In an abstract sense, however, we
do, as each &quot;instantiation&quot; of <code>length</code> has been &quot;supplied&quot; an argument to <code>'a</code>
to produce a &quot;copy&quot; of the function. You can think of it as if <code>length</code> has
infinitely many different variations that can be selected, depending on what the
given type is inferred to be. Note that the &quot;type&quot; that is chosen does not
necessarily need to be a concrete type - it may itself compose of type
variables. For instance, consider the following code:</p>
<pre><code class="language-sml">fun tupleLength [] = 0
  | tupleLength ((x, y)::xys) = 1 + length xys
</code></pre>
<p>Disregard the rather strange implementation, which is a rather arcane way of
rewriting <code>length</code> with unnecessary overhead. In this example, we can see that
the list <code>xys</code> contains tuples of two elements, the types of which are unknown
to us. Without knowing a concrete type, we can only conclude that the type of
<code>length</code> is <code>('a * 'b) list -&gt; int</code>. This is because the elements of the tuple
do not necessarily have to be correlated with each other - <code>'a</code> and <code>'b</code> are
thus independent, though they <em>could</em> be instantiated to the same type. As such,
we have taken a type variable and replaced it with two more type variables,
which gives us a little more information but still quite a bit of leeway.
<code>tupleLength</code> is thus itself still polymorphic, with the same type of <code>('a * 'b) list -&gt; int</code>.</p>
<p><strong>NOTE:</strong> We have now reached a point where we will begin to omit explicit type
annotations, as they tend to unnecessarily constrain the types of functions. It
is also a good exercise to be able to understand conceptually how type inference
is carried out, which is covered more in the next section.</p>
<p>An important principle to note, however, is that an <code>'a</code> type does not magically
&quot;just work&quot; with regards to type safety. For instance, let us consider the
following code fragment, which is ill-typed:</p>
<pre><code class="language-sml">fun inc (x : 'a) : int = 1 + x
</code></pre>
<p>Note that, in this case, type annotations have actually worked against us! Had
we removed the type annotations, this code would compile. The reason why this
code is ill-typed is because, while we are allowed to use a type <em>more
generally</em> than it actually is, we cannot use a polymorphic type <em>more
specifically</em>. The reason for this is because if we think about it as if we
explicitly passed in some type variable, in the <em>scope of the function</em> <code>inc</code>,
<code>inc</code> has fixed <code>'a</code> to be some type. It then attempts to add 1 to <code>x</code>, which is
a value of that fixed, arbitrary type. However, we cannot add 1 to a value of
any type - we can only safely add 1 to <code>x</code> if we know that <code>x</code> has type <code>int</code>.
If <code>'a</code> were instantiated to be a <code>string</code>, it would violate type safety to
allow this code to compile. As such, we <em>cannot</em> explicitly type annotate <code>x</code> to
be of type <code>'a</code>, as it is used <em>more specifically</em> than that in the body of the
function.</p>
<h2 id="other-forms-of-polymorphism"><a class="header" href="#other-forms-of-polymorphism">Other Forms of Polymorphism</a></h2>
<p>A similar idea of extending functions to working on many types is exhibited by
<em>equality types</em>, which are a behind-the-scenes process that you have already
been exposed to. Consider the type of the function <code>=</code> - the equality operator.
Clearly, it cannot have type <code>'a * 'a -&gt; bool</code>, since some types don't make
sense to compare for equality. For instance, how would you compare whether or
not a real is equal to another? Machine representations are finite, so asking
the question is bound to introduce problems. Another difficulty is in <em>function
types</em> - determining if two arbitrary functions are extensionally equivalent is
an uncomputable problem (closely related to the Halting Problem). As such, we
would like <code>=</code> to work on a wide spectrum of types, but also not work on
another, also very wide spectrum of types.</p>
<p>To do this, SML has a concept of <em>equality types</em>. The type variable <code>''a</code> (and
<code>''b</code> and <code>''c</code>, as normal) are not quantified over all types, but merely all
equality types. This includes <code>int</code>, <code>bool</code>, <code>string</code>, and any datatype built up
from non-equality types, among others. Thus, the <code>=</code> operator actually has type
<code>''a * ''a -&gt; bool</code>, so as to only work on compatible types. </p>
<p><strong>NOTE:</strong> Note that the polymorphism demonstrated by <code>length</code> is of a different
flavor than that of <code>+</code>, <code>*</code>, or other overloaded functions. The overloading of
basic arithmetic functions to work on ints and reals is more in line with what
might be referred to as &quot;ad hoc&quot; polymorphism, which is merely the compatibility
of a single operator with several possibly heterogeneous implementations, with
the precise implementation being chosen by context (such as type, in this case).
It is thus important to note that while parametric polymorphism identifies a
single, <em>general</em> implementation with many types, ad hoc polymorphism identifies
several different implementations with different use cases. Ad hoc polymorphism
is noticeably more inelegant than parametric polymorphism, but it is useful in
the cases that you only have a small subset of types to extend an operator to.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>During compilation, SML will often need to determine exactly what the type of
the expression that we are looking at. This is not so different of a problem
than type-checking, however. On a high level, SML simply assigns everything a
very general type, and then begins looking at clues from the context so as to
narrow down what the &quot;most general type&quot; is. By &quot;most general type&quot;, we usually
mean the most general type an expression can have, meaning that we do not use
specific instances of polymorphic expressions, but just the polymorphic type
itself. It is valid to say that the <code>length</code> function has type <code>int list -&gt; int</code>, but its most general type is <code>'a list -&gt; int</code>.</p>
<blockquote>
<p><strong>[Type Inference]</strong> A procedure employed by type systems to <em>infer</em> the type
of expressions and functions, even when not explicitly given those types.</p>
</blockquote>
<p>This is how we can, for instance, determine that the function <code>fn x =&gt; x + 1</code>
must have type <code>int -&gt; int</code>. <code>x</code> is not deliberately stated to have any type,
but we know that it wouldn't make sense for <code>x</code> to be any other type than <code>int</code></p>
<ul>
<li>it would otherwise not type-check. Note that <code>x</code> cannot be <code>real</code>, since <code>+</code>
cannot have an input type of <code>real * int</code>.</li>
</ul>
<p>We might also think of it like this - consider the expression <code>fn x =&gt; x + 1</code>.
Most generally, we know that its type should an instance of type <code>'a</code>. Moreover, we see that it is a lambda expression, so it must now be an instance of <code>'a -&gt; 'b</code>. The input is <code>x</code>, so we assign <code>x</code> to be an instance of type <code>'a</code>. We then attempt to apply the <code>+</code> operator to <code>x</code>, so for this to typecheck, <code>x</code> must have type <code>int</code>. The outcome of an <code>int</code> and an <code>int</code> with <code>+</code> should be an <code>int</code>, and that's the entire function body, so the whole expression has type <code>int -&gt; int</code>.</p>
<h2 id="conclusions-1"><a class="header" href="#conclusions-1">Conclusions</a></h2>
<p>Parametric polymorphism offers us a clean and elegant way to extend <em>general
implementations</em> to work across a spectrum of types. In this way, we can still
preserve type safety while allowing us to avoid writing out the same
implementations for many different types. Type inference also conveniently lets
us omit manually determining the type of our code, instead being able to
determine it from context. Ultimately, parametric polymorphism is a simple idea
that offers us a great deal of versatility.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher Order Functions</a></h1>
<p>At this point, we've explored the concept of
computation as <em>evaluation</em>, passing around values and reducing expressions to
values as well. We have seen how we are allowed a great deal of versatility
while maintaining type safety in SML's type system, and how we can construct
arbitrary datatypes to be passed around as <em>first class citizens</em>, that is being
able to be manipulated the same as any other value. We will now discuss what is
considered one of the most powerful tools available in functional programming
languages - that is, the exploitation of <em>functions themselves</em> as values, with
which we can further parameterize our functions and results.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="currying-and-staging"><a class="header" href="#currying-and-staging">Currying and Staging</a></h1>
<p><em>By Brandon Wu, June 2020</em></p>
<p>Suppose that we are interested in writing a function
that adds two numbers. This is fairly simple - this is not a new concept to us.</p>
<pre><code class="language-sml">fun add (x, y) = x + y
</code></pre>
<p>Then this function should clearly have type <code>int * int -&gt; int</code>. We also know
that this notation is really just syntactic sugar for the following:</p>
<pre><code class="language-sml">val add = fn (x, y) =&gt; x + y
</code></pre>
<p>It binds the lambda expression that takes in a tuple of two integers and adds
them together to the identifier of <code>add</code>. Yet with our knowledge of expressions
and values, it is not too outlandish to write the following instead:</p>
<pre><code class="language-sml">fun addCurry x = fn y =&gt; x + y
</code></pre>
<p>What might be the type of this function? Well, we know that <code>addCurry</code> takes in
a value <code>x</code>, which should be an <code>int</code>, since it is summed with <code>y</code>. It then
returns a lambda expression that takes in that same <code>y</code>, and returns the sum,
which is an <code>int</code>. It seems to us that the type should be <code>int -&gt; (int -&gt; int)</code>.
This is an example of a <em>curried</em> function, and one of the first examples we
will see of a <em>higher-order function</em>.</p>
<blockquote>
<p><strong>[Higher-Order Functions]</strong> A <em>higher-order function</em> is a function that
takes in other functions as input, or returns a function as output.</p>
</blockquote>
<blockquote>
<p><strong>[Currying]</strong> Named after mathematician/logician Haskell Brooks Curry,
<em>currying</em> is the act of transforming a function that takes multiple arguments into a
function that returns a function that takes the remaining arguments.
Intuitively, it separates the arguments into a series of function
applications, instead of all at once. We may refer to a general higher-order
function that returns a function as a curried function.</p>
</blockquote>
<p>An important note is that in the type <code>int -&gt; (int -&gt; int)</code>, the parentheses are
unnecessary. This is because type arrows are <em>right-associative</em>, in the same
way that <code>::</code> is. This means that there is already an implicit parentheses in
the type <code>int -&gt; int -&gt; int</code> - the function simply takes in an integer and
returns a function from <code>int -&gt; int</code>. This is thus a separate type than <code>(int -&gt; int) -&gt; int</code>, which is a function that takes in a function from <code>int -&gt; int</code> and
returns an integer.</p>
<p>Note that in the curried example of <code>addCurry</code> we wrote above, this is really
syntactic sugar for the following:</p>
<pre><code class="language-sml">val addCurry = fn x =&gt; fn y =&gt; x + y
</code></pre>
<p>Not being ones to skimp on the syntactic sugar (which perhaps spells danger for
our syntactic blood sugar levels), we can take this one step further. We can
write the exact same declaration in a more concise way, using the form:</p>
<pre><code class="language-sml">fun addCurry x y = x + y
</code></pre>
<p>This thus will curry our arguments for us, when we separate them by a space.</p>
<p>Note that our implementations of <code>addCurry</code> and <code>add</code> are <em>not</em> extensionally
equivalent - for the simple reason that they do not even have the same type!
They do, however, in a sense <em>correspond</em>, in that they seem to do the <em>same
thing</em> - that is, add numbers together. The manner in which they do so is
entirely disparate, however.</p>
<p>It is important to note that currying our functions gives us a notion of
<em>partial application</em>, where we can give a curried function only <em>some</em> of its
&quot;arguments&quot;. This lends us to further specialization and modularity based on the
use case and amount of information available. This is discussed more in the
coming section.</p>
<h2 id="revisiting-extensional-equivalence"><a class="header" href="#revisiting-extensional-equivalence">Revisiting Extensional Equivalence</a></h2>
<p>In previous chapters, we have explored the idea of extensional equivalence, and
constructed a definition for extensional equivalence that covered two cases -
the function case and the non-function case.</p>
<p>We seemed to agree on a meaning that said that, for non-function values, two
values are extensionally equivalent if they are the <em>same value</em>, which is an
perhaps an ill-justified definition that may leave a bad taste in one's mouth,
but ultimately boils down to our intuitive notion that, yes, some values are
just the <em>same</em> and we can't really do much more than question that. For
instance, we can see that <code>(1, 2, &quot;hi&quot;)</code> and <code>(1, 2, &quot;hi&quot;)</code> are the &quot;same&quot;,
and neither are the same as <code>(2, 1, &quot;hello&quot;)</code>. For functions, however, we
decided on a slightly more appeasing definition that defined a function by
its <em>input-output</em> behavior. We restate the definition below:</p>
<blockquote>
<p><strong>[Extensional Equivalence (Functions)]</strong> We say two expressions <code>e : t1 -&gt; t2</code> and <code>e' : t1 -&gt; t2</code> for some types <code>t1</code> and <code>t2</code> are extensionally
equivalent if for all values <code>x : t1</code>, <code>e x</code> \( \cong \)<code>e' x</code>.</p>
</blockquote>
<p>It is our hope that we are now in a place to properly appreciate this
definition. For functions that have type <code>int -&gt; int</code>, this is a fairly
straightforward definition - these functions are extensionally equivalent if,
for every integer that we give them, they return the same int. However, what
about curried functions? Our definition, in light of this new concept, is that
curried functions are extensionally equivalent if <em>the functions that they
return are extensionally equivalent</em>.</p>
<p>No matter how deeply nested this currying takes place, this definition will
suffice. Types must be finite, so we must eventually reach a point where we can
say that values are &quot;the same&quot; (excluding the existence of non-equality types, perhaps).
We can see now that this idea of extensional equivalence is elegantly
compatible with the existence of curried functions, being a recursive definition
much in the same way that the <code>datatype</code>s that we declare or the <code>fun</code>ctions
that we write are.</p>
<h2 id="staging"><a class="header" href="#staging">Staging</a></h2>
<p>With curried functions, we can have much more deliberate control over <em>when</em> a
function does evaluation, particularly with respect to the inputs that it
receives.</p>
<p>Consider an analogy. Suppose you have math homework to do, but you left your
calculator at home. A more lazy-minded student might procrastinate, thinking
that they would only start once they got home, but a more pragmatically-minded
individual might simply start on the problems that don't require a calculator.
The idea of staging is that we can reap efficiency benefits for certain
problems when facing a scarcity of information, by simply doing computations
that require the arguments that are at hand first. We thus make a distinction
between functions that must have all of their arguments to do useful work, and
those who do not.</p>
<p>For instance, take the addition function.</p>
<pre><code class="language-sml">fun add (x : int, y : int) : int = x + y
</code></pre>
<p>This is not a function that we would categorize as being able to do &quot;useful
work&quot; with a single one of its arguments. Even if we were to curry <code>add</code>, with
only one <code>int</code> it can't really do anything but simply wait for the second
argument. In this case, the efficiency benefits are marginal at best. The
computations are somewhat &quot;dependent&quot; - we need access to both arguments in
order to do anything meaningful.</p>
<p>Consider a more contrived example:</p>
<pre><code class="language-sml">(* contrived : int -&gt; int -&gt; int *)
fun contrived x y =
    let
        val z = horrible_computation x (* this takes 3 years *)
    in
        y + z
    end
</code></pre>
<p>The function <code>contrived</code> takes in two arguments <code>x</code> and <code>y</code>. It then performs
some transformation on <code>x</code> using the function <code>horrible_computation</code> (which
takes 3 years to run, unfortunately), and then adds <code>y</code> to the result of that
transformation <code>z</code>.</p>
<p>Suppose that we are interested in computing the results of <code>contrived 4 2</code> and
<code>contrived 4 5</code>, for no reason other than because we can. Then, clearly
evaluation of those two expressions will take 3 years each (per
<code>horrible_computation</code>'s horrible computational nature) - totalling up to six
years! This is far too long, and we want to do better.</p>
<p>One thing that we note is that almost all of the work that we expended in
computing <code>contrived 4 2</code> and <code>contrived 4 5</code> was in evaluating
<code>horrible_computation 4</code>. This computation took us 3 years, but we repeated it
twice! In both of queries we made, we had to compute the exact same thing, which
led to major inefficiencies. The rest of the work of <code>contrived</code> was negligible
compared to the overhead of <code>horrible_computation</code>. It seems that we should be
able to achieve better results.</p>
<p>Consider the following definition instead:</p>
<pre><code class="language-sml">(* contrivedStaged : int -&gt; int -&gt; int *)
fun contrivedStaged x =
    let
        val z = horrible_computation x (* this still takes 3 years *)
    in
        fn y =&gt; y + z
    end
</code></pre>
<p>Now, we have <em>staged</em> <code>contrived</code>. <code>contrivedStaged</code> still has the same type as
<code>contrived</code>, but it behaves slightly differently. It is not too difficult to see
that <code>contrived</code> is extensionally equivalent to <code>contrivedStaged</code>, but we have
made a slightly more optimal change with regards to SML's semantics.</p>
<p>Now, instead of waiting for the second argument <code>y</code> to begin executing
<code>horrible_computation x</code>, <code>contrivedStaged</code> does so immediately after receiving
<code>x</code>. This is clearly better - there was no point to wait for <code>y</code> in the first
place, since <code>horrible_computation</code> does not depend on it. So now we can execute
the following code fragment:</p>
<pre><code class="language-sml">val intermediate = contrivedStaged 4
val ans1 = intermediate 2
val ans2 = intermediate 5
(* takes 3 years in total *)
</code></pre>
<p>We can do this because <code>contrivedStaged 4</code> computes the result of
<code>horrible_computation 4</code>, and then <em>stores the result</em> in the closure of the
function that it returns. This means that, in the scope of <code>intermediate</code>, it
contains the answer that was common to both of the expressions we wrote earlier.
Now, we can execute the step of <code>y + z</code> (which is nearly instantaneous), cutting
our runtime in half. Now, we can obtain the result of <code>contrived 4 2</code> and
<code>contrived 4 5</code> in only 3 years (though to evaluate both of those expressions
themselves would still take 6 years!).</p>
<p>It is important to note that currying is <em>not</em> the same thing as staging.
<code>contrived</code> was curried, but not staged optimally - we made a change that, even
though it had the same type, let us structure our queries in a more optimal
manner. This is an important idea with many applications, such as when building
up a data structure to make queries to, or in graphics when a lot of work must
first be done to preprocess the given data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-hofs-and-partial-evaluation"><a class="header" href="#common-hofs-and-partial-evaluation">Common HOFs and Partial Evaluation</a></h1>
<p><em>By Brandon Wu, June 2020. Revised March 2022</em></p>
<p>In this section, we will explore a number of common higher-order functions that
we will make use of. These higher-order functions embody <em>design patterns</em> that
are common in programming, and represent a <em>generalized notion</em> of a large space
of potential functions that can be made to solve a myriad of problems. This
section focuses on understanding the importance that higher-order functions
offer us through increasing <em>abstraction</em>, as well as <em>modularity</em> in the
structure of our code.</p>
<h2 id="designing-higher-order-functions"><a class="header" href="#designing-higher-order-functions">Designing Higher-Order Functions</a></h2>
<p>Suppose that we are interested in incrementing all the numbers in a list by one.</p>
<pre><code class="language-sml">fun incList [] = []
  | incList (x::xs) = (x + 1) :: incList xs
</code></pre>
<p>This is not too bad to do - we simply need to increment each individual element, and then
simply cons it back on recursively. Suppose further that, as the arithmetically-minded
scholars that we are, we are also interested in negating the sign of each
element in a list.</p>
<pre><code class="language-sml">fun negateList [] = []
  | negateList (x::xs) = (~x) :: negateList xs
</code></pre>
<p>These two look quite similar, which we begin to find unnerving. Hoping to get
away from what is surely a wild coincidence, we try and write a function to take
a list of strings and append the string <code>&quot;\n&quot;</code> to them (which denotes the
newline character).</p>
<pre><code class="language-sml">fun newLineList [] = []
  | newLineList (x::xs) = (x ^ &quot;\n&quot;) :: newLineList xs
</code></pre>
<p>We can't seem to escape!</p>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p>We have seen that these functions we have written all look very similar - they
perform a function on each element of a list, then cons the result back on to
the recursive call so as to perform that operation on <em>every</em> element of the
list. This is a common <em>design pattern</em>, or <em>template</em> for a function that we
want to do a particular thing. For each specific operation we want to perform on
a list, it seems we would have to write the same sort of function each time,
only changing the operation that is performed at the recursive call. To avoid
all that work, we will make use of <em>higher-order functions</em>.</p>
<pre><code class="language-sml">(* map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list *)
fun map f [] = []
  | map f (x::xs) = (f x) :: map f xs
</code></pre>
<p><code>map</code> thus both takes in a function (in this instance, the function <code>f</code>) and is <em>curried</em>, meaning that it itself returns a function. <code>map</code> takes in the
function that you wish to apply to the entire list, and then the list, and then
returns the result of applying that function to every element in the list. In
other words, <code>map f [x_1, ..., x_n] ==&gt; [f x_1, ..., f x_n]</code>.</p>
<p>We also note that <code>map</code> is <em>polymorphic</em>, as we learned earlier, and the
function it takes in has type <code>'a -&gt; 'b</code>, which is the most general function
type. This means that the function we pass in can describe any kind of
transformation on some element, which grants us a great deal of versatility.</p>
<p><code>map</code> <em>describes</em> a pattern, or a <em>family</em> of functions that all follow the same
sort of structure. In the same way that <code>'a</code> is a variable ranging over all
types, where we can describe each type as an <em>instance</em> of <code>'a</code>, we can describe
functions like <code>incList</code>, <code>negateList</code>, and <code>newLineList</code> as being sort of
&quot;instances&quot; of <code>map</code>. Specifically, we have that <code>incList</code> is extensionally
equivalent to <code>map (fn x =&gt; x + 1)</code>, <code>negateList</code> is extensionally equivalent to
<code>map ~</code>, and <code>newLineList</code> is extensionally equivalent to <code>map (fn x =&gt; x ^ &quot;\n&quot;)</code>.</p>
<p>We will now explore some more types of common patterns.</p>
<h3 id="filter"><a class="header" href="#filter">Filter</a></h3>
<p>Quite often, we have a collection of objects and are interested in only some of
them - we want to select those that possess the desired property, and get rid of
those that do not. In other words, we want to <em>filter</em> the list into only those
such elements. The property that we desire, however, could be anything. All we
need to be able to do is say &quot;yes&quot; or &quot;no&quot; at any given item,</p>
<p>This is embodied in the implementation of <code>filter</code>, which abstracts away the
specific property in question.</p>
<pre><code class="language-sml">(* filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list *)
fun filter p [] = []
  | filter p (x::xs) = if p x then x :: filter p xs
                              else filter p xs
</code></pre>
<p>We describe the function <code>p</code> (of type <code>'a -&gt; bool</code>) as a <em>predicate function</em>,
or alternatively <em>indicator function</em>, which simply returns <code>true</code> on those
&quot;yes&quot;-cases and <code>no</code> on &quot;no&quot;-cases. Seen in this way, <code>filter</code> does something
very similar to <code>map</code>, where it takes in the function it needs to apply to the
elements of the list. In the case where the predicate holds, the element is
kept, otherwise the element is discarded.</p>
<p>We could, for instance, obtain all the even integers in a list <code>L : int list</code> by
writing the expression <code>filter (fn x =&gt; x mod 2 = 0) L</code>.</p>
<h3 id="fold"><a class="header" href="#fold">Fold</a></h3>
<p>Map is very useful for performing some kind of transformation on a bulk group of
data, however it retains the &quot;structure&quot; of the list. It maintains the elements
in the same order as they were inputted, and simply transforms each piecewise to
produce a final answer. Sometimes, we are interested in simply achieving a final
result from a collection of data - not another collection of data itself. This
describes a very common pattern known as <em>folding</em>.</p>
<pre><code class="language-sml">(* foldl : ('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b *)
fun foldl g z [] = z
  | foldl g z (x::xs) = foldl g (g(x, z)) xs

(* foldr : ('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b *)
fun foldr g z [] = z
  | foldr g z (x::xs) = g(x, foldr g z xs)
</code></pre>
<p>More specifically, <code>foldl</code> and <code>foldr</code> both describe two ways of combining the
elements in a list, given a function <code>g</code>. The role of <code>z</code> is that of a &quot;base
case&quot; in our accumulated value, so that we have an initial point to start from
when using the function <code>g</code>. The result of <code>foldl g z [x_1, ..., x_n]</code> is to
evaluate to <code>f(x_n, ..., f(x_2, f(x_1, z))...)</code>, and the result of <code>foldr g z [x_1, ..., x_n]</code> is to evaluate to <code>f(x_1, ..., f(x_n-1, f(x_n, z))...)</code>. We are
thus choosing whether we want to fold from the <em>left</em> of the list or the
<em>right</em>.</p>
<p><strong>NOTE:</strong> One way to remember which way that that each respective <code>fold</code> goes is
to identify the corresponding side (left or right) as being the side of the most
<em>deeply nested</em> element in the functions. As such, since <code>x_1</code> is the most
leftmost element, <code>foldl</code> has <code>f(x_1, z)</code> as its innermost component, whereas
since <code>x_n</code> is the most rightmost element, <code>foldr</code> has <code>f(x_n, z)</code>.</p>
<p>Use cases for <code>fold</code> include if you wanted to turn a list of strings into a
single string, which you could accomplish with <code>foldr (op^) &quot;&quot;</code>, or if you wanted
to sum the elements of a list, which could be done with <code>foldl (op+) 0</code>. Note that
in the case of summing a list, <code>foldr</code> would work too - this is because <code>+</code> is
an <em>associative</em> function, meaning that it does not matter which order you
evaluate it in (or in proper terms, \( f(x, f(y, z)) \cong f(f(x, y), z) \), for
all \( x, y, z \)).</p>
<p>For many purposes, it will be the case that your <code>z</code> will be some <em>identity</em>
value, such as <code>0</code> for summing a list, or the empty string for concatenating all
the strings in a list. This does not always have to be the case. One of the
strengths of the implementation is that we can <em>specify</em> what our <code>z</code> is, and
tailor that to our needs. For instance, if we wanted to append a <code>&quot;\n&quot;</code> to our
string concatenation, we could use <code>foldr (op^) &quot;\n&quot;</code>. Fold offers us a great
deal of flexibility with choosing how we want to reduce a list.</p>
<p>It is somewhat important to note the type of the function <code>g</code> here. It has type
<code>'a * 'b -&gt; 'b</code>, where <code>'a</code> is the type of the elements in the list that we are
folding, and <code>'b</code> is the type of the initial accumulator and output. It is useful to
think of this <code>'b</code> type as the type of the <code>fold</code> function's &quot;accumulator&quot;, or
the information that it stores as it proceeds along its computation. In the case
of <code>foldl</code>, this accumulator at a given point along the list is simply the
folded value of the all the elements to the left - and in <code>foldr</code>, it is the
folded value of all the elements to the right. The polymorphic nature of this
accumulator becomes a major strength, as we can &quot;carry along&quot; any kind of
information that we like, so long as we define how it changes when we receive a
new <code>'a</code>-typed element from the list that we are folding.</p>
<p>So, for instance, the accumulator in <code>foldl (op+) 0</code> is simply the sum of all
the elements to the left of any given point. The accumulator of <code>foldr (op^) &quot;&quot;</code>
is the concatenation of all of the strings to the right of a given point (which
I hope makes apparent why <code>foldr</code> is the right fold for the task, as opposed to
<code>foldl</code>!).</p>
<h2 id="compose"><a class="header" href="#compose">Compose</a></h2>
<p>One of the major examples that we used to motivate totality was that of
<em>function composition</em>, the classic example being \( f(g(x)) \), for some
functions \( f \) and \( g \). This is a very common idea, where we have some form
of data that we would like to put through a series of transformations. If our
transformations are inherently disparate (such as being bound to identifiers of
different functions), we may have to write code that looks like <code>f1 (f2 (f3 (f4 (f5 x))))</code>. However, this can only happen if we <em>already have access to the
element x</em>. So then, what happens if we want to give a name to the <em>process</em> of
applying <code>f5</code>, then <code>f4</code>, then <code>f3</code>, then <code>f2</code>, and then <code>f1</code>?</p>
<p>We could, of course, write the lambda expression <code>fn x =&gt; f1 (f2 (f3 (f4 (f5 x))))</code>, however that still can be rather ugly. There is an entire style of
programming (named <em>point-free</em>, or <em>tacit</em> programming) that tries to eliminate
the deliberate identification of the arguments to functions, instead making use
of <em>combinators</em>. In a similar flavor, we would like to eliminate the explicit
need to construct the lambda expression that takes in the input <code>x</code>. We might
then call back to another common mathematical operator, that being of <em>function
composition</em>, or <code>o</code>.</p>
<pre><code class="language-sml">infix o
(* o : ('b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; ('a -&gt; 'c) *)
fun f o g = fn x =&gt; f (g x)
</code></pre>
<p>Note that the types are constrained to permit the &quot;compatibility&quot; of the
functions <code>f</code> and <code>g</code>. The input type of <code>f</code> can be general, as well as the
output type of <code>g</code>, but the output type of <code>g</code> must match the input type of <code>f</code>.
In this way, we can &quot;string along&quot; a series of functions in order to produce a
single function that performs the &quot;pipeline&quot; of transformations that we desire.</p>
<p>So, for instance, we could write the function that, given a tree of integers,
sums all of the elements in the tree by simply writing <code>sum o inord</code>. We could,
of course, simply write <code>treeSum</code>, however this idea is generalizable to more
complicated sequences of transformations.</p>
<h2 id="partial-evaluation-and-modularity"><a class="header" href="#partial-evaluation-and-modularity">Partial Evaluation and Modularity</a></h2>
<p>At this point, we have seen several examples of common higher-order functions,
as well as potential use cases. These use cases often look nothing alike, but
they all share a fundamental similarity in their <em>structure</em>, which is specified
by the given higher-order function.</p>
<p>A key strength of higher-order functions lies in <em>partial evaluation</em>, where we
can use higher-order functions to further derive other functions (and possibly
higher-order functions, themselves). It is fine for, in the case of finding the
sum of a single list <code>L</code>, to simply evaluate <code>foldr (op+) 0 L</code>, but in the general
case it is a strength that we can bind the function <code>foldr (op+) 0</code> to the name
<code>sum</code>. This comes in handy especially if we want to sum over <em>many</em> lists, so
that we don't continuously have to compute the result of <code>foldr (op+) 0</code> (though it
has negligible computational cost, admittedly).</p>
<p>Seen in this way, it is as if higher-order functions are at the root of a large
<em>tree</em> of potential functions, where each node in the tree is an
increasingly-specialized function, until we arrive at some specific use case.
This makes higher-order functions <em>modular</em>, as we can simply &quot;mix-and-match&quot;
the arguments to HOFs such as <code>map</code> or <code>fold</code> until we arrive at the specific
tools that we need.</p>
<p>This is only an example of the way that abstraction and modularity grant us
strength in programming. Through abstracting away even the specific operations
that programs carry out, we can &quot;capture&quot; a large amount of potential functions
that we may write.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Programs inherently are composed of a series of <em>steps</em>. Depending on the
context, syntax, and semantics of the programming language in general, we arrive
at a certain <em>prescribed order</em> in which instructions are executed (at least for
sequential programs). It is often the case that, according to small differences
in state or environment, <em>control</em> may be affected, causing different
instructions to be executed. In this chapter, we will discuss two control flow
constructs, namely continuations and exceptions, that can allow us to more
easily and cleanly write functions that need to have complex control flow
behavior, or in other words, complicated decision-making.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.center{
    display: block;
    margin-left: auto;
    margin-right: auto;
}
figure figcaption {
    text-align: center;
}
</style>
<h1 id="continuation-passing-style"><a class="header" href="#continuation-passing-style">Continuation Passing Style</a></h1>
<p><em>By Brandon Wu, June 2020. Revised March 2022</em></p>
<p>We have seen how we can write functions that are <em>tail recursive</em>, in that they
only make recursive calls as <em>tail calls</em>, where the recursive calls is the last
thing that the function does (i.e. there is no deferred work). This commonly was
realized by implementing the tail-recursive function with an <em>accumulator</em>,
which simply stored the intermediate values that were computed. In this section,
we will explore an concept known as <em>continuation-passing style</em>, which sees the
use of <em>functions as accumulators</em>, which lets us use more explicit logic when
encoding the control flow of our programs, as well as the intermediate results
of our computations.</p>
<h2 id="continuation-passing-style-the-idea"><a class="header" href="#continuation-passing-style-the-idea">Continuation Passing Style: The Idea</a></h2>
<p>Consider the computation of <code>(2 + 3) * 4</code>.</p>
<p>Clearly, there is an ordering to how we should evaluate this. We should sum <code>2</code>
and <code>3</code> first, then take the <em>result of that</em> and multiply it by <code>4</code>. There is
kind of a catch here, that is quickly glossed over by our human brains - we
refer to &quot;the result of that&quot; rather casually. We haven't explicitly named it,
but we nonetheless make an appeal to intuition to get our point across.</p>
<p>How else might we represent this computation? Well, we could use lambda
expressions, and then use the power of function application to compute the
result. Then, we might obtain that this is akin to evaluating <code>(fn res =&gt; res * 4) (2 + 3)</code>. This would be a more direct translation of the idea of &quot;add 2 and 3,
then pass the result of that to 4&quot;. We note that, in the process, we have
explicitly made clear what we mean by &quot;the result of that&quot; - it is now bound to
a name, that being <code>res</code>.</p>
<p>We can take this one step further. If we think about it a bit more, we might
want to consider starting at a &quot;single&quot; value, so that we don't have to consider
the operation of <code>2 + 3</code> as one step. Then, we might instead write &quot;take 2, add
the previous result to 3, and then multiply the previous result by 4&quot;. Clearly,
we have now made it deliberate that we are passing around a <em>single value</em> that
we are performing operations on at each step. How would we write this as a
lambda expression, however?</p>
<p>We might write <code>(fn res =&gt; (fn res2 =&gt; res2 * 4) (res + 3)) 2</code> to encode the
previous instructions. This essentially makes <code>res</code> the <em>first</em> &quot;previous
result&quot;, and then the result of <code>2 + 3</code> is <code>res2</code>, the <em>second</em> &quot;previous
result&quot;. Make sure you understand what is happening here - we are binding <code>2</code> to
the identifier <code>res</code>, then binding the result of <code>res + 3</code> to the identifier
<code>res2</code>.</p>
<p>However, it is still on us to provide the value of <code>2</code>. We to somehow encode the
notion of the <em>computation</em> of <code>(2 + 3) * 4</code>, not necessarily evaluating the
expression ourselves. We know that placing an expression within the confines of
a lambda expression will &quot;freeze&quot; the computation, causing it to only resume
once the lambda expression is given an input, so what we can do is simply do the
same with a trivial input. Our trivial input here will be <code>()</code>, or unit, since
we always have access to it, and there is only one value of type <code>unit</code>.</p>
<p>So somehow, we can encode the idea of this expression with <code>(fn () =&gt; (fn res =&gt; (fn res2 =&gt; res2 * 4) (res + 3)) 2)</code>. Seen in this way, we have somehow encoded
the desired expression not by actually executing it, but forming some large
function <em>a priori</em> that essentially does the same thing. We thus form a correspondence between evaluating an expression by <em>carrying out each step in real time</em> and by <em>writing out the steps to be done at a later time</em>. We hope to show that two are really equivalent - this will be important to understand for later.</p>
<h2 id="continuation-passing-style-a-case-study"><a class="header" href="#continuation-passing-style-a-case-study">Continuation Passing Style: A Case Study</a></h2>
<p>We will now discuss continuation passing style more explicitly.</p>
<p>It is hopefully clear that the previous example of <code>(fn () =&gt; (fn res =&gt; (fn res2 =&gt; res2 * 4) (res + 3)) 2)</code> encodes, in some form, the <em>idea</em>
of the computation of the expression <code>(2 + 3) * 4</code>. Somewhat key, however, is
that computation <em>does not execute</em> until we actually feed a unit to it. It is
important to note the distinction between <em>doing something</em> and <em>writing the
instructions to do something</em>. A continuation can be thought of as a
<em>blueprint</em>, or a <em>contingency plan</em>. We will expand more on what we mean by
this shortly, but a continuation essentially represents <em>what instructions need
to be executed</em>. This is a very powerful idea, because programs can continuously
alter continuations by adding more instructions or even executing different
continuations in order to determine what computations ultimately need to be
executed.</p>
<p>We will first consider a simple example before going into the definition.</p>
<pre><code class="language-sml">(* factCPS : int -&gt; (int -&gt; 'a) -&gt; 'a *)
(* REQUIRES: true *)
(* ENSURES: factCPS n k ~= k (n!) *)
fun factCPS 0 k = k 1
  | factCPS n k = factCPS (n-1) (fn res =&gt; k (n * res))
</code></pre>
<p>Here, <code>factCPS</code> takes in two arguments - one is the counter for the factorial
function (as normal), and the other is the <em>continuation</em>. In this case, the
continuation is a function from <code>int -&gt; 'a</code>. The idea here is that the
continuation should represent what work is <em>left to do</em>. It is left polymorphic,
however, in order to give the user control over what they want the function to
do. In order to compute the factorial of <code>n</code> directly, one could just evaluate
<code>factCPS n Fn.id</code>, however we grant more versatility to the user in that they
are not <em>just</em> constrained to computing the factorial. If one wanted a textual
representation of the factorial of <code>n</code>, they could evaluate <code>factCPS n Int.toString</code>, for instance. This way, we get additional versatility out of our
implementation.</p>
<p>We will now consider a trace of <code>factCPS 3 Int.toString</code> to fully understand the
mechanism by which it works.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/cps.png" alt="CPS Trace" width="1500"/>
    <figcaption><b>Fig 1.</b> Code trace of the evaluation of `factCPS 3 Int.toString` </figcaption>
</figure>
<p>As we can see, this code trace does correctly result in <code>Int.toString 6</code>, which
is our desired result. Of particular interest to our analysis is the
<em>continuation</em> of the function, which seems to grow with every line through
<code>factCPS</code>'s recursion, until ultimately being reduced down step-wise until it
yields our final result. </p>
<p>The colors in the image denote the difference between the <em>current</em> value of <code>k</code>
and the new, <em>constructed</em> k. For instance, <code>k</code> is originally <code>Int.toString</code>
(which is the blue-colored text), however it is eventually wrapped in <code>(fn res =&gt; ... (3 * res))</code>, which is the RHS of the call to <code>factCPS 3 Int.toString</code>.
Thus, the &quot;inner&quot; <code>k</code> in the third line is in orange, to signify that it is in
fact the same as the entire continuation from the previous line (also in
orange), which is the &quot;previous&quot; <code>k</code>. Seen in this way, all that each recursive
call seems to be doing is appending a layer to the continuation, while the
inside remains the same.</p>
<p><strong>NOTE:</strong> The definition of <code>factCPS</code> says that the input to each lambda
expression should be named <code>res</code>. In order to make understanding clearer and
avoid namespace collisions, we have opted to name it <code>res</code>, <code>res2</code>, and <code>res3</code>,
on each recursive call to <code>factCPS</code>. Note that this renaming does not affect the
evaluation of <code>factCPS 3 Int.toString</code> and does keep it exactly equivalent to
how it is actually evaluated<a href="concepts/cps.html#footnote1"> <sup> [1] </sup> </a>.</p>
<p>So hopefully now we are convinced of <code>factCPS</code>'s correctness<a href="concepts/cps.html#footnote2"> <sup>[2]</sup> </a>. What might not be evident, however, is <em>why</em>. </p>
<p>Recall our previous metaphor with regards to writing down instructions. It is
hopefully not too difficult to see that this large lambda expression that we are
constructing is akin to writing down instructions - we specify the operations
that should occur when it is ultimately &quot;collapsed&quot; (by being given an input
value), but nothing actually occurs until then. It merely encodes that
information in the meantime. The next diagram will attempt to more specifically
show this relationship between the &quot;instructions&quot; and how it arises from the
definition of <code>factCPS</code>:</p>
<figure class="aligncenter">
    <img src="concepts/../assets/updown.png" alt="Instructions" width="1500"/>
    <figcaption><b>Fig 2.</b> Relationship between an arbitrary recursive call of `factCPS` and the "instructions" that it writes down. </figcaption>
</figure>
<p>The middle of this image is supposed to denote the &quot;instructions&quot; that you might
write if you were to codify the algorithm to determine the factorial of \( n \).
Note that these instructions are actually read from bottom to top - thus, we
start with 1 and then work out way up multiplying until we reach \( n \), which
presumably should give us the actual factorial. </p>
<p>Now consider if we were at some arbitrary point of execution of the expression
<code>factCPS n initK</code>, for some arbitrary <code>initK : int -&gt; 'a</code>. That is, suppose that 
<code>factCPS n initK</code> has reduced down to <code>factCPS i k'</code>, for some other <code>k</code> (which 
is the result of modifying the continuation throughout the recursive calls of 
<code>factCPS</code> until now. Then, we should see that the form of <code>k</code> should look something 
like <code>(fn res =&gt; (fn res2 =&gt; ... (fn resn =&gt; initK (n * resn)) ... ((i + 2) * res)) ((i + 1) * res))</code>. That is, it exactly captures the idea of the instructions in
orange - it covers the multiplication of all of the terms from \( i+1 \) to \( n \). </p>
<p>What is the action of the recursive call <em>at</em> <code>factCPS i k</code>? Well, clearly it
should reduce to <code>factCPS (i-1) (fn res =&gt; k (i * res))</code> - that is, it wraps <code>k</code>
in the lambda expression <code>(fn res =&gt; k (i * res))</code>, which is just the
&quot;instruction&quot; to multiply the result by <code>i</code>, which exactly corresponds to the
instruction in blue.</p>
<p>How do we compute the rest of the factorial function? Everything seems correct
so far, but that is all that we will have in our accumulation of <code>k</code>. The rest
of the instructions are exactly corresponding to the recursive call - to
<code>factCPS i</code> itself. <code>factCPS i</code>, as the recursive call, will continue to go and
compute the factorial all the way down to 0. Thus, even though we have not
written them down yet, we can use the &quot;recursive leap of faith&quot; to <em>assume</em> that
<code>factCPS i k</code> will behave properly, and write down the instructions for
multiplying <code>i-1</code> through <code>1</code> properly, which will result in the final, correct
result.</p>
<p><strong>NOTE:</strong> An equivalent, but also very <em>important</em> way to view CPS functions is
that recursive calls <em>pass their result</em> to their continuation. For instance, as
we have defined, <code>factCPS n k</code> should be extensionally equivalent to <code>k (fact n)</code>, or in other words, <code>factCPS n k</code> will be the same as passing the actual
factorial of <code>n</code> to <code>k</code>. This means that when we are writing our function, we
can make that assumption - <code>factCPS (n-1) (fn res =&gt; k (n * res))</code> should pass
the result of \( (n-1)! \) to <code>(fn res =&gt; k (n * res))</code>. This is equivalent to, in
our &quot;instructions&quot; analogy, saying that <code>factCPS i k</code> should faithfully execute
all the instructions of multiplying from <code>1</code> to <code>i</code> - that is, <code>factCPS i k</code>
should pass the result of \( i! \) to <code>k</code>.</p>
<p>So now, we can sort of inductively see how <code>factCPS</code> writes down the entire page of
instructions, which should mean that it is correct when we execute it. This is
not an inductive proof in itself, but this should give the intuition for <em>why</em>
it does work.</p>
<p>An additional way to think about CPS functions is that they behave similarly to
a <em>stack</em>. This is because, as we have seen, we are continuously wrapping lambda
expressions with other lambda expressions - we can only &quot;pop&quot; off a lambda
expression by evaluating it with an argument, or &quot;push&quot; on more instructions by
wrapping our continuation in more lambda expressions. We cannot access the ones
inside. As such, we could visualize the evaluation of <code>factCPS 3 k</code>
as the following diagram:</p>
<figure class="aligncenter">
    <img src="concepts/../assets/stack.png" alt="CPS Stack" width="1500"/>
    <figcaption><b>Fig 3.</b> A visualization of the "stack" of instructions created by evaluating `factCPS 3 k`. </figcaption>
</figure>
<p>We would build this stack up from the bottom by first putting our <code>k</code> on (as our
&quot;original&quot; <code>k</code>), then wrapping it in more lambda expressions as we go along the
recursive calls (so, for instance, the orange brick is added by <code>factCPS 3 k'</code>, and
the red brick is added by <code>factCPS 2 k''</code>, for their own respective continuations
<code>k'</code> and <code>k''</code>). Then, once we are at the end, our &quot;instruction stack&quot; looks
like the one currently pictured. At that point, we have nothing left to do but
execute the stack of instructions with an initial value of <code>1</code>, which will cause
the bricks to start being popped off one by one, and then ultimately result in the 
value of <code>6</code> being applied to <code>k</code>. </p>
<p>Another, equivalent way to view continuations is as <em>donuts</em>.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/donut.png" alt="CPS Donut" width="1500"/>
    <figcaption><b>Fig 4.</b> An artist's rendition of the "CPS Donut" of instructions created by evaluating `factCPS 3 k` (colorized, 2020). </figcaption>
</figure>
<p>As you can see, we cannot access the inner layers of the CPS Donut without first
biting through the outer layers (corresponding to our evaluation of the outer
layers first). One can only imagine what it would taste like in real life.</p>
<p><strong>NOTE:</strong> It is not important to be able to draw these examples, or parrot them
verbatim. They are merely here to try and provide some intuition as to what is
happening with CPS. It is very important to be able to understand <em>why</em> it is
that CPS functions work, which may be rather daunting and hard-to-grasp at
first.</p>
<h3 id="footnotes-3"><a class="header" href="#footnotes-3">Footnotes</a></h3>
<p><a id="footnote1"> [1]: In fact, it is
<a href="https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence"><em>alpha equivalent!</em></a> </a></p>
<p><a id="footnote2"> [2]: Though perhaps we should not be, until we write a full inductive proof of correctness! </a></p>
<h2 id="continuation-passing-style-the-definition"><a class="header" href="#continuation-passing-style-the-definition">Continuation Passing Style: The Definition</a></h2>
<p>We are now ready to attempt a definition of continuation passing style.</p>
<blockquote>
<p><strong>[Continuation]</strong> A <em>continuation</em> is a function that specifies what is
supposed to be done with the result of a computation.</p>
</blockquote>
<blockquote>
<p><strong>[Continuation Passing Style]</strong> A function is said to be written in
<em>continuation passing style</em> if it satisfies the following conditions:</p>
<ol>
<li>
<p>It takes in and uses continuation(s).</p>
</li>
<li>
<p>It calls functions with continuations (including itself) as tail calls.</p>
</li>
<li>
<p>It can only call its continuations in tail calls.</p>
</li>
</ol>
<p>The key characteristic of CPS functions is that they are generally written
with the goal of <em>passing their results to their continuations</em>. These
continuations specify what computations should occur next.</p>
</blockquote>
<p>First, take a moment to assure yourself that the implementation of <code>factCPS</code>
that we have so deeply studied <em>is</em>, in fact, in continuation passing style<a href="concepts/cps.html#footnote3">
<sup> [3] </sup></a>.</p>
<pre><code class="language-sml">fun factCPS 0 k = k 1
  | factCPS n k = factCPS (n-1) (fn res =&gt; k (n * res))
</code></pre>
<p>As we have seen, clearly <code>k</code> is <code>factCPS</code>'s continuation, and it does call it in
tail calls (as well as itself). This seems consistent with our definition. </p>
<p>An important corollary of this definition is that a CPS function <em>cannot case on
a recursive call to itself</em>. So, for instance, making a recursive call to a CPS
function to see if it succeeds, then taking some action based on that premise is
illegal. You may not fully understand what that means at the present, but we
will explore this idea more in the future.</p>
<p>A somewhat interesting note is that every direct-style (which is how we will
term the kinds of functions that we have written until now) function admits a
continuation passing style implementation. This means that continuation passing
style is nothing arcane, but it is merely a <em>different way of viewing
computation</em>. Functions written in continuation passing style can have
significant performance benefits when compared to their direct style
counterparts, so there are reasons to use continuation passing style other than
just for the sake of it. </p>
<h3 id="footnotes-4"><a class="header" href="#footnotes-4">Footnotes</a></h3>
<p><a id="footnote3"> [3]: Otherwise, you should be quite concerned about the competency of the author, and you would probably be better off reading a different help site.</p>
<h2 id="continuation-passing-style-a-case-study-v20"><a class="header" href="#continuation-passing-style-a-case-study-v20">Continuation Passing Style: A Case Study v2.0</a></h2>
<p>We will now explore an example of a CPS function that makes use of some concept
of limited <em>backtracking</em>, or <em>checkpointing</em>. Somewhat key to this example is
that it writes down not just <em>one</em> instruction at each recursive call, but
<em>multiple</em>.</p>
<pre><code class="language-sml">fun treeSumCPS Empty k = k 0
  | treeSumCPS (Node (L, x, R)) k = 
  treeSumCPS L (fn leftSum =&gt; treeSumCPS R (fn rightSum =&gt; k (leftSum + x + rightSum))
</code></pre>
<p>This function computes the sum of the elements in an int tree. The recursive
case has a slightly more intimidating-looking continuation, however we can view
it as simply a case of the continuation being wrapped <em>twice</em>.</p>
<p>Consider how we would normally want to approach this problem. In a typical
<code>treeSum</code>, we might compute both the left and right sums, and then simply add
the results to <code>x</code>. This suffices, and follows rather intuitively, but in CPS we
must make our control flow <em>explicit</em>. In this manner, we must be very specific
about <em>what</em> we should do and in which <em>order</em>. To that end, we fix a direction
to visit first (in this case, left, though it does not matter), and then compute
the sum of that direction, with the promise that we will eventually use the
result of the left side to compute the final result.</p>
<p>To visualize what is happening, consider the following tree.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/cpsTree.png" alt="Tree to be summed"
    width="200" class="center"/>
    <figcaption><b>Fig 5.</b> A tree of ints to be summed, whose node contents are conveniently enumerated according to visit order. </figcaption>
</figure>
<p>We will run through a mock simulation of the evaluation of <code>treeSumCPS T k</code>,
where <code>T</code> is the tree pictured, and <code>k</code> is some arbitrary continuation. First,
note that we will take the convention that &quot;Tn&quot; for some number n will denote
the subtree rooted at the vertex n, and &quot;Sn&quot; will denote the sum of that
subtree.</p>
<p>Firstly, we know that from <code>treeSumCPS T k</code> we should obtain <code>treeSumCPS T2 (fn S2 =&gt; treeSumCPS T4 (fn S4 =&gt; k (S2 + 1 + S4))</code>.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/phase1.png" alt="Phase 1"
    width="3000" class="center">
    <figcaption class="center"><b>Fig 6.</b> Phase 1 of evaluation of the tree T. </figcaption>
</figure>
<p>We can think of the individual calls to <code>treeSumCPS</code> on <code>T2</code> and <code>T4</code> as leaving
&quot;flags&quot; on each arm of the edges coming from vertex 1 - denoting which node that
we should visit next. Clearly, we visit <code>T2</code> first, so the red brick
corresponding to <code>T2</code> is on top.</p>
<p>Our next move is to pop it off first, which will cause our expression to now
have three bricks - two corresponding to the children of <code>T2</code>, and one
corresponding to <code>T4</code>. We can visualize the next phase as the following:</p>
<figure class="aligncenter">
    <img src="concepts/../assets/phase2.png" alt="Phase 2"
    width="3000" class="center">
    <figcaption class="center"><b>Fig 7.</b> Phase 2 of evaluation of the tree T. Note that two extra "bricks" have been added due to evaluation of treeSumCPS T2. </figcaption>
</figure>
<p>where the brick labelled <code>treeSumCPS E</code> corresponds to the empty child of
<code>T2</code>. Note that we have retained the blue flag at <code>T4</code> and left its brick alone,
since for all intents and purposes we have not yet &quot;touched&quot; it - we have not
evaluated our stack to that point. Note that due to corresponding to the <code>Empty</code>
case, the purple brick will not add any new bricks, but merely defer to the next
brick on the stack - the orange brick. Thus, the next step looks like the
following:</p>
<figure class="aligncenter">
    <img src="concepts/../assets/phase3.png" alt="Phase 3"
    width="3000" class="center">
    <figcaption class="center"><b>Fig 8.</b> Phase 3 of evaluation of the tree T. Note that this follows from evaluating both of the top bricks from the previous step. </figcaption>
</figure>
<p>In this step, the green and light blue bricks again correspond to empty trees,
so they simply dissolve without generating more instructions. As such, we reduce
to the following diagram:</p>
<figure class="aligncenter">
    <img src="concepts/../assets/phase4.png" alt="Phase 4"
    width="3000" class="center">
    <figcaption class="center"><b>Fig 9.</b> Phase 4 of evaluation of the tree T. Note that, after finishing our evaluation of all of the bricks of the left side, we return to our long-neglected "checkpoint" on the right side of the tree.. </figcaption>
</figure>
<p>We see in this step that, as the figure caption says, we have returned to the
right hand side after finishing all evaluation on the left hand side of the
tree. Thus, our construction was correct - we placed the blue brick onto the
stack at the very beginning, then proceeded to forget about it until now. This
works in our favor, however, as we only return to it once we have finished with
everything on the left. One more step of evaluation yields:</p>
<figure class="aligncenter">
    <img src="concepts/../assets/phase5.png" alt="Phase 5"
    width="3000" class="center">
    <figcaption class="center"><b>Fig 10.</b> Phase 5 of evaluation of the tree T. </figcaption>
</figure>
<p>Thus, all we have left are empty bricks, so we are very close to termination.</p>
<p>This demonstration was far from a rigorous treatment, and also omitted any
mention of the actual value being passed into each continuation - this can be
inductively assumed to be the proper sum at any given brick. We invite the
reader to conduct any detailed analysis on their own, similarly to the treatment
of <code>factCPS</code>, in order to truly grasp how the different subtree sums are
computed and passed around.</p>
<p>The main point in this example, however, was to demonstrate how even a slightly
more complicated function can result in elegant, powerful control-flow behavior.
By simply wrapping our continuation twice, we ensured that we could set up a
&quot;checkpointing&quot; system, where we could set &quot;flags&quot; to jump back to once
finishing a certain computation. This is an important idea to cognize with
continuation passing style. </p>
<p>In the next example, we will explore how we can set up more complicated
arrangements of control flow through usage of two continuations.</p>
<h2 id="continuation-passing-style-a-case-study-in-success-and-failure"><a class="header" href="#continuation-passing-style-a-case-study-in-success-and-failure">Continuation Passing Style: A Case Study in Success and Failure</a></h2>
<p>Duality seems to permeate computational problems. When trying to write programs,
we often come to cases where we need to make a choice between two extremes - on
or off, keep or don't, left or right, 1 or 0. With the capacity to make choices,
however, comes the possibility of making the <em>wrong</em> choice. In such a case, we
might want the ability to remember the choice we made, and take the other one,
or <em>backtrack</em>. </p>
<blockquote>
<p><strong>[Backtracking]</strong> Backtracking is a strategy employed by algorithms when
trying to find all the possible &quot;options&quot; or &quot;possibilities&quot;, so as to locate
the &quot;best&quot; solution, or alternatively just one feasible solution. Problems
that admit backtracking solutions include the N-queens puzzle, constraint
satisfaction problems, and Sudoku.</p>
</blockquote>
<p>At first, backtracking might seem like it is akin to what was done in the
previous example, with our idea of &quot;checkpointing&quot;, except that we never really
&quot;reset&quot; our state. When we set checkpoints to go back to in the <code>treeSumCPS</code>
example, we always did so while retaining the sum of the left side, so we never
lost information. In a backtracking problem, we may need to throw away
everything that we've done in the meantime and go to a different solution
entirely.</p>
<p>In this example, we will analyze a classic optimization problem, and how it
admits a CPS solution.</p>
<blockquote>
<p><strong>[Knapsack Problem - Decision Version]</strong> The <em>knapsack problem</em> is a resource
allocation problem which traditionally concerns a person with a knapsack that
can only contain a certain total weight of items. The person has to choose between a
collection of items (all of differing weight and value) so as to maximize the
amount of value collected, while being below the maximum weight limit of the knapsack.
Note that items can be taken more than once.</p>
<p>In this chapter, we will be concerned specifically with the <em>decision problem</em>
version of the knapsack problem, which, instead of asking for a maximizing
assignment, instead asks if there <em>exists</em> an assignment that can achieve a
certain threshold of value.</p>
</blockquote>
<p>We will now write a continuation passing style function that solves the
knapsack problem.</p>
<pre><code class="language-sml">type weight = int
type value = int

(* knapsackCPS : 
 *            (value * weight) list -&gt; 
 *            value -&gt; 
 *            weight -&gt; 
 *            ((value * weight) list -&gt; 'a) -&gt; 
 *            (unit -&gt; 'a) -&gt; 
 *            'a 
 * REQUIRES: The weights and values of the elements in L are strictly positive.
 * ENSURES: knapsackCPS L minVal maxWeight sc fc ~= sc L' for some L' that only
 * contains elements of L, such that the total value of L' &gt;= minVal and the 
 * total weight of L' &lt;= maxWeight, if such an L' exists. If no such L' exists, 
 * then it should be equivalent to fc ().
 *)

fun knapsackCPS 
  (L : (value * weight) list) 
  (minVal : value) 
  (maxWeight : weight) 
  (sc : (value * weight) list -&gt; 'a) 
  (fc : unit -&gt; 'a)
  : 'a =
  case L of
    [] =&gt; if minVal &lt;= 0 andalso maxWeight &gt;= 0 then sc [] 
                                                else fc ()
  | (v, w)::xs =&gt; if maxWeight &lt; 0 then fc ()
                                   else
    knapsackCPS ((v, w)::xs) (minVal - v) (maxWeight - w) 
    (fn L' =&gt; sc ((v, w)::L')) (fn () =&gt; knapsackCPS xs minVal maxWeight sc fc)
</code></pre>
<p>We see that <code>knapsackCPS</code> takes in a list of items, each represented as 
a <code>value * weight</code> tuple, where <code>value</code> and <code>weight</code> are both really just 
aliases for <code>int</code>. It also takes in a minimum threshold for the knapsack's 
value, <code>minVal</code>, and a maximum weight of items to be taken <code>maxWeight</code>. Of 
particular interest, however, are the parameters <code>sc</code> and <code>fc</code> - denoting 
what we call the <em>success</em> and <em>failure</em> continuations. The goal of our 
function is to ultimately find a list <code>L'</code> that contains elements that are also 
in <code>L</code> (with duplicates allowed). This corresponds to choosing how many of each 
item in the allowed collection to pick.</p>
<p>If such a list exists, then we should return <code>sc L'</code>. Otherwise, if there is no
such list, we should return <code>fc ()</code>. </p>
<p>Rather immediately, this should seem as a kind of different problem. There isn't
really a better algorithm than brute forcing possibilities, but if we try a
possibility and it turns out to be wrong, we want to have the option to be able
to <em>backtrack</em> and try something else entirely. We will demonstrate how this is
realized in the algorithm in the next part.</p>
<pre><code class="language-sml">case L of
    [] =&gt; if minVal &lt;= 0 andalso maxWeight &gt;= 0 then sc [] 
                                                else fc ()
</code></pre>
<p>For the base case, however, we know that if we are given no items whatsoever,
then we cannot place anything in our knapsack. Thus, we have no choice but to
have a value and weight of 0. As such, if we know that our minimum value is at
most 0 and our maximum weight is at least 0, then a valid list value for <code>L'</code> is
just the empty list, so we can call our success continuation in <code>sc []</code>. Otherwise, 
we must call the failure continuation, as the problem is not solvable.</p>
<p>Note that, since we plan to write this function recursively, if we were given an
initial list that was non-empty, we may eventually recurse down to the empty
case. It may then seem like a concern that we are calling <code>sc []</code>, as we might
actually call <code>sc</code> on a list that contains elements. Note that this is not a
concern - by the structure of CPS functions, if we were to recurse down to the
base case, our &quot;promise&quot; is that the success continuation <code>sc</code> that we enter the
base case with is not the &quot;original&quot; <code>sc</code> that we were passed - by this point,
it should have accumulated a great deal of &quot;information&quot; and thus become more
advanced than simply returning <code>sc []</code>, for the original <code>sc</code>. For the base
case, it is sufficient to simply solve it from the perspective of having been
originally given <code>[]</code>.</p>
<p>In the recursive case, we now have to think about how we might solve the
knapsack problem given that we have a non-empty collection of items to take.
Right off the bat, we can say that if our <code>maxWeight &lt; 0</code>, then this problem is
unsolvable, since we cannot possibly have a negative total weight (our weights
in this problem are strictly positive), so in that case we would simply call our
failure continuation.</p>
<p>Otherwise, however, we now need to actually think about what to do. Oftentimes,
it is very helpful reduce the problem to making a <em>binary choice</em>, and then
simply explore the consequences of doing so from there. In this case, we can
imagine our choice to be whether to put the first element of the list into the
knapsack, or to not. </p>
<pre><code class="language-sml">| (v, w)::xs =&gt; if maxWeight &lt; 0 then fc ()
                                   else
    knapsackCPS ((v, w)::xs) (minVal - v) (maxWeight - w) 
    (fn L' =&gt; sc ((v, w)::L')) (fn () =&gt; knapsackCPS xs minVal maxWeight sc fc)
</code></pre>
<p>What does our recursive call for putting the first element <code>(v, w)</code> into the
knapsack look like? It takes the form of <code>knapsackCPS ((v, w)::xs) (minVal - v)  (maxWeight -  w) sc' fc'</code>, for some <code>sc'</code> and <code>fc'</code> that we will determine later. We 
keep the list the same, to account for the fact that we can have duplicates - in the 
next step, we want to reconsider whether we want to put <code>(v, w)</code> on again. If we
commit to putting <code>(v, w)</code> in the knapsack, however, we need to somehow encode
the fact that our value has gone up by <code>v</code>, and our knapsack's weight has gone
up by <code>w</code>. This is achieved by setting the new minimum value to be <code>minVal - v</code>,
and the new max weight to be <code>maxWeight - w</code> - we simply lower our thresholds,
which is functionally the same.</p>
<p>What should our continuations be? Remember that by the recursive leap of faith,
we can assume a kind of &quot;promise&quot; of this recursive call - that is, we can
assume that <code>knapsackCPS ((v, w)::xs) (minVal - v) (maxWeight - w) sc' fc'</code>
obeys the same ENSURES clause as was written above, for its own <code>sc'</code> and <code>fc'</code>.
We now should define what to do in the case that either is called.</p>
<p>We are, at this point, not actually at the stage where we know if <code>sc'</code> or <code>fc'</code>
is going to be called, or on what, if at all. The power in CPS comes from the
fact that this <em>does not matter</em>, and we can write our algorithm despite
that. Earlier, we discussed the concept of continuations as <em>contingency plans</em>.
In this function, we are going to be using that strategy to full effect.</p>
<p>Think of <code>sc'</code> and <code>fc'</code> as contingency plans for the success and failure case,
respectively. <em>If</em> we were to succeed on this recursive call, what should we do?
If we were to fail, what should we do? Even though we have no idea what the
input to the continuation is, the fact that it is a function allows us (inside
the scope of the body of <code>sc'</code>) to <em>assume we have access to it</em>. </p>
<p>As such, the first thing we may write for <code>sc'</code> is <code>fn L' =&gt; ...</code>. Now, we must 
fill in the ellipses. If <code>sc'</code> is called, we know that it must be called with an 
appropriate <code>L'</code> that satisfies the ENSURES conditions. Recall that this recursive call
emerged in the first place from our <em>choice</em> - to place <code>(v, w)</code> inside of the
knapsack. Thus, if the call to <code>knapsackCPS</code> succeeds, we know that placing <code>(v, w)</code> inside the knapsack must be feasible, by extension. So then we know it makes
sense to write <code>fn L' =&gt; sc ((v, w)::L')</code> for <code>sc'</code>, which intuitively means
&quot;take the answer (knapsack) to the recursive call and then put <code>(v, w)</code> in it,
then call success on it&quot;. Thus, we have written down a <em>contingency plan</em> for
what we should do <em>if</em>, at some point in the future, our success continuation is
called.</p>
<p>What about <code>fc'</code>? What should we do if we fail? Well, if our recursive call to
<code>knapsackCPS</code> does not succeed, that must mean that our choice to place <code>(v, w)</code>
inside of the knapsack was wrong. In that case, we want to make the other choice - 
to not put <code>(v, w)</code> inside the knapsack. Thus, we write <code>fn () =&gt; knapsackCPS xs minVal maxWeight sc fc</code>, which has the exact same parameters as what we were
initially passed, except we have gotten rid of <code>(v, w)</code> (since we know to put it
in the knapsack is a mistake). Our <code>sc</code> and <code>fc</code> remain the same, since on a
sucess or fail to this call, we just do whatever we would normally do on a
success or fail.</p>
<p>This, in only a few lines (and generous whitespace), we have written an
algorithm for a backtracking knapsack problem solver. While it looks
intimidating at first, the overall algorithm reduces down to only a few simple
steps, which is written in an elegant and explicit manner due to continuation
passing style.</p>
<h2 id="conclusions-2"><a class="header" href="#conclusions-2">Conclusions</a></h2>
<p>In this section, we explored the idea of continuation passing style, which lets
us phrase the control flow of our functions in a more explicit manner, granting
us more versatility in our implementation. We saw how CPS functions can be
viewed as simply a more advanced form of accumulation, as well as how having
multiple continuations (corresponding to success and failure cases) allows us to
explore expansive trees of binary choices to find solutions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<p><em>By Brandon Wu, June 2020</em></p>
<p>So far, we have seen how we can manipulate the constructs of SML to create
unique control flow behavior in the form of continuation passing style. In this
section, we will discuss <em>exceptions</em>, which are themselves a builtin feature of
the language. With exceptions, we can cover cases where continuing to evaluate an
exprerssion does not make sense or is ill-defined at run-time.</p>
<h2 id="built-in-exceptions"><a class="header" href="#built-in-exceptions">Built-In Exceptions</a></h2>
<p>We have seen how SML interprets computation as evaluation, and how we can reduce
our entire notion of program execution to application of simple reduction rules.
Sometimes, however, we run into cases where attempting to apply some rule
results in an error, or in some output that we cannot actually
express. In such cases, it is necessary to actually <em>halt</em> evaluation with some
manner of effect - this is the behavior that exceptions will introduce.</p>
<p>While we would like to be able to push as many of these errors as possible to compile 
time, it is not always the case that this is possible - this is usually when
dealing with cases where computation is made infeasible by the <em>values</em>
that are bound to identifiers, which cannot be determined <em>a priori</em> at compile
time. As such, we have no way of telling beforehand if such errors will occur -
forcing us to define some notion of a <em>run-time error</em>.</p>
<p>There are numerous examples of built-in SML exceptions, however, you will encounter
some far more than others. The following is a brief overview of what they are,
when you will encounter them, and how to deal with them.</p>
<h3 id="fail"><a class="header" href="#fail">Fail</a></h3>
<p>Whether you knew it or not, you have certainly seen <code>Fail</code> before! Whenever
you have a homework problem where we give you an unimplemented function
in the form <code>fun myFunction x = raise Fail &quot;Unimplemented&quot;</code> you are using the 
power of exceptions! <code>Fail</code> can be thought of as an all-purpose exception,
nothing super special, but quite useful!</p>
<h3 id="div"><a class="header" href="#div">Div</a></h3>
<p>This one is fairly straight-forward. <code>Div</code> is raised whenever you do a division
operation that is mathematically invalid such as <code>1 div 0</code>.</p>
<h3 id="match"><a class="header" href="#match">Match</a></h3>
<p>The match exception is raised whenever you have a case of nonexhaustive pattern matching.
We <em>generally</em> want our patterns to be exhaustive, meaning that no matter the input,
it matches to one of the buckets established by our patterns. 
Consider the function <code>fn true =&gt; 1</code>, which is plainly nonexhaustive, not
covering the <code>false</code> case. Nonetheless, it is a function of type <code>bool -&gt; int</code>
that can be bound to an identifier. How, then, should we handle the case of
attempting to evaluate <code>(fn true =&gt; 1) false</code>? This is a well-typed expression,
causing it to fly under the radar of our compile-time tests. At run-time, then,
we cannot evaluate this expression through function application - the function
does not specify what it should return in this case! As such, we will simply
raise a <code>Match</code> exception, signifying that the function's input was not able to
match to any particular clause of the function.</p>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<p>Lines that cause exceptions will be marked <code>(* ! *)</code></p>
<pre><code class="language-sml">fun f 1 = 5
  | f 5 = 10

val x = f 6 (* ! *)

val y = case [] of x::xs =&gt; 17 (* ! *)
</code></pre>
<h3 id="bind"><a class="header" href="#bind">Bind</a></h3>
<p>Bind is similar to match, but crucially different.
While Match is raised when you are unable to match with any clause, Bind is raised when you try to &quot;force&quot; a binding that cannot happen. 
An example of this would be <code>val 5 = 4</code>. SML we see that you are trying to force the value <code>4</code> to be assigned to the value <code>5</code> which
obviously cannot happen.</p>
<p>In pattern matching, while we are attempting to produce a binding in case expressions/function clauses, we aren't &quot;forcing&quot; any bindings. 
Instead, we are simply attempting to find a case that could match our expression (and we only bind to the pattern if we find a successful case). 
If we aren't able to find a case that works, we raise <code>Match</code> to indicate that we tried to find a case that could match with our expression, 
but couldn't due to non-exhaustive casing.</p>
<p><code>Bind</code> on the other hand is caused when we don't even try to case to see whether a pattern works or not. 
Instead, we are saying that our expression <em>has</em> to bind with some pattern. If that binding cannot happen, then <code>Bind</code> is raised.</p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples</a></h4>
<pre><code class="language-sml">val () = 5
val &quot;polly&quot; = &quot;honk&quot; (* could you imagine! :O *)
</code></pre>
<h2 id="defining-exceptions-basic"><a class="header" href="#defining-exceptions-basic">Defining Exceptions: Basic</a></h2>
<p>We have now seen the built-in exceptions that are automatically raised for
certain prescribed use cases. Oftentimes, however, we are interested in our own
specified use cases, meaning that we likely do not want to use the exceptions
<code>Div</code>, <code>Match</code>, and <code>Bind</code>, which may be unrelated. In this case, we want to
define our own exceptions.</p>
<p>The syntax for defining exceptions is as follows:</p>
<pre><code class="language-sml">exception Error
</code></pre>
<p>This introduces the constructor named Error, which corresponds to the
identically named exception Error. Exception constructors are <em>first class</em>,
meaning that they are themselves values. The type of exception constructors is
<code>exn</code>, so this line really introduces the value <code>Error : exn</code>. The type <code>exn</code>
stands for &quot;exception name&quot;, but it is also useful to think of it as standing
for &quot;extensible&quot;, since the type <code>exn</code> is <em>extensible</em>. This means that we
can <em>extend</em> the values that populate <code>exn</code> with new constructors, like we did 
with <code>Error</code>.</p>
<p>The value <code>Error</code> is not, by itself, an exception, however we can use it to
raise exceptions with the <code>raise</code> keyword. We can think of the <code>raise</code> keyword
as being &quot;like&quot; a function of type <code>exn -&gt; 'a</code>, in that it &quot;takes in&quot; a value of
type <code>exn</code> and has type <code>'a</code>. It is important to remember that <code>raise</code> is <em>not</em>
a function really, though - it merely has similar behavior when used to raise
exceptions, but it is not first class.</p>
<p>The polymorphic &quot;return type&quot; of the <code>raise</code> keyword is so that raising
exceptions can be compatible with our type system. Suppose we want to write a
factorial function that, instead of looping forever on negative inputs, raises
an exception.</p>
<pre><code class="language-sml">exception Negative

fun fact' 0 = 1
  | fact' n = 
      if n &lt; 0 then raise Negative
               else n * fact' (n-1)
</code></pre>
<p>This code fragment should carry out our desired behavior. Consider the type of
<code>raise Negative</code> - we would like to raise an exception, but we know that the
expressions in both branches of an if then else expression must be the same
type. In the positive case, this has type <code>int</code>, corresponding to just
calculating the actual factorial. Therefore the negative case must also be
<code>int</code>, though we also want to raise an exception. To be compatible with this, 
<code>raise Negative</code> must have type <code>int</code>.</p>
<p>We would not like <code>raise Negative</code> to have type <code>int</code> in <em>general</em>, however -
this depends on our use case! We want raising exceptions to be able to just
<em>work</em>, type-wise, since we know that it never returns a well-defined value anyways. 
As such, we define raising exceptions to have a <em>polymorphic</em> return type, so that
it fits within our type system correctly, no matter the use case. This is also
the reason why we can write <code>raise Fail &quot;Unimplemented&quot;</code> as the output of
not-yet defined functions and still pass typechecking, no matter how complicated
the function.</p>
<h2 id="exceptional-control-flow"><a class="header" href="#exceptional-control-flow">Exceptional Control Flow</a></h2>
<p>At this point, we have seen how exceptions let us implement a very limited form
of &quot;control flow&quot;, in that we can stop the flow of control entirely - upon
encountering a raised exception, computation ceases. This is rather rudimentary
in terms of expressiveness - we can only create programs that forcibly
terminate! In this section, however, we will explore the usage of <code>handle</code>, a
keyword that allows us to have more sophisticated behavior with respect to
programs deal with raised exceptions.</p>
<blockquote>
<p><strong>[handle]</strong> For expressions <code>e : t</code>, <code>e1 : t</code> ... <code>en : t</code>, and different values 
<code>Exn1 : exn</code> ... <code>ExnN : exn</code>, if the expression <code>e</code> raises the exception
<code>ExnI</code>, then the expression </p>
<pre><code>e handle Exn2 =&gt; e1
       | Exn2 =&gt; e3
       ...
       | ExnN =&gt; en
</code></pre>
<p>reduces to <code>eI</code>.</p>
<p>In other words, the <code>handle</code> keyword lets us case on the exception raised by
an expression.</p>
</blockquote>
<p>It is important to note that all the expressions <code>e</code>, <code>e1</code>, ... <code>en</code> have to be
of the same type. Consider what would happen if they were not:</p>
<pre><code class="language-sml">e handle Div =&gt; &quot;Oh no!&quot;
</code></pre>
<p>Let <code>e</code> be an expression of type <code>int</code>. Suppose that, in this case, <code>e</code> raises <code>Div</code>, 
so ostensibly this expression should reduce to <code>&quot;Oh no!&quot;</code>. However, what would happen 
if <code>Div</code> was not raised? Then, we would have <code>e</code>, which is of type <code>int</code>.</p>
<p>We've violated type safety here. We cannot &quot;sometimes&quot; have an expression be one
type and another time have it be another. We must have <em>static type guarantees</em>.
As such, all the arms of a <code>handle</code> must agree, and additionally they must agree
with the type of the expression being handled.</p>
<p>We say that an exception that is raised can either propagate up to the <em>top
level</em> (in which case the program or expression simply results in an uncaught
exception), or to the <em>nearest handler</em>. To clarify the meaning of &quot;nearest&quot;,
take the evaluation of the expression <code>(1 + (1 div 0)) * 3 handle Div =&gt; 5</code>, for
example. We see that <code>1 div 0</code> raises the exception <code>Div</code>, so the inner
expression is extensionally equivalent to <code>(1 + raise Div) * 3</code>. Then, applying
this logic one more time, <code>1 + raise Div</code> clearly should also raise <code>Div</code>, so we
get that it is extensionally equivalent to <code>raise Div * 3</code>, which is then
extensionally equivalent to <code>raise Div</code>. What we see is that this raised
exception &quot;propagates up&quot; as it subsumes more and more expressions, until
eventually it reaches a handler.</p>
<p>While we now see how we can handle different kinds of exceptions, we might want
to make a more educated choice about what our next action should be. It might be
the case that we raise an exception in some failed branch of the program, but we
want to have more information about exactly what happened, or what the program
was doing at the time. We will now discuss <em>information-carrying exceptions</em>,
which are nothing other than an extension of our declarations of exceptions to
being more akin to how we declare datatypes.</p>
<p>In a similar vein to how we can declare <code>datatype Foo = Bar of int</code> to denote
that a value of type <code>Foo</code> is the constructor <code>Bar</code> wrapping a value of type
<code>int</code>, we can declare values of type <code>exn</code> to also be constructors wrapping
values. This takes the form:</p>
<pre><code class="language-sml">exception Crash of int
</code></pre>
<p>which denotes that <code>Crash 1</code> and <code>Crash 5</code>, among others, are values of type
<code>exn</code>, and can thus be <code>raise</code>d. Note that <code>Crash</code> thus has type <code>int -&gt; exn</code>.</p>
<p>Concretely, we can &quot;pattern match&quot; on the data contained by the exception
handler by doing something like the following:</p>
<pre><code class="language-sml">exception Return of int

fun factException 0 = raise Return 1
  | factException n = factException (n - 1) handle (Return res) =&gt; raise Return
  (n - 1)
</code></pre>
<p><strong>NOTE:</strong> It is not clear why anyone would want to define <code>fact</code> this way.</p>
<p>This example makes use of an exception, <code>Return : int -&gt; exn</code>, which wraps the
return value of <code>fact</code>. <code>fact</code>, at each step, simply raises an exception
containing its return value, which (in a future recursive call) is handled, the
value unwrapped (bound to <code>res</code>), then multiplied by the current value of <code>n</code> to
generate the next value, which is simply raised again. This is very similar to a
<code>case</code> expression - we simply pattern match on the raised exception's constructor 
using the handler (you can pattern match on exception constructors with <code>case</code> as
well, though not <em>raised</em> exceptions). Thus, the behavior of <code>factException n</code>
is to be extensionally equivalent to <code>raise Return (fact n)</code>.</p>
<p>For an abstract idea of a potential use case, consider some recursive function 
<code>f</code> that carries out some sequence of calculations, with a potential for error.
We might be interested in how many recursive calls such a function makes when it
ultimately fails - however, if we were to return the number of recursive calls,
we would constrain the return type to be <code>int</code>, or barring that, some datatype
that could be either a valid result (say, <code>Valid res</code>) or a signal for failure,
with a line number (say, <code>Fail line</code>). We might desire that on a fail, execution
actually stops, however. We could then simply raise the exception <code>Crash line</code>,
which, as a raised exception, has a polymorphic type. As such, exceptions allow
us to propagate back information <em>without altering types</em>, which can be
convenient for our purposes.</p>
<p>For a concrete example of using such exceptions, see the next section.</p>
<h2 id="exception-handling-style"><a class="header" href="#exception-handling-style">Exception Handling Style</a></h2>
<p>In the previous section, we discussed how continuation passing style could be
used to devise complicated control flow schemas, in some instances being based
around the idea of a <em>success</em> and <em>failure</em> continuation, which could both
potentially execute disjoint sets of instructions. With continuations, we can
relate them to a common other construct in programming languages, that being a
<em>goto</em>. With a goto, we abandon whatever we are currently in the process of
doing in favor of something else. In this, we can see that continuations and
exceptions share similar characteristics, of being able to just &quot;stop&quot; execution
in favor of some other route.</p>
<p>Consider the knapsack example from the previous section. We will now implement a
solution to the knapsack problem using exception handling style.</p>
<pre><code class="language-sml">exception Failure

type weight = int
type value = int

(* knapsackEHS : 
 *            (value * weight) list -&gt; 
 *            value -&gt; 
 *            weight -&gt; 
 *            ((value * weight) list -&gt; 'a) -&gt; 
 *            'a 
 * REQUIRES: The weights and values of the elements in L are strictly positive.
 * ENSURES: knapsackEHS L minVal maxWeight sc fc ~= sc L' for some L' that only
 * contains elements of L, such that the total value of L' &gt;= minVal and the 
 * total weight of L' &lt;= maxWeight, if such an L' exists. If no such L' exists, 
 * then it should be equivalent to raise Failure.
 *)

fun knapsackEHS 
  (L : (value * weight) list) 
  (minVal : value) 
  (maxWeight : weight) 
  (sc : (value * weight) list -&gt; 'a) 
  : 'a =
  case L of
    [] =&gt; if minVal &lt;= 0 andalso maxWeight &gt;= 0 then sc [] 
                                                else raise Failure
  | (v, w)::xs =&gt; if maxWeight &lt; 0 then raise Failure
                                   else
    knapsackEHS ((v, w)::xs) (minVal - v) (maxWeight - w)  (fn L' =&gt; sc ((v, w)::L')) 
    handle Failure =&gt; knapsackEHS xs minVal maxWeight sc
</code></pre>
<p>It should be apparent that this function shares very close similarities to
<code>knapsackCPS</code>, with the exception<a href="concepts/exn.html#footnote1"> <sup> [1] </sup> </a> of
omitting the failure continuation for raising the <code>Failure</code> exception. In fact,
we can claim that <code>knapsackCPS L minVal maxWeight sc fc ~= knapsackEHS L minVal maxWeight sc handle Failure =&gt; fc ()</code>, for all relevant values. Take a moment to
assure yourself that this is the case. The code does not look very different,
with the largest change being the recursive case, where the failure continuation
has instead been offloaded to a handler.</p>
<p>Recall that we can think of the recursive call in the knapsack problem as a
&quot;choice&quot; to &quot;keep&quot; or &quot;not keep&quot; the item at the head of the list. We said
previously that, arbitrarily, we could commit to the choice of &quot;keep&quot;, with a
provision in the failure continuation to instead &quot;not keep&quot;, should that failure
continuation ever be executed. When evaluating the expression <code>knapsackEHS ((v, w)::xs) (minVal - v) (maxWeight - w) (fn L' =&gt; sc ((v, w)::L'))</code>
<a href="concepts/exn.html#footnote2"> <sup> [2] </sup> </a>, we know that one of two things can
happen - it can either <em>succeed</em> or <em>fail</em>. Now, however, our definition of
failure is different - instead of calling its failure continuation, an instance
of <code>knapsackEHS</code> which fails should instead raise <code>Failure</code>. Thus, it is exactly
the right thing to do to do what we would ordinarily do upon a failure, should
our call to <code>knapsackEHS</code> raise <code>Failure</code>.</p>
<p>Note, however, that in this implementation we put a slight amount more burden on
the user, since the ill-defined behavior of this function now results in a
raised <code>Failure</code>, instead of just invoking <code>fc ()</code>, for some pre-defined <code>fc</code>
that we input. This offers us the same advantages, however, since the return
types of <code>sc</code> and <code>fc</code> in <code>knapsackCPS</code> must be the same. As such, if we want
<code>knapsackCPS</code> to return some indicative value (without using an option type), we 
might not have an appropriate return value for the failure case. Thus,
<code>knapsackEHS</code> might have the behavior we're looking for, since the type of
<code>raise Failure</code> allows us to &quot;unconstrain&quot; the type of our success. In the
general case, however, we will not make heavy usage of exception handling style,
in favor of continuation passing style, which can be cleaner.</p>
<p>This is not the most committed that we could have made <code>knapsackEHS</code>, when
converting to exception handling style - we could have also represented <em>success
continuations</em> with a raised exception, an <code>exception Success of (int * int) list</code>. We will not cover such an implementation in this chapter, but we invite
the reader to try it out.</p>
<h3 id="footnotes-5"><a class="header" href="#footnotes-5">Footnotes</a></h3>
<p><a id="footnote1"> [1]: We're funny.
<a id="footnote2"> [2]: Say that five times fast.</p>
<h2 id="conclusions-3"><a class="header" href="#conclusions-3">Conclusions</a></h2>
<p>In this chapter, we explored <em>exceptions</em>, which allow us to have quick
transfers of control flow, albeit in a less &quot;controlled&quot; fashion than ways that
we have seen in the past. The success of so-called <em>exception handling style</em> is
heavily contingent on intelligent placement and consideration of <em>handlers</em>,
which decide where control is transferred to. We also have seen that we have a
way of passing information back <em>through</em> the raised exception, which allows us
to have a more powerful manner of communication than just an indicator of
failure. Exceptions ultimately allow us a robust and type-safe way to deal with 
run-time errors in our programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p><em>By Eunice Chen and Brandon Wu, December 2020</em></p>
<p>Sometimes, we are interested in developing large projects. Large codebases are
oftentimes convoluted and impenetrable to outside scrutiny, being solely
understandable by the original author. It is thus in our best interest to
develop good coding practices - consisting of clean, commented code that
communicates its cause clearly, as well as a <em>modular</em> structure that allows
understanding what each part of the codebase should do. For instance, we would
not want to simply dump all of our code into a single file with
thousands of lines - instead, what we oftentimes may do is decompose it into
constituent parts, each part of which has a certain purpose, such as parsing,
maintaining certain data structures, or other purposes, depending on the use
case.</p>
<p>In this chapter, we will discuss SML's <em>module system</em>, which allows for safe,
powerful abstraction of code. We will discuss the power that <em>data abstraction</em> grants
us as code designers, as well as the clean ways that we can compose them in
order to encapsulate common design patterns.</p>
<h2 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h2>
<p>Oftentimes as programmers, we are tasked with writing code that matches a
specification. This specification can vary in rigor and mathematical formality,
but the general idea is that oftentimes it <em>exists</em>. When we are asked to write a
function to compute the first \( n \) Fibonacci numbers, it does not necessarily
matter <em>how</em> we go about implementing this function, so long as it exhibits the
proper input-output behavior. In other words, we would like it so that all
functions implementing a given specification have <em>extensionally equivalent</em>
behavior to what we should expect them to do.</p>
<p><strong>NOTE</strong>: Sometimes, there are constraints beyond simply being the same
&quot;mathematical function&quot; - that is, defining the same outputs on the same inputs.
Sometimes we are asked for the implementation of a function, running in only less
than \( O(n^2) \) asymptotic time. Even in cases like these, however, there are
always still <em>superficial</em> differences that our implementation allows for - for
instance, when writing the Fibonacci function, it is unlikely that it should
matter whether we calculate the value of \( f(n-1) \) or \( f(n-2) \) first.</p>
<p>This should not be an unfamiliar idea - this is exactly the concept of
referential transparency, which says that we can swap &quot;equals-for-equals&quot;
whenever discussion the equality of expressions. Under the eyes of the language,
equal expressions are just that - equal, and there is no need to disambiguate
them.</p>
<p>This idea, however, is rather limited in scope. What if we would like to
deal with a function that depends upon another function? Then we cannot freely
make the swap between functions, and substitute a function into a context where
its dependencies do not exist. Indeed, we cannot perform such a substitution at
all in the case where a function is in any way defined beyond its own function
body itself.</p>
<p>We don't want to outlaw such practices, however - we simply need to make our
<em>abstraction boundaries</em> more explicit. When we have a package or otherwise
standalone bundle of software, we should be able to use all of its components
that are muutally dependent on each other - not just make our distinctions at
the function level. We will do so using SML's module system.</p>
<h2 id="modules-basics"><a class="header" href="#modules-basics">Modules: Basics</a></h2>
<p>SML takes both the ideas of the <em>specification</em> and the <em>implementation</em> and
provides a way of codifying both within the language itself. Of course, it is
rather difficult to say &quot;implement the list reversal function in \( O(n) \) asymptotic
time in \( n \), the length of the list&quot; in code<a
href="#footnote1"><em><sup>[1]</sup></em></a>, so SML will only deal with
specifications at the <em>type-level</em>. That is, within SML itself, a specification
for a function is simply a type for that function.</p>
<p>The term for a specification in SML is called a <em>signature</em>. Consider the following specification and
implementation of a package for modular arithmetic. Note that the comments are optional.</p>
<pre><code class="language-sml">signature MOD_ARITH =
sig
    (* ENSURES: mod_add n x y = (x + y) mod n *)
    val mod_add : int -&gt; int -&gt; int -&gt; int

    (* ENSURES: mod_sub n x y = (x - y) mod n *)
    val mod_sub : int -&gt; int -&gt; int -&gt; int

    (* ENSURES: mod_times n x y = (x * y) mod n *)
    val mod_times : int -&gt; int -&gt; int -&gt; int
end
</code></pre>
<p>This signature defines three functions, all of which have type <code>int -&gt; int -&gt; int -&gt; int</code>, which takes in the modulus of the operation, as well as the two
operands to the operation to be performed. While we would like an implementation
of this signature to also display the behavior outlined in the comments,
realistically there is no way to verify that this is true (why?), so the best that we
can do is ensure that an implementation provides functions with the correct
type.</p>
<p>Note also that this syntax is slightly different than that you have seen before</p>
<ul>
<li>we use <code>val</code> as if we were going to produce a val binding (with an associated
type annotation), however we do not actually give it any definition. In truth,
you <em>cannot</em> define a value in the signature itself, since it's impossible in
general to check if two values are the same. You can, however, define a <code>type</code>
within a signature (or leave it definitionless, as we will see later in the
chapter).</li>
</ul>
<p>An implementation of <code>MOD_ARITH</code> (called a <em>structure</em>, or <em>module</em>) might look as follows:</p>
<pre><code class="language-sml">structure ModArith : MOD_ARITH =
struct
    fun mod_add n x y = (x + y) mod n

    fun mod_sub n x y = mod_add n x (~y)

    fun mod_times n x y =
        case Int.compare (x, 0) of
            LESS =&gt; mod_add n (mod_times n (x + 1) y) (~y)
          | EQUAL =&gt; 0
          | GREATER =&gt; mod_add n (mod_times n (x - 1) y) y
end
</code></pre>
<p><strong>NOTE</strong>: By convention, structure names are usually capitalized, and signature
names are usually all-capitals. Additionally, it is totally fine to declare a
structure's values with <code>fun</code> instead of <code>val</code>, even if it says <code>val</code> in the
signature, as <code>fun</code> is just shorthand for producing a function value binding
anyways.</p>
<p>We will go over the precise meaning of the usage of the colon symbol in the
above structure later in the chapter. For now, the meaning of this code snippet
is to produce a structure <em>ascribing</em> to the <code>MOD_ARITH</code> signature, or in other
words, implementing the <code>MOD_ARITH</code> specification. We see that it contains three
declarations, those being the functions declared in the signature itself. A key
note is that ascribing to a signature is akin to a contract - any structure
ascribing a signature <em>must</em> implement all the requisite components described by
the signature, or it will fail to ascribe, and result in a compile-time error
(similar to an ill-typed program).</p>
<p>It is not, however, the case that a structure cannot provide <em>more</em> information
than is strictly necessitated by the signature. Additional helper functions and
value bindings can be freely instantiated within a structure without affecting
ascription. Thus, honoring a contract only entails satisfying the terms agreed to
in the signature, without comment on going over. We will explore this idea more
later in the chapter when we discuss information hiding.</p>
<p>Using structures should be something that you are already familiar with - you do
it every time that you invoke <code>Int.compare</code>. To use the fields of a structure,
you access them using the name of the module, followed by a dot, followed by the name of whatever
you are trying to access. Thus, calling <code>Int.compare</code> means to access the function named
<code>compare</code> implemented within the structure named <code>Int</code>, which is provided as
part of the Standard ML Basis Library. To use the structure that we have just
implemented, we would similarly call <code>ModArith.mod_add</code>, for instance.</p>
<p>It is important to know that although a structure may contain values, a
structure is <em>not</em> a value. Structures and signatures exist on another &quot;level&quot;
of syntax outside that of expressions and values, and should not be mixed
interchangeably with them. For instance, it would be nonsense to write <code>val x = ModArith</code>, as you cannot bind <code>ModArith</code> to a value identifier.</p>
<p>It is often useful when thinking of structures and signatures to think of them
as &quot;elevated types and values&quot;, as there is a neat correspondence between the
two. A structure is really just a <em>package</em> of values (among other things, as
we will see later) that must &quot;type-check&quot; in that it must successfully ascribe
to its signature. As such, a structure can be regarded as a &quot;bundle of values&quot;,
and a signature as a &quot;bundle of types&quot;. This only skims the surface at what can
be done with modules, but it is a handy perspective to have.</p>
<h2 id="modules-a-study-in-modularity"><a class="header" href="#modules-a-study-in-modularity">Modules: A Study in Modularity</a></h2>
<p>Ultimately, the main goal that we seek to achieve with modules is, in fact,
<em>modularity</em>. As alluded to previously in this chapter, we have mentioned how we
would like to be able to <em>swap out</em> certain implementations for others as
necessary, to enforce clean boundaries of code dependency and produce more
maintainable code. As it stands, we have only seen modules used for conveniently
wrapping our code, however in this section we are going to discuss how modules
allow us to maintain multiple implementations of the same specification.</p>
<p>Consider the following signature for performing geometric operations on the
Cartesian plane:</p>
<pre><code class="language-sml">signature GEOMETRY =
sig
    type point

    val origin : point
    val rotate : point -&gt; real -&gt; point

    val get_x : point -&gt; real
    val get_y : point -&gt; real
    val get_dist : point -&gt; real
end
</code></pre>
<p>Suppose that we are interested in performing operations on points within the
Cartesian plane. Then, we may be interested in a structure ascribing to this
signature. The question then becomes - how should this signature be implemented?
We have previously discussed swapping out more code for more efficient
implementations, however in that case we clearly consider one unilaterally
superior to the other.</p>
<p>In this signature, note that we have left the type of <code>point</code> <em>abstract</em>, meaning that it
is up to the structure to define what precisely the type of <code>point</code> is - it is
not decided by the signature. In this case, there are at least two discrete ways
that we can consider points on the Cartesian plane - as rectangular or polar coordinates.</p>
<p>Consider the following structures ascribing to the <code>GEOMETRY</code> signature:</p>
<pre><code class="language-sml">structure RectGeo : GEOMETRY =
struct
    (* pair of (x, y) coordinates *)
    type point = real * real

    val origin = (0.0, 0.0)
    fun rotate (x, y) r = (x * Math.cos r) + (y * Math.sin r)

    fun get_x (x, y) = x
    fun get_y (x, y) = y
    fun get_dist (x, y) = Math.sqrt (Math.pow (x, 2.0) + Math.pow (y, 2.0))
end

structure PolarGeo : GEOMETRY =
struct
    (* pair of (d, theta), where d is distance from origin and theta is angle from 0 degrees *)
    type point = real * real

    (* theoretically here theta could be anything *)
    val origin  = (0.0, 0.0)
    fun rotate (d, theta) r = (d, theta + r)

    fun get_x (d, theta) = d * (Math.cos theta)
    fun get_y (d, theta) = d * (Math.sin theta)
    fun get_dist (d, theta) = d
end
</code></pre>
<p>It should be relatively clear that these are two perfectly valid ways of
representing an (albeit limited) implementation of coordinate geometry. Both
have their own strengths and weaknesses, such as rectangular coordinates having
more convenient access to computing the x and y coordinates of a given point,
and polar coordinates more easily rotating points about the origin and
calculating the distance of a point from the origin. As such, it comes down to
<em>context</em> to determine which should be used in any given circumstance.</p>
<p>In this case, modules allow a convenient way of swapping out code without having
to bother with poring through to find dependencies. If we are using the
<code>PolarGeo</code> structure, and instead find ourselves wishing that we were using
rectangular coordinates instead - no problem! We can simply load the other
structure instead. In this case, we have moved dependencies and code reuse to a
static, compile-time check, much in the same way that we moved type-checking to
a static, compile-time check. This is a recurring theme, that we can avoid
deferring errors to runtime to instead try and catch them earlier, in order to
write cleaner and less error-prone code.</p>
<h2 id="modules-transparent-and-opaque-ascription"><a class="header" href="#modules-transparent-and-opaque-ascription">Modules: Transparent and Opaque Ascription</a></h2>
<p>At this point, we have discussed how to use modules for enforcing &quot;contracts&quot;
between parties interested in some kind of software, as well as how it can
assist in code reuse and statically enforcing code dependencies. Another use of
modules in the SML module system is <em>information hiding</em>.</p>
<p>It is sometimes said that one of the greatest ideas in computer science is
<em>abstraction</em>. Whether it is focusing on developing an algorithm to solve a problem, a
piece of software for a given client, or trying to interface with some existing
computer system, it is often the case that it is only prudent to focus on those
details that are <em>relevant to the problem</em>. It takes time and mental energy to
internalize every last detail of a codebase, and it is a waste of time to try
and do so every time that one wants to make a patch. As such, we rely on
abstraction in order to keep the amount of relevant information low.</p>
<p>Consider the computer. It is a complicated, convoluted work of machinery and
circuitry - at its most fundamental level being comprised of logic gates and
incredible networks of interacting parts. Although an action as simple as
opening up a notepad seems very intuitive to the user, under the hood it is
anything but. The key, however, is that the user of a computer need not
understand the underlying hardware and circuitry - indeed, they need not even
know what circuitry is! In the general case,
the user of a computer does not <em>really</em> know how it functions.</p>
<p>Yet again, it is also unlikely that it is important for you to know. A user of a
computer does not need to know precisely how it works to know that they can type
a query into Google. The only details that are <em>relevant to the user</em> are the devices that
allow interfacing with the inner hardware (the mouse and keyboard, among other
things), and less so the precise configuration of the microchips inside of the
machine.</p>
<p>When writing code, we would like to maintain the same practice. We would like to
write clear, concise, and <em>maintainable</em> code (for the unfortunate souls who
have to go back and read it afterwards), so it is important to lessen the burden
on the code-reader who comes after (which might be you!). With modules, we
will be able to create <em>enforced abstraction boundaries</em> that allow
programmers to only consider the <em>interface</em> of a given module, much in the same
way that a computer-user needs only consider the physical interface of the
device.</p>
<p>The first example of this phenomenon of information hiding is through the
contents of a structure that are available for use. We have spoken of signatures
as an interface, a sort of lens through which we view the contents of a
structure. This metaphor is further strengthened by the fact that a signature
literally does dictate what information the user of a structure is able to see.
In any structure ascribing to a given signature, the only data able to be used
by an outside client are those described within the signature.</p>
<p>Practically, this means that the use of &quot;helper functions&quot; in the implementation
of a structure is hidden from the client. This means that in the following
signature and structure:</p>
<pre><code class="language-sml">signature REVERSE =
sig
    val reverse : 'a list -&gt; 'a list
end

structure Reverse : REVERSE =
struct
    fun trev [] acc = acc
      | trev (x::xs) acc = trev xs (x::acc)

    fun reverse L = trev L []
end
</code></pre>
<p>only the value <code>reverse</code> is visible to the user of the <code>Reverse</code> structure. This
can be convenient in enforcing abstraction, because we could be writing a
program that uses helper functions that have certain preconditions. Through
restricting the usage of those helper functions, the client is blocked from
constructing certain inputs to those functions that may violate those
preconditions, resulting in unallowed behavior.</p>
<p>We have used the term &quot;ascription&quot; several times so far in this chapter,
referring to how a structure &quot;implements&quot; a signature, similarly to how a value
has a certain type. In reality, there are two kinds of ascription: transparent
and opaque. To demonstrate the difference, we will consider the following
implementation of 2D arrays.</p>
<pre><code class="language-sml">signature ARRAY =
sig
    type 'a array
    val new : int * int -&gt; 'a -&gt; 'a array
    val get : 'a array -&gt; int * int -&gt; 'a array
    val set : 'a array -&gt; int * int -&gt; 'a -&gt; 'a array
end

structure RectArray : ARRAY =
struct
    type 'a array = 'a list list

    fun row 0 v = []
      | row n v = v :: row (n - 1) v

    fun new (0, width) v = []
      | new (height, width) v =
        row w v :: new (height - 1, width) v

    fun get A (y, x) =
        List.nth (List.nth (A, y), x)

    fun set A (y, x) v =
        let
          val row = List.nth (A, y)
        in
          List.update (A, y, List.update (row, x, v))
        end
end
</code></pre>
<p>This implementation of arrays uses a 2D list in order to create a rectangular
array, with separate access to each row. There is one &quot;creator&quot; function, <code>new</code>,
which constructs a new array, and get the &quot;getter&quot; and &quot;setters&quot; of <code>get</code> and
<code>set</code>, which allow manipulation of an existing array. The structure <code>RectArray</code>
thus ascribes to the <code>ARRAY</code> signature, and because of its usage of the colon
symbol, it <em>transparently ascribes</em> to the <code>ARRAY</code> signature. We are now ready
to discuss precisely what this means.</p>
<blockquote>
<p><strong>[Transparent ascription]</strong>: Ascribing a structure to a signature where all
abstract types are visible to the user of the structure.</p>
</blockquote>
<p>We have previously discussed the existence of <em>abstract types</em>, which are type
declarations in the signature that is being ascribed to. For instance, the type
of <code>'a array</code> is an abstract type, because it is not concretely defined within
the signature. However, if we had instead replaced that line in the <code>ARRAY</code>
signature with <code>type 'a array = 'a list list</code>, it would no longer be abstract
(and note that this would have the consequence that any structure ascribing to
<code>ARRAY</code> <em>must</em> use the representation of a 2D list for its arrays).</p>
<p>What precisely does it mean for the type of <code>'a array</code> to be visible to the user
of the structure? We know that the user of a structure should only be aware of
what is in the signature of a structure, and nothing more. This is not strictly
true - if we have a transparently ascribed structure like <code>RectArray</code>, then the
user of the <code>RectArray</code> structure can treat the <code>'a RectArray.array</code> type as
synonymous with <code>'a list list</code>, and thus be privy to the &quot;internals&quot; of the
structure, even though it is not explicitly defined within the structure.</p>
<p>We will now compare this to if we had instead used opaque ascription. Consider
the following two implementations of the <code>ARRAY</code> signature:</p>
<pre><code class="language-sml">structure ListArray :&gt; ARRAY =
struct
    type 'a array = 'a list * int

    fun gen 0 v = []
      | gen n v = v :: gen (n - 1) v

    fun new (height, width) v =
        (gen (height * width) v, width)

    fun get (A, w) (y, x) = List.nth (A, w * y + x)

    fun set (A, w) (y, x) v = List.update (A, w * y + x, v)
end

structure RectArray :&gt; ARRAY =
struct
    type 'a array = 'a list list

    fun row 0 v = []
      | row n v = v :: row (n - 1) v

    fun new (0, width) v = []
      | new (height, width) v =
        row w v :: new (height - 1, width) v

    fun get A (y, x) =
        List.nth (List.nth (A, y), x)

    fun set A (y, x) v =
        let
          val row = List.nth (A, y)
        in
          List.update (A, y, List.update (row, x, v))
        end
end
</code></pre>
<p>Note that the latter implementation is exactly the same as the previous
<code>RectArray</code> structure, with the exception that is now <em>opaquely ascribed</em>. This
is from using <code>:&gt;</code> between the structure and signature names, which signals
opaque ascription rather than transparent ascription.</p>
<blockquote>
<p><strong>[Opaque ascription]</strong>: Ascribing a structure to a signature where all
abstract types are hidden to the user of the structure.</p>
</blockquote>
<p>By &quot;hidden&quot;, we mean precisely in the same way that the abstract types are
&quot;visible&quot; in transparent ascription. Abstract types are truly that, <em>abstract</em>,
and thus the user of either the <code>RectArray</code> or <code>ListArray</code> structure are
incapable of knowing precisely what either the <code>'a ListArray.array</code> or <code>'a RectArray.array</code> types are. The only way to construct a value of type <code>'a array</code>, from either structure, is by using either respective <code>new</code> function, and
similarly with manipulating an existing array.</p>
<p>Why would we want to have opaque ascription? This is precisely for the reason
that we have been motivating for the entire chapter, which is abstraction. A
fundamental idea of having a powerful type system is to <em>make illegal states
unrepresentable</em>. Instead of having a precondition that must be obeyed in a
given function, we instead would like it so that the type system enforces these
preconditions for us instead - similarly to how for a function of type <code>int -&gt; int</code> with precondition &quot;TRUE&quot;, if we were to instead write it in a dynamically
typed (&quot;typeless&quot;) language, we may instead say that it has a precondition that
its input is an integer. This is then just an extension of that idea to more
general representation invariants.</p>
<p>By <em>representation invariant</em>, we typically mean some invariant of a data
structure that qualifies it to truly be an &quot;instance&quot; of that data structure.
For instance, in the <code>RectArray</code> structure, we use a 2D list to represent a
given array, however it is not the case that <em>all</em> values of type <code>'a list list</code>
correspond to an array of <code>'a</code> values. For instance, is <code>[[1, 2, 3], [4, 5]]</code> a
valid <code>int RectArray.array</code>?</p>
<p>If <code>RectArray</code> were to be transparently ascribed, a client could construct an
illegal instance of an <code>'a RectArray.array</code>, and thus produce undefined behavior
when interfacing with it using functions like <code>get</code> and <code>set</code>. By opaquely
ascribing it to its signature, however, we ensure that the <em>only</em> way that you
can produce and manipulate arrays is internally, through the structure itself,
so as long as the structure's functions preserve representation invariants,
there will be no way of producing an illegal state.</p>
<p>Another motivation is that, ultimately, it isn't important for the client to
know how arrays are implemented - this is an example of <em>information hiding</em>.
If a client wants some implementation of the <code>ARRAY</code> signature, it likely isn't that
important to them whether or not it is implemented as a one-dimensional or two-dimensional
list, so long as it provides certain functionality (which, while limited in this example,
could be extended). We can thus ensure that it is completely impossible to distinguish <code>ListArray</code>
and <code>RectArray</code>, at least in terms of their input-output behavior. This benefits abstraction in
that now the client does not have to think about the fiddley details of
implementation, but instead focus purely on the interface.</p>
<p>We thus see that transparent ascription is useful for cases where knowing a
representation is totally fine (or when debugging), but opaque ascription is in
general the best approach when constructing a library. To clients of a given
software package, it is best to enforce abstraction.</p>
<h2 id="conclusions-4"><a class="header" href="#conclusions-4">Conclusions</a></h2>
<p>In this chapter, we have explored the powerful benefits that are given by SML's
module system, particularly in terms of <em>information hiding</em>, <em>abstraction</em>, and
<em>modularization</em>. While modules are in themselves of significant theoretical
interest, there are many practical applications to their use, and they offer a
clean and concise way to structure large codebases. In the next chapter, we will
explore <em>functors</em>, which are like a <em>higher-order structure</em> that allows us a greater degree of freedom
in structuring our code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-1"><a class="header" href="#modules-1">Modules</a></h1>
<p><em>By Eunice Chen and Brandon Wu, December 2020</em></p>
<p>Sometimes, we are interested in developing large projects. Large codebases are
oftentimes convoluted and impenetrable to outside scrutiny, being solely
understandable by the original author. It is thus in our best interest to
develop good coding practices - consisting of clean, commented code that
communicates its cause clearly, as well as a <em>modular</em> structure that allows
understanding what each part of the codebase should do. For instance, we would
not want to simply dump all of our code into a single file with
thousands of lines - instead, what we oftentimes may do is decompose it into
constituent parts, each part of which has a certain purpose, such as parsing,
maintaining certain data structures, or other purposes, depending on the use
case.</p>
<p>In this chapter, we will discuss SML's <em>module system</em>, which allows for safe,
powerful abstraction of code. We will discuss the power that <em>data abstraction</em> grants
us as code designers, as well as the clean ways that we can compose them in
order to encapsulate common design patterns.</p>
<h2 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h2>
<p>Oftentimes as programmers, we are tasked with writing code that matches a
specification. This specification can vary in rigor and mathematical formality,
but the general idea is that oftentimes it <em>exists</em>. When we are asked to write a
function to compute the first \( n \) Fibonacci numbers, it does not necessarily
matter <em>how</em> we go about implementing this function, so long as it exhibits the
proper input-output behavior. In other words, we would like it so that all
functions implementing a given specification have <em>extensionally equivalent</em>
behavior to what we should expect them to do.</p>
<p><strong>NOTE</strong>: Sometimes, there are constraints beyond simply being the same
&quot;mathematical function&quot; - that is, defining the same outputs on the same inputs.
Sometimes we are asked for the implementation of a function, running in only less
than \( O(n^2) \) asymptotic time. Even in cases like these, however, there are
always still <em>superficial</em> differences that our implementation allows for - for
instance, when writing the Fibonacci function, it is unlikely that it should
matter whether we calculate the value of \( f(n-1) \) or \( f(n-2) \) first.</p>
<p>This should not be an unfamiliar idea - this is exactly the concept of
referential transparency, which says that we can swap &quot;equals-for-equals&quot;
whenever discussion the equality of expressions. Under the eyes of the language,
equal expressions are just that - equal, and there is no need to disambiguate
them.</p>
<p>This idea, however, is rather limited in scope. What if we would like to
deal with a function that depends upon another function? Then we cannot freely
make the swap between functions, and substitute a function into a context where
its dependencies do not exist. Indeed, we cannot perform such a substitution at
all in the case where a function is in any way defined beyond its own function
body itself.</p>
<p>We don't want to outlaw such practices, however - we simply need to make our
<em>abstraction boundaries</em> more explicit. When we have a package or otherwise
standalone bundle of software, we should be able to use all of its components
that are muutally dependent on each other - not just make our distinctions at
the function level. We will do so using SML's module system.</p>
<h2 id="modules-basics-1"><a class="header" href="#modules-basics-1">Modules: Basics</a></h2>
<p>SML takes both the ideas of the <em>specification</em> and the <em>implementation</em> and
provides a way of codifying both within the language itself. Of course, it is
rather difficult to say &quot;implement the list reversal function in \( O(n) \) asymptotic
time in \( n \), the length of the list&quot; in code<a
href="#footnote1"><em><sup>[1]</sup></em></a>, so SML will only deal with
specifications at the <em>type-level</em>. That is, within SML itself, a specification
for a function is simply a type for that function.</p>
<p>The term for a specification in SML is called a <em>signature</em>. Consider the following specification and
implementation of a package for modular arithmetic. Note that the comments are optional.</p>
<pre><code class="language-sml">signature MOD_ARITH =
sig
    (* ENSURES: mod_add n x y = (x + y) mod n *)
    val mod_add : int -&gt; int -&gt; int -&gt; int

    (* ENSURES: mod_sub n x y = (x - y) mod n *)
    val mod_sub : int -&gt; int -&gt; int -&gt; int

    (* ENSURES: mod_times n x y = (x * y) mod n *)
    val mod_times : int -&gt; int -&gt; int -&gt; int
end
</code></pre>
<p>This signature defines three functions, all of which have type <code>int -&gt; int -&gt; int -&gt; int</code>, which takes in the modulus of the operation, as well as the two
operands to the operation to be performed. While we would like an implementation
of this signature to also display the behavior outlined in the comments,
realistically there is no way to verify that this is true (why?), so the best that we
can do is ensure that an implementation provides functions with the correct
type.</p>
<p>Note also that this syntax is slightly different than that you have seen before</p>
<ul>
<li>we use <code>val</code> as if we were going to produce a val binding (with an associated
type annotation), however we do not actually give it any definition. In truth,
you <em>cannot</em> define a value in the signature itself, since it's impossible in
general to check if two values are the same. You can, however, define a <code>type</code>
within a signature (or leave it definitionless, as we will see later in the
chapter).</li>
</ul>
<p>An implementation of <code>MOD_ARITH</code> (called a <em>structure</em>, or <em>module</em>) might look as follows:</p>
<pre><code class="language-sml">structure ModArith : MOD_ARITH =
struct
    fun mod_add n x y = (x + y) mod n

    fun mod_sub n x y = mod_add n x (~y)

    fun mod_times n x y =
        case Int.compare (x, 0) of
            LESS =&gt; mod_add n (mod_times n (x + 1) y) (~y)
          | EQUAL =&gt; 0
          | GREATER =&gt; mod_add n (mod_times n (x - 1) y) y
end
</code></pre>
<p><strong>NOTE</strong>: By convention, structure names are usually capitalized, and signature
names are usually all-capitals. Additionally, it is totally fine to declare a
structure's values with <code>fun</code> instead of <code>val</code>, even if it says <code>val</code> in the
signature, as <code>fun</code> is just shorthand for producing a function value binding
anyways.</p>
<p>We will go over the precise meaning of the usage of the colon symbol in the
above structure later in the chapter. For now, the meaning of this code snippet
is to produce a structure <em>ascribing</em> to the <code>MOD_ARITH</code> signature, or in other
words, implementing the <code>MOD_ARITH</code> specification. We see that it contains three
declarations, those being the functions declared in the signature itself. A key
note is that ascribing to a signature is akin to a contract - any structure
ascribing a signature <em>must</em> implement all the requisite components described by
the signature, or it will fail to ascribe, and result in a compile-time error
(similar to an ill-typed program).</p>
<p>It is not, however, the case that a structure cannot provide <em>more</em> information
than is strictly necessitated by the signature. Additional helper functions and
value bindings can be freely instantiated within a structure without affecting
ascription. Thus, honoring a contract only entails satisfying the terms agreed to
in the signature, without comment on going over. We will explore this idea more
later in the chapter when we discuss information hiding.</p>
<p>Using structures should be something that you are already familiar with - you do
it every time that you invoke <code>Int.compare</code>. To use the fields of a structure,
you access them using the name of the module, followed by a dot, followed by the name of whatever
you are trying to access. Thus, calling <code>Int.compare</code> means to access the function named
<code>compare</code> implemented within the structure named <code>Int</code>, which is provided as
part of the Standard ML Basis Library. To use the structure that we have just
implemented, we would similarly call <code>ModArith.mod_add</code>, for instance.</p>
<p>It is important to know that although a structure may contain values, a
structure is <em>not</em> a value. Structures and signatures exist on another &quot;level&quot;
of syntax outside that of expressions and values, and should not be mixed
interchangeably with them. For instance, it would be nonsense to write <code>val x = ModArith</code>, as you cannot bind <code>ModArith</code> to a value identifier.</p>
<p>It is often useful when thinking of structures and signatures to think of them
as &quot;elevated types and values&quot;, as there is a neat correspondence between the
two. A structure is really just a <em>package</em> of values (among other things, as
we will see later) that must &quot;type-check&quot; in that it must successfully ascribe
to its signature. As such, a structure can be regarded as a &quot;bundle of values&quot;,
and a signature as a &quot;bundle of types&quot;. This only skims the surface at what can
be done with modules, but it is a handy perspective to have.</p>
<h2 id="modules-a-study-in-modularity-1"><a class="header" href="#modules-a-study-in-modularity-1">Modules: A Study in Modularity</a></h2>
<p>Ultimately, the main goal that we seek to achieve with modules is, in fact,
<em>modularity</em>. As alluded to previously in this chapter, we have mentioned how we
would like to be able to <em>swap out</em> certain implementations for others as
necessary, to enforce clean boundaries of code dependency and produce more
maintainable code. As it stands, we have only seen modules used for conveniently
wrapping our code, however in this section we are going to discuss how modules
allow us to maintain multiple implementations of the same specification.</p>
<p>Consider the following signature for performing geometric operations on the
Cartesian plane:</p>
<pre><code class="language-sml">signature GEOMETRY =
sig
    type point

    val origin : point
    val rotate : point -&gt; real -&gt; point

    val get_x : point -&gt; real
    val get_y : point -&gt; real
    val get_dist : point -&gt; real
end
</code></pre>
<p>Suppose that we are interested in performing operations on points within the
Cartesian plane. Then, we may be interested in a structure ascribing to this
signature. The question then becomes - how should this signature be implemented?
We have previously discussed swapping out more code for more efficient
implementations, however in that case we clearly consider one unilaterally
superior to the other.</p>
<p>In this signature, note that we have left the type of <code>point</code> <em>abstract</em>, meaning that it
is up to the structure to define what precisely the type of <code>point</code> is - it is
not decided by the signature. In this case, there are at least two discrete ways
that we can consider points on the Cartesian plane - as rectangular or polar coordinates.</p>
<p>Consider the following structures ascribing to the <code>GEOMETRY</code> signature:</p>
<pre><code class="language-sml">structure RectGeo : GEOMETRY =
struct
    (* pair of (x, y) coordinates *)
    type point = real * real

    val origin = (0.0, 0.0)
    fun rotate (x, y) r = (x * Math.cos r) + (y * Math.sin r)

    fun get_x (x, y) = x
    fun get_y (x, y) = y
    fun get_dist (x, y) = Math.sqrt (Math.pow (x, 2.0) + Math.pow (y, 2.0))
end

structure PolarGeo : GEOMETRY =
struct
    (* pair of (d, theta), where d is distance from origin and theta is angle from 0 degrees *)
    type point = real * real

    (* theoretically here theta could be anything *)
    val origin  = (0.0, 0.0)
    fun rotate (d, theta) r = (d, theta + r)

    fun get_x (d, theta) = d * (Math.cos theta)
    fun get_y (d, theta) = d * (Math.sin theta)
    fun get_dist (d, theta) = d
end
</code></pre>
<p>It should be relatively clear that these are two perfectly valid ways of
representing an (albeit limited) implementation of coordinate geometry. Both
have their own strengths and weaknesses, such as rectangular coordinates having
more convenient access to computing the x and y coordinates of a given point,
and polar coordinates more easily rotating points about the origin and
calculating the distance of a point from the origin. As such, it comes down to
<em>context</em> to determine which should be used in any given circumstance.</p>
<p>In this case, modules allow a convenient way of swapping out code without having
to bother with poring through to find dependencies. If we are using the
<code>PolarGeo</code> structure, and instead find ourselves wishing that we were using
rectangular coordinates instead - no problem! We can simply load the other
structure instead. In this case, we have moved dependencies and code reuse to a
static, compile-time check, much in the same way that we moved type-checking to
a static, compile-time check. This is a recurring theme, that we can avoid
deferring errors to runtime to instead try and catch them earlier, in order to
write cleaner and less error-prone code.</p>
<h2 id="modules-transparent-and-opaque-ascription-1"><a class="header" href="#modules-transparent-and-opaque-ascription-1">Modules: Transparent and Opaque Ascription</a></h2>
<p>At this point, we have discussed how to use modules for enforcing &quot;contracts&quot;
between parties interested in some kind of software, as well as how it can
assist in code reuse and statically enforcing code dependencies. Another use of
modules in the SML module system is <em>information hiding</em>.</p>
<p>It is sometimes said that one of the greatest ideas in computer science is
<em>abstraction</em>. Whether it is focusing on developing an algorithm to solve a problem, a
piece of software for a given client, or trying to interface with some existing
computer system, it is often the case that it is only prudent to focus on those
details that are <em>relevant to the problem</em>. It takes time and mental energy to
internalize every last detail of a codebase, and it is a waste of time to try
and do so every time that one wants to make a patch. As such, we rely on
abstraction in order to keep the amount of relevant information low.</p>
<p>Consider the computer. It is a complicated, convoluted work of machinery and
circuitry - at its most fundamental level being comprised of logic gates and
incredible networks of interacting parts. Although an action as simple as
opening up a notepad seems very intuitive to the user, under the hood it is
anything but. The key, however, is that the user of a computer need not
understand the underlying hardware and circuitry - indeed, they need not even
know what circuitry is! In the general case,
the user of a computer does not <em>really</em> know how it functions.</p>
<p>Yet again, it is also unlikely that it is important for you to know. A user of a
computer does not need to know precisely how it works to know that they can type
a query into Google. The only details that are <em>relevant to the user</em> are the devices that
allow interfacing with the inner hardware (the mouse and keyboard, among other
things), and less so the precise configuration of the microchips inside of the
machine.</p>
<p>When writing code, we would like to maintain the same practice. We would like to
write clear, concise, and <em>maintainable</em> code (for the unfortunate souls who
have to go back and read it afterwards), so it is important to lessen the burden
on the code-reader who comes after (which might be you!). With modules, we
will be able to create <em>enforced abstraction boundaries</em> that allow
programmers to only consider the <em>interface</em> of a given module, much in the same
way that a computer-user needs only consider the physical interface of the
device.</p>
<p>The first example of this phenomenon of information hiding is through the
contents of a structure that are available for use. We have spoken of signatures
as an interface, a sort of lens through which we view the contents of a
structure. This metaphor is further strengthened by the fact that a signature
literally does dictate what information the user of a structure is able to see.
In any structure ascribing to a given signature, the only data able to be used
by an outside client are those described within the signature.</p>
<p>Practically, this means that the use of &quot;helper functions&quot; in the implementation
of a structure is hidden from the client. This means that in the following
signature and structure:</p>
<pre><code class="language-sml">signature REVERSE =
sig
    val reverse : 'a list -&gt; 'a list
end

structure Reverse : REVERSE =
struct
    fun trev [] acc = acc
      | trev (x::xs) acc = trev xs (x::acc)

    fun reverse L = trev L []
end
</code></pre>
<p>only the value <code>reverse</code> is visible to the user of the <code>Reverse</code> structure. This
can be convenient in enforcing abstraction, because we could be writing a
program that uses helper functions that have certain preconditions. Through
restricting the usage of those helper functions, the client is blocked from
constructing certain inputs to those functions that may violate those
preconditions, resulting in unallowed behavior.</p>
<p>We have used the term &quot;ascription&quot; several times so far in this chapter,
referring to how a structure &quot;implements&quot; a signature, similarly to how a value
has a certain type. In reality, there are two kinds of ascription: transparent
and opaque. To demonstrate the difference, we will consider the following
implementation of 2D arrays.</p>
<pre><code class="language-sml">signature ARRAY =
sig
    type 'a array
    val new : int * int -&gt; 'a -&gt; 'a array
    val get : 'a array -&gt; int * int -&gt; 'a array
    val set : 'a array -&gt; int * int -&gt; 'a -&gt; 'a array
end

structure RectArray : ARRAY =
struct
    type 'a array = 'a list list

    fun row 0 v = []
      | row n v = v :: row (n - 1) v

    fun new (0, width) v = []
      | new (height, width) v =
        row w v :: new (height - 1, width) v

    fun get A (y, x) =
        List.nth (List.nth (A, y), x)

    fun set A (y, x) v =
        let
          val row = List.nth (A, y)
        in
          List.update (A, y, List.update (row, x, v))
        end
end
</code></pre>
<p>This implementation of arrays uses a 2D list in order to create a rectangular
array, with separate access to each row. There is one &quot;creator&quot; function, <code>new</code>,
which constructs a new array, and get the &quot;getter&quot; and &quot;setters&quot; of <code>get</code> and
<code>set</code>, which allow manipulation of an existing array. The structure <code>RectArray</code>
thus ascribes to the <code>ARRAY</code> signature, and because of its usage of the colon
symbol, it <em>transparently ascribes</em> to the <code>ARRAY</code> signature. We are now ready
to discuss precisely what this means.</p>
<blockquote>
<p><strong>[Transparent ascription]</strong>: Ascribing a structure to a signature where all
abstract types are visible to the user of the structure.</p>
</blockquote>
<p>We have previously discussed the existence of <em>abstract types</em>, which are type
declarations in the signature that is being ascribed to. For instance, the type
of <code>'a array</code> is an abstract type, because it is not concretely defined within
the signature. However, if we had instead replaced that line in the <code>ARRAY</code>
signature with <code>type 'a array = 'a list list</code>, it would no longer be abstract
(and note that this would have the consequence that any structure ascribing to
<code>ARRAY</code> <em>must</em> use the representation of a 2D list for its arrays).</p>
<p>What precisely does it mean for the type of <code>'a array</code> to be visible to the user
of the structure? We know that the user of a structure should only be aware of
what is in the signature of a structure, and nothing more. This is not strictly
true - if we have a transparently ascribed structure like <code>RectArray</code>, then the
user of the <code>RectArray</code> structure can treat the <code>'a RectArray.array</code> type as
synonymous with <code>'a list list</code>, and thus be privy to the &quot;internals&quot; of the
structure, even though it is not explicitly defined within the structure.</p>
<p>We will now compare this to if we had instead used opaque ascription. Consider
the following two implementations of the <code>ARRAY</code> signature:</p>
<pre><code class="language-sml">structure ListArray :&gt; ARRAY =
struct
    type 'a array = 'a list * int

    fun gen 0 v = []
      | gen n v = v :: gen (n - 1) v

    fun new (height, width) v =
        (gen (height * width) v, width)

    fun get (A, w) (y, x) = List.nth (A, w * y + x)

    fun set (A, w) (y, x) v = List.update (A, w * y + x, v)
end

structure RectArray :&gt; ARRAY =
struct
    type 'a array = 'a list list

    fun row 0 v = []
      | row n v = v :: row (n - 1) v

    fun new (0, width) v = []
      | new (height, width) v =
        row w v :: new (height - 1, width) v

    fun get A (y, x) =
        List.nth (List.nth (A, y), x)

    fun set A (y, x) v =
        let
          val row = List.nth (A, y)
        in
          List.update (A, y, List.update (row, x, v))
        end
end
</code></pre>
<p>Note that the latter implementation is exactly the same as the previous
<code>RectArray</code> structure, with the exception that is now <em>opaquely ascribed</em>. This
is from using <code>:&gt;</code> between the structure and signature names, which signals
opaque ascription rather than transparent ascription.</p>
<blockquote>
<p><strong>[Opaque ascription]</strong>: Ascribing a structure to a signature where all
abstract types are hidden to the user of the structure.</p>
</blockquote>
<p>By &quot;hidden&quot;, we mean precisely in the same way that the abstract types are
&quot;visible&quot; in transparent ascription. Abstract types are truly that, <em>abstract</em>,
and thus the user of either the <code>RectArray</code> or <code>ListArray</code> structure are
incapable of knowing precisely what either the <code>'a ListArray.array</code> or <code>'a RectArray.array</code> types are. The only way to construct a value of type <code>'a array</code>, from either structure, is by using either respective <code>new</code> function, and
similarly with manipulating an existing array.</p>
<p>Why would we want to have opaque ascription? This is precisely for the reason
that we have been motivating for the entire chapter, which is abstraction. A
fundamental idea of having a powerful type system is to <em>make illegal states
unrepresentable</em>. Instead of having a precondition that must be obeyed in a
given function, we instead would like it so that the type system enforces these
preconditions for us instead - similarly to how for a function of type <code>int -&gt; int</code> with precondition &quot;TRUE&quot;, if we were to instead write it in a dynamically
typed (&quot;typeless&quot;) language, we may instead say that it has a precondition that
its input is an integer. This is then just an extension of that idea to more
general representation invariants.</p>
<p>By <em>representation invariant</em>, we typically mean some invariant of a data
structure that qualifies it to truly be an &quot;instance&quot; of that data structure.
For instance, in the <code>RectArray</code> structure, we use a 2D list to represent a
given array, however it is not the case that <em>all</em> values of type <code>'a list list</code>
correspond to an array of <code>'a</code> values. For instance, is <code>[[1, 2, 3], [4, 5]]</code> a
valid <code>int RectArray.array</code>?</p>
<p>If <code>RectArray</code> were to be transparently ascribed, a client could construct an
illegal instance of an <code>'a RectArray.array</code>, and thus produce undefined behavior
when interfacing with it using functions like <code>get</code> and <code>set</code>. By opaquely
ascribing it to its signature, however, we ensure that the <em>only</em> way that you
can produce and manipulate arrays is internally, through the structure itself,
so as long as the structure's functions preserve representation invariants,
there will be no way of producing an illegal state.</p>
<p>Another motivation is that, ultimately, it isn't important for the client to
know how arrays are implemented - this is an example of <em>information hiding</em>.
If a client wants some implementation of the <code>ARRAY</code> signature, it likely isn't that
important to them whether or not it is implemented as a one-dimensional or two-dimensional
list, so long as it provides certain functionality (which, while limited in this example,
could be extended). We can thus ensure that it is completely impossible to distinguish <code>ListArray</code>
and <code>RectArray</code>, at least in terms of their input-output behavior. This benefits abstraction in
that now the client does not have to think about the fiddley details of
implementation, but instead focus purely on the interface.</p>
<p>We thus see that transparent ascription is useful for cases where knowing a
representation is totally fine (or when debugging), but opaque ascription is in
general the best approach when constructing a library. To clients of a given
software package, it is best to enforce abstraction.</p>
<h2 id="conclusions-5"><a class="header" href="#conclusions-5">Conclusions</a></h2>
<p>In this chapter, we have explored the powerful benefits that are given by SML's
module system, particularly in terms of <em>information hiding</em>, <em>abstraction</em>, and
<em>modularization</em>. While modules are in themselves of significant theoretical
interest, there are many practical applications to their use, and they offer a
clean and concise way to structure large codebases. In the next chapter, we will
explore <em>functors</em>, which are like a <em>higher-order structure</em> that allows us a greater degree of freedom
in structuring our code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functors"><a class="header" href="#functors">Functors</a></h1>
<p><em>By Cooper Pierce and Brandon Wu, February 2021</em></p>
<p>We have so far discussed the usage of modules for explicitly structuring our
code, in that we are afforded a degree of <em>modularity</em> in how the different
components of some software can fit together. We have used language like
&quot;swapping out&quot; modules or &quot;substituting&quot; modules for one another, but this is
very imprecise. What exactly do we mean when we say to swap one module for
another? Certainly, it would be messy to have to go through our code and change
every mention of <code>StructureA</code> for <code>StructureB</code>, and we would like to avoid some
kind of global change that requires an extenuous amount of effort on the
client's part.</p>
<p>Going through and changing every mention of a particular structure in order to
achieve &quot;modularization&quot; is akin to saying that using a particular higher-order
function by replacing specifically what each function parameter is in each
invocation is how we can achieve &quot;parameterization&quot; in the function argument. In
reality, this does not offer any more versatility. In this chapter, we will
discuss <em>functors</em>, which are akin to <em>higher-order modules</em>, which are allowed
to take other modules in as arguments.</p>
<h2 id="functors-the-basics"><a class="header" href="#functors-the-basics">Functors: The Basics</a></h2>
<p>Firstly, consider the signature of a stack.</p>
<pre><code class="language-sml">signature STACK =
sig
    type 'a t

    val push : 'a t -&gt; 'a -&gt; 'a t
    val pop : 'a t -&gt; 'a option * 'a t
    val size : 'a t -&gt; int
    val empty : 'a t
end

</code></pre>
<p>Suppose that we would like to <em>extend</em> the definition of a stack such that it
has a limit on how many elements that it contains. However, we don't necessarily
know which implementation of a stack to use - there could be several such
existing implementations, so we would like to instead make our <code>BoundedStack</code>
structure a <em>parameter of</em> an existing structure ascribing to <code>STACK</code>.</p>
<p>We will then use a very similar signature to <code>STACK</code> called <code>BOUNDED_STACK</code>,
which is the exact same except for having an <code>exception Full</code> for use if a stack
is given too many elements.</p>
<pre><code class="language-sml">signature BOUNDED_STACK =
sig
    type 'a t
    exception Full

    val push : 'a t -&gt; 'a -&gt; 'a t
    val pop : 'a t -&gt; 'a option * 'a t
    val size : 'a t -&gt; int
    val empty : 'a t
end
</code></pre>
<p>We first consider the case where we have a hard limit of 10 items in a given
stack.</p>
<pre><code class="language-sml">functor BoundedStack (S : STACK) :&gt; BOUNDED_STACK =
struct
    type 'a t = 'a S.t

    val limit = 10
    exception Full

    fun push S x =
        if S.size S &gt;= limit
          then raise Full
          else S.push S x

    fun pop S = S.pop S

    fun size S = S.size S

    val empty = S.empty
end
</code></pre>
<p>We see that most of this code is duplicated - we have based the majority of the
design of this <code>BoundedStack</code> in terms of <code>S</code>, which is the given implementation
of a stack. The correctness of a <code>BoundedStack</code> is thus totally dependent on
whether or not the given <code>S</code> is correct, but we achieve <em>modularity</em> in that we
can freely swap out a structure ascribing to <code>STACK</code> for another when
instantiating a given <code>BoundedStack</code>.</p>
<p>To put it concretely, suppose that we have two structures:</p>
<pre><code class="language-sml">structure Stack1 :&gt; STACK =
struct
    (* some code here *)
end

structure Stack2 :&gt; STACK =
struct
    (* some code here *)
end
</code></pre>
<p>Then we can create instances of the <code>BoundedStack</code> functor as follows:</p>
<pre><code class="language-sml">structure BoundedStack1 = BoundedStack(Stack1)
structure BoundedStack2 = BoundedStack(Stack2)
</code></pre>
<p><strong>NOTE</strong>: SML functors are <em>generative</em>, meaning that applying the same functor
to the same structure twice yields two unique structures. As such,
if we had <code>structure BS1 = BoundedStack(Stack1)</code> and <code>structure BS2 = BoundedStack(Stack1)</code>, then the types <code>BS1.t</code> and <code>BS2.t</code> are recognized as being two
distinct types, despite the fact that they are &quot;constructed&quot; in the same manner.</p>
<p><code>BoundedStack1</code> and <code>BoundedStack2</code> implement <code>BOUNDED_STACK</code>, so they all can access
the fields of the <code>BOUNDED_STACK</code> signature. Presumably, the only change they display
from <code>Stack1</code> and <code>Stack2</code> are in raising the exception <code>Full</code> when the stack is given more than
ten elements.</p>
<h2 id="functors-syntactic-sugar"><a class="header" href="#functors-syntactic-sugar">Functors: Syntactic Sugar</a></h2>
<p>SML offers some &quot;syntactic sugar&quot; for functor arguments, allowing us to
(seemingly) parameterize them by terms other than structures. It is a little
unsavory to have to hard code the limit of the <code>BoundedStack</code> within the functor
itself, rather than having it be parameterized by the limit itself, so we can
actually also write the following:</p>
<pre><code class="language-sml">functor BoundedStack (structure S : STACK
                      val limit : int) :&gt; BOUNDED_STACK =
struct
    type 'a t = 'a S.t

    exception Full

    fun push S x =
        if S.size S &gt;= limit
          then raise Full
          else S.push S x

    fun pop S = S.pop S

    fun size S = S.size S

    val empty = S.empty
end
</code></pre>
<p>The only difference is that instead of taking in a single <code>S : STACK</code>, we
specify &quot;<code>structure S : STACK val limit : int</code>&quot; within the parentheses of the
functor's input. Note that there are no commas or delimiters other than spaces.</p>
<p>In reality, this is something of a lie. While this seems to give the impression
that <code>BoundedStack</code> is taking in <em>two</em> things, a structure named <code>S</code> ascribing
to <code>STACK</code> and a value of type int named <code>limit</code>, in reality functors can only
take in other structures. This is thus <em>syntactic sugar</em> for the following code:</p>
<pre><code class="language-sml">functor BoundedStack (UnnamedStructure :
                      sig
                        structure S : STACK
                        val limit : int
                      end) :&gt; BOUNDED_STACK =
struct
    open UnnamedStructure
    (* same code as before *)
end
</code></pre>
<p>The <code>open</code> keyword specifies to <em>open</em> the namespace within a given module,
effectively promoting all contents of it to the top level. Thus, if we were to
<code>open Stack1</code>, as per our previous example, we could write <code>push</code> instead of
<code>Stack1.push</code>, <code>pop</code> instead of <code>Stack1.pop</code>, and so on and so forth. Thus, what
this syntactic sugar does is specify to take in a <em>single structure</em> ascribing
to a signature that <em>contains</em> a structure ascribing to <code>STACK</code> and an int-typed
value, named <code>S</code> and <code>limit</code> respectively.</p>
<p><strong>CAUTION</strong>: This is a very important point to cognize! This can be the source
of many frustrated hours of debugging due to a simple syntax error.</p>
<p>The reason why we must <code>open UnnamedStructure</code> in order to be able to use the
same code is because we cannot say <code>S.push</code>, for instance, as we did in the
original implementation of <code>BoundedStack</code>. We would instead have to specify
<code>UnnamedStructure.S.push</code>, which is not what our previous code says. However, if
we <code>open UnnamedStructure</code> first, the <code>S</code> structure is promoted to the top
level, and we can now access it without first having to go through
<code>UnnamedStructure</code>.</p>
<p>The reason for naming the input structure <code>UnnamedStructure</code> should hopefully
now be clear. Indeed, it is a <em>phantom structure</em> of a sort, since in the
syntactic sugar case, we never give it a name, and indeed we never really
acknowledge its existence at all. Yet it is important to realize what is really
happening, that there really <em>is</em> a structure being taken in as input, and then
immediately opened for its contents.</p>
<p>What issues can occur if we forget about the existence of this syntactic sugar?
Consider the following code:</p>
<pre><code class="language-sml">functor BoundedStack (structure S : STACK) :&gt; BOUNDED_STACK =
struct
    type 'a t = 'a S.t

    val limit = 10
    exception Full

    fun push S x =
        if S.size S &gt;= limit
          then raise Full
          else S.push S x

    fun pop S = S.pop S

    fun size S = S.size S

    val empty = S.empty

end

structure BoundedStack1 = BoundedStack(Stack1)
structure BoundedStack2 = BoundedStack(Stack2)
</code></pre>
<p>This code <em>will not compile!</em> Can you see why?</p>
<p>The issue is that we have added a prefix of <code>structure</code> to <code>S : STACK</code> within
the inputs. Even though we have only specified one field, not including the
<code>limit</code> as a parameter, this will be interpreted as the following:</p>
<pre><code class="language-sml">functor BoundedStack (UnnamedStructure :
                      sig
                        structure S : STACK
                      end) :&gt; BOUNDED_STACK =
struct
    type 'a t = 'a S.t

    val limit = 10
    exception Full

    fun push S x =
        if S.size S &gt;= limit
          then raise Full
          else S.push S x

    fun pop S = S.pop S

    fun size S = S.size S

    val empty = S.empty

end

structure BoundedStack1 = BoundedStack(Stack1)
structure BoundedStack2 = BoundedStack(Stack2)
</code></pre>
<p>Thus, <code>BoundedStack</code> is no longer a functor taking in a structure ascribing to
<code>STACK</code>, but a functor taking in a structure ascribing to <code>sig structure S: STACK end</code>. In other words, taking in a structure <em>containing</em> a structure
ascrbing to <code>STACK</code>! Thus, the line <code>structure BoundedStack1 = BoundedStack(Stack1)</code> will not type-check, as <code>Stack1</code> does not ascribe to the
same signature that <code>BoundedStack</code> is expecting. This one simple syntax error
can be the source of much pain and frustration, so we caution the reader to be
particular with their syntax, and mindful of what is really happening under the
hood.</p>
<h2 id="case-study-typeclasses"><a class="header" href="#case-study-typeclasses">Case study: Typeclasses</a></h2>
<p>Certain types have some functionality or operation in common. Depending on the
operation in question, we can say that these types fall into the same
<em>typeclass</em>, which is a common interface consisting of a type and the desired
operations. Note that typeclass membership is not a formally defined
relationship, but instead a useful categorization that we use in order to
classify types that we intend to parameterize some implementation over.</p>
<p>For a concrete example of a typeclass, consider the <code>ORDERED</code> typeclass.</p>
<pre><code class="language-sml">signature ORDERED =
sig
    type t
    val compare : t * t -&gt; order
end
</code></pre>
<p>The <code>ORDERED</code> typeclass consists of those types that admit a <em>sensible
ordering</em>, which we will not (and perhaps cannot) define. Thus, we can witness
<code>int</code> and <code>string</code> as valid instances of the <code>ORDERED</code> typeclass with the
following structures:</p>
<pre><code class="language-sml">structure IntOrder : ORDERED =
struct
    type t = int
    val compare = Int.compare
end

structure StringOrder : ORDERED =
struct
    type t = string
    val compare = String.compare
end
</code></pre>
<p>Note that it is useful, in this case, for our instances of the <code>ORDERED</code>
typeclass to be <em>transparently ascribed</em>, since it is the whole point that we
are aware of the type that the typeclass is associated with.</p>
<p><strong>NOTE</strong>: In actuality, we use transparent ascription as somewhat of a
sledgehammer to avoid having to talk about a different language construct,
namely <code>where</code> clauses. A <code>where</code> clause modifies a signature containing an
abstract type, and concretely specifies what that type should be. For instance,
we could discuss the signature <code>signature ORDERED type t end where type t = int</code>. A structure ascribing to this signature would &quot;publish&quot; the details of the
type <code>t</code> (which is really an <code>int</code>), the same way that transparent ascription
would. With <code>where</code> clauses, however, if there are multiple abstract types, we
can be selective about which ones that are made &quot;transparent&quot;. For the purposes
of this chapter, however, we will largely avoid <code>where</code> clauses.</p>
<p>These definitions come very naturally from the fact that the <code>String</code> and <code>Int</code>
libraries included with the Standard ML basis library already implement
<code>compare</code> fields, however we can also define types such as <code>int list</code> to be
instances of <code>ORDERED</code>:</p>
<pre><code class="language-sml">structure IntListOrder : ORDERED =
struct
    type t = int list
    fun compare [] [] = EQUAL
      | compare [] ys = LESS
      | compare xs [] = GREATER
      | compare (x::xs) (y::ys) =
        case Int.compare (x, y) of
            EQUAL =&gt; compare xs ys
          | LESS =&gt; LESS
          | GREATER =&gt; GREATER
end
</code></pre>
<p>This structure defines a <em>lexicographic ordering</em> on int lists, using the fact
that values of type <code>int</code> are already ordered. It prioritizes the relative
comparison of the corresponding elements of both lists first, and then the
length (akin to how a dictionary is ordered).</p>
<p>Indeed, we can take this one step further and see that lexicographic orderings
form a <em>functor</em>, in that we can parameterize the ordering of some type of list,
given that we can order the elements of the list. Like a higher-order function,
this saves us from having to repeat the same code over and over to declare
<code>StringListOrder</code> and <code>CharListOrder</code> structures, instead encapsulating the
common pattern. We can implement the <code>LexicListOrder</code> functor as follows:</p>
<pre><code class="language-sml">functor LexicListOrder (O : ORDERED) : ORDERED =
struct
    type t = O.t list
    fun compare [] [] = EQUAL
      | compare [] ys = LESS
      | compare xs [] = GREATER
      | compare (x::xs) (y::ys) =
        case O.compare (x, y) of
            EQUAL =&gt; compare xs ys
          | LESS =&gt; LESS
          | GREATER =&gt; GREATER
end
</code></pre>
<p>Note that since an instantiation of the <code>LexicListOrder</code> functor is itself a
structure ascribing to <code>ORDERED</code>, it can be &quot;passed in&quot; as input to <em>itself</em>,
resulting in <em>any</em> type of nested list being an instance of <code>ORDERED</code>, so long
as the base type is also an instance of <code>ORDERED</code>.</p>
<p>It is also useful to note that <em>equality types</em> in Standard ML are essentially a
language-supported typeclass, akin to inbuilt support for the following
signature:</p>
<pre><code class="language-sml">signature EQ =
sig
    type t
    val equal : t * t -&gt; bool
end
</code></pre>
<p>The operations for <code>equal</code> for each &quot;instance&quot; of the typeclass are instead
defined by Standard ML itself, and not user-defined. Thus, we can think of the
equality operator <code>=</code> as simply invoking the <code>T.equal</code> method for the proper
typeclass <code>T</code>, defined by the type that is being compared for equality.</p>
<p>In this next section, we will explore a concrete use for typeclasses when
designing functors.</p>
<h2 id="case-study-red-black-trees"><a class="header" href="#case-study-red-black-trees">Case study: Red-black trees</a></h2>
<p>Typeclasses can be important when we are attempting to place some greater
constraint on the types that may instantiate some universal type. In certain
cases, we do not want the types that we are considering to truly be <em>any</em> type,
but any of a limited subset of types that share some common characteristic or
implement some operation. We will study the use of <em>red-black trees</em> as the
underlying data structure for dictionaries.</p>
<p>A dictionary is a simple data structure that maps keys to values. Consider its
signature given below.</p>
<pre><code class="language-sml">signature DICT =
sig
    type key
    type 'a dict
    val empty : 'a dict
    val insert : 'a dict -&gt; key * 'a -&gt; 'a dict
    val lookup : 'a dict -&gt; key -&gt; 'a option
end
</code></pre>
<p>It is a well-known fact that, utilizing a kind of <em>balanced binary tree</em> data
structure, dictionaries can be implemented with an \( O(\log n) \) <code>insert</code> and
<code>lookup</code> operation, as opposed to \( O(n) \) for other data structures such as
lists. While there are many different implementations of balanced binary trees,
we will consider a particular variant known as <em>red-black trees</em>.</p>
<blockquote>
<p><strong>[Red-black tree]</strong>: A variant of self-balancing binary tree that ensures
logarithmic search and insert time. It is named because of its nodes, which
are marked as either <em>red</em> or <em>black</em>. Furthermore, it obeys the following
properties:</p>
<ol>
<li>All leaves are black.</li>
<li>The children of a red node must be black.</li>
<li>Any path from a given node to a leaf node must go through the same number
of black nodes.</li>
</ol>
<p>Note that as a variant of binary search tree, a red-black tree must also
satisfy the invariant that the key stored at a node must be greater than or
equal to every key in the left subtree, and less than or equal to every key in
the right subtree.</p>
</blockquote>
<p>It is easy to reason about why this schema ensures that we have the proper
asymptotic bound for search - the third property in particular ensures that, for
any path from the root, the length of the longest path from the root to a leaf
is at most twice that of the shortest path. This is because the longest such
path you can construct from the root to a leaf (minimizing black nodes) is by
alternating black and red nodes.</p>
<p>This means that a given red-black tree is not as strictly balanced as some other
variants (for instance, AVL trees), however it is always <em>approximately</em>
balanced.</p>
<p>We would like to create a structure for red-black tree dictionaries. There are
some options that we have - we could simply hard-code a <code>TypeRedBlackDict :&gt; DICT</code> for any type <code>Type</code>, except that this would
entail quite a bit of repeated code (and exertion on our part). Another solution
would be to make the type of <code>'a dict</code> doubly-polymorphic instead - something
like an <code>('a, 'b) dict</code>, where <code>'a</code> is the type of the dict's keys and <code>'b</code> the
type of its contents. However, then we lose the guarantee that <code>'a</code> is a type
that supports comparison, which means that we cannot satisfy the tree's
invariants.</p>
<p>The solution we will turn to is exactly similar to that as discussed in the
previous section - we will instead design a <code>RedBlackDict</code> functor that takes in
a typeclass implementing <code>ORDERED</code>, and exports a structure whose keys are the
type of the given typeclass. We thus will define our functor with the following
preliminaries:</p>
<pre><code class="language-sml">functor RedBlackDict (Key : ORDERED) :&gt; DICT =
struct
    type key = Key.t
    datatype color = Red | Black
    datatype 'a dict = Leaf | Node of 'a dict * (color * (key * 'a)) * 'a dict

    val empty = Leaf
    (* ... *)
end
</code></pre>
<p>Because we take as input a <code>Key</code> structure ascribing to <code>ORDERED</code>, we have
access to the <code>Key.compare</code> function, which we will use when inserting into our
dictionary. We define a <code>color</code> type (which only consists of the constant
constructors <code>Red</code> and <code>Black</code>) for tagging the nodes of the red-black tree
(leaves are considered to be black).</p>
<p>The question becomes: how should we implement insert? We cannot be so naive as
to simply insert as we would in an ordinary binary search tree, as this would
quickly cause problems with our invariants. In particular, we must be mindful of
the <em>black height</em> invariant, saying that all paths to leaves must have the same
number of black nodes on them.</p>
<p>The easiest case to tackle for insert is the <code>Leaf</code> case. How should we finish
the definition of <code>fun insert Leaf (k, v) = </code>? Well, clearly we must insert a
<code>Node(Leaf, (c, (k, v)), Leaf)</code> for some color <code>c</code>. Note that since a <code>Leaf</code> is
considered to be colored black, if we choose <code>c</code> to be <code>Black</code>, we will run into
issues with our black height invariant - we have replaced a <code>Leaf</code> (a subtree of
black height 1) with a subtree of black height 2! This will disproportionately
affect the black height of paths ending in this subtree, thus causing the
invariant to be violated.</p>
<p>Thus, the only sensible choice we can commit is to insert as a <code>Red</code> node. The
astute reader may see that this will quickly cause issues - we will address this
shortly. Thus, we can write</p>
<pre><code class="language-sml">fun insert Leaf (k, v) = Node(Leaf, (Red, (k, v)), Leaf)
  | insert (Node (L, (c', (k', v')), R)) (k, v) = ...
</code></pre>
<p>How should we handle the <code>Node</code> case? Well, insertion really only happens at the
leaves - the only thing that we can do at a <code>Node</code> is to propagate the change
throughout the tree until it gets to where it needs to be. We have seen that
this schema of an &quot;always-red&quot; insertion maintains the black-height invariant,
however there is the <em>red-children</em> invariant as well - the children of a red
node must themselves be red. This invariant is the one that we are not
respecting, with our current schema.</p>
<p>So we only run into an issue when we insert into the tree such that the new node
is the child of a red node. Furthermore, we know that, if the tree that we are
inserting into is truly a red-black tree, it must respect the red-children
invariant, and thus the the parent of the inserted node must itself have a black
parent. Thus, there can only be four cases for the &quot;site&quot; of the insertion:</p>
<figure class="aligncenter">
    <img src="concepts/../assets/redblack.svg" alt="Cases" width="1000"\>
    <figcaption><b>Fig 1.</b> Illustration of the four cases of the red-children
    invariant being broken following insertion. The inserted nodes are marked
    with a "plus". </figcaption>
</figure>
<p>Such an invariant violation is only a local concern, however. All that is needed
in order to restore the invariant is to simple <em>rotate</em> the site of violation,
and do a simple recoloring. We will illustrate only the first case, and the rest
follow similarly. You may verify for yourself that this continues to preserve
the ordering and black-height invariants.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/balance.svg" alt="Balance" width="1000"\>
    <figcaption><b>Fig 2.</b> Illustration of the "balancing" necessary in order
    to preserve the red-children invariant in Case 1 of Fig. 1. </figcaption>
</figure>
<p>We thus write the following function which takes care of all four cases.</p>
<pre><code class="language-sml">fun balance (Node(Node(Node(a,(Red,x),b), (Red,y), c), (Black, z), d)) =
            Node(Node(a,(Black,x),b),  (Red,y), Node(c,(Black,z),d))
  | balance (Node(a,(Black,x), Node(Node(b,(Red,y),c), (Red, z), d))) =
            Node(Node(a,(Black,x),b), (Red,y), Node(c,(Black,z), d))
  | balance (Node(Node(a, (Red,x), Node(b,(Red,y),c)), (Black,z), d)) =
            Node(Node(a,(Black,x),b), (Red, y), Node(c,(Black,z),d))
  | balance (Node(a, (Black,x), Node(b, (Red,y), Node(c,(Red,z), d)))) =
            Node(Node(a,(Black,x),b), (Red,y), Node(c,(Black,z), d))
  | balance T = T
</code></pre>
<p>Note that if we are not in any of the four described cases, <code>balance</code> simply
acts as the identity function, as there is no invariant being broken.</p>
<p>However, this rotation may itself cause another site of red-children invariant
violation, slightly farther up. As such, we must <em>propagate</em> this balancing
operation as far up as necessary, in order to produce a proper binary tree at
the very end. To this end, we can write the following code for the inductive
case of <code>insert</code>:</p>
<pre><code class="language-sml">fun insert Leaf (k, v) = Node(Leaf, (Red, (k, v)), Leaf)
  | insert (Node (L, (c', (k', v')), R)) (k, v) =
    case Key.compare (k, k') of
        LESS =&gt; balance(Node(insert L (k, v), (c', (k', v')), R))
      | EQUAL =&gt; Node(L, (c', (k, v)), R)
      | GREATER =&gt; balance(Node(L, (c', (k', v')), insert R (k ,v)))
</code></pre>
<p>This code ensures that, after descending into a subtree in order to insert the
given key and value, a balancing operation is immediately performed once the
insertion is complete. This ensures that we have a <em>bottom-up</em> propagation of
balancings, immediately after completing the insertions. Note that because
<code>balance</code> acts as the identity function on anything that does not pattern-match
to either of the four cases, we perform only a negligible amount of extra checks
at each recursive call, and ultimately are only concerned with those four cases.</p>
<p>However, this code is not complete. There is a minor edge case that remains -
what if we are too close to the root for any of the four cases to apply? Our
previous analysis relied on the fact that we could assume that the parent of our
inserted node was red, and thus had a black parent - what of the case where the
parent of the inserted node <em>has no</em> parent?</p>
<p>Consider the case illustrated below:</p>
<figure class="aligncenter">
    <img src="concepts/../assets/insert.svg" alt="Example of inserting two nodes into an empty tree" width="1000"\>
    <figcaption><b>Fig 3.</b> Demonstration of potential issues in inserting nodes at the root when lacking a black parent. </figcaption>
</figure>
<p>As we can see here, our previous reasoning does not catch this red-children
violation because it does not conform to our previous cases, by virtue of the
inserted node not having a grandfather. This case can <em>only</em> happen at the root,
however, since that is the only location where that can occur. As a result, the
simple solution is to simply make the root of any red-black tree black - it will
preserve the black height invariant, but also result in this red-red violation
being impossible. We can amend our code as follows:</p>
<pre><code class="language-sml">fun insert' Leaf (k, v) = Node(Leaf, (Red, (k, v)), Leaf)
  | insert' (Node (L, (c', (k', v')), R)) (k, v) =
    case Key.compare (k, k') of
        LESS =&gt; balance(Node(insert' L (k, v), (c', (k', v')), R))
      | EQUAL =&gt; Node(L, (c', (k, v)), R)
      | GREATER =&gt; balance(Node(L, (c', (k', v')), insert' R (k ,v)))

fun insert T (k, v) =
    case insert' T (k, v) of
        Leaf =&gt; Leaf
      | Node (L, (_, (k', v')), R) =&gt; Node(L, (Black, (k', v')), R)
</code></pre>
<p>Finally, this results in our completed code for the <code>insert</code> function. Note that
because of the signature that we are ascribing to, helper functions such as
<code>balance</code> and <code>insert</code> will not be visible to the client of the module, so there
is no harm in declaring them within the namespace of the functor.</p>
<p>Our completed code for a red-black tree implementation of dictionaries is thus
as follows. Note that the implementation of <code>lookup</code> is very straightforward, and</p>
<pre><code class="language-sml">functor RedBlackDict (Key : ORDERED) :&gt; DICT =
struct
    type key = Key.t
    datatype color = Red | Black
    datatype 'a dict = Leaf | Node of 'a dict * (color * (key * 'a)) * 'a dict

    val empty = Leaf

    fun balance (Node(Node(Node(a,(Red,x),b), (Red,y), c), (Black, z), d)) =
                Node(Node(a,(Black,x),b),  (Red,y), Node(c,(Black,z),d))
      | balance (Node(a,(Black,x), Node(Node(b,(Red,y),c), (Red, z), d))) =
                Node(Node(a,(Black,x),b), (Red,y), Node(c,(Black,z), d))
      | balance (Node(Node(a, (Red,x), Node(b,(Red,y),c)), (Black,z), d)) =
                Node(Node(a,(Black,x),b), (Red, y), Node(c,(Black,z),d))
      | balance (Node(a, (Black,x), Node(b, (Red,y), Node(c,(Red,z), d)))) =
                Node(Node(a,(Black,x),b), (Red,y), Node(c,(Black,z), d))
      | balance T = T

    fun insert' Leaf (k, v) = Node(Leaf, (Red, (k, v)), Leaf)
      | insert' (Node (L, (c', (k', v')), R)) (k, v) =
        case Key.compare (k, k') of
            LESS =&gt; balance(Node(insert' L (k, v), (c', (k', v')), R))
          | EQUAL =&gt; Node(L, (c', (k, v)), R)
          | GREATER =&gt; balance(Node(L, (c', (k', v')), insert' R (k ,v)))

    fun insert T (k, v) =
        case insert' T (k, v) of
            Leaf =&gt; Leaf
          | Node (L, (_, (k', v')), R) =&gt; Node(L, (Black, (k', v')), R)

    fun lookup Leaf k = NONE
      | lookup (Node (L, (_, (k', v)), R)) k =
        case Key.compare (k, k') of
            LESS =&gt; lookup L k
          | EQUAL =&gt; SOME v
          | GREATER =&gt; lookup R k
end
</code></pre>
<p>In the end, usage of modules allows us to write a powerful, parameterized
implementation of a dictionary interface, in such a way that we ensure that our
<em>representation invariants</em> are respected throughout each operation. By making
a structure ascribing to the <code>ORDERED</code> typeclass a parameter of the functor
<code>RedBlackDict</code>, we allow powerful generality in the type of the key to the
dictionary, without having to introduce additional overhead in the functions of
the module itself.</p>
<h2 id="conclusions-6"><a class="header" href="#conclusions-6">Conclusions</a></h2>
<p>In this chapter, we have seen how functors are a potent tool when structuring
our code, that allows us to enforce modularity and implement code reuse <em>within
the language itself</em>. Functors also form the basis for a kind of <em>higher-order
module</em>, where we can parameterize the structures we are capable of creating by
other structures themselves, resulting in a greater degree of expression and
versatility not unlike those of higher-order functions themselves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequences"><a class="header" href="#sequences">Sequences</a></h1>
<p><em>By Kaz Zhou, January 2021</em>. <em>Revised April 2021</em></p>
<p>In programming, we often need to write fast algorithms that use enumerable collections. Currently we use the list datatype to represent enumerable collections. There are some crucial limitations of lists though.</p>
<p>A great application of SML's modules system is the sequence signature. The implementation of sequences (which is specific to 15150) allows for parallelism and accessing any element in O(1) time; it also comes with some helpful functions.</p>
<p>Similar to our notation for lists, our notation for sequences looks like <code>&lt;x_1, x_2, x_3, ..., x_n&gt;</code>.</p>
<h2 id="sequences-vs-lists"><a class="header" href="#sequences-vs-lists">Sequences vs. Lists</a></h2>
<p>Here are some advantages / disadvantages of sequences and lists. Considering sequences and lists purely from an algorithm-writing perspective, the only con of sequences is the slow cons operation.</p>
<table><thead><tr><th></th><th>Sequences</th><th>Lists</th></tr></thead><tbody>
<tr><td>Accessing element i</td><td>O(1)</td><td>O(i)</td></tr>
<tr><td>Parallelism</td><td>✅</td><td>❌</td></tr>
<tr><td>Pattern matching</td><td>❌</td><td>✅</td></tr>
<tr><td>cons operation</td><td>O(n) work</td><td>O(1) work</td></tr>
<tr><td>Writing proofs</td><td>Difficult</td><td>Relatively easy</td></tr>
</tbody></table>
<h2 id="important-sequence-functions"><a class="header" href="#important-sequence-functions">Important sequence functions</a></h2>
<p>Some frequently used sequence functions are <code>nth</code>, <code>tabulate</code>, <code>map</code>, <code>filter</code>, and <code>reduce</code>. For a comprehensive documentation of the sequence library, see http://www.cs.cmu.edu/~15150/resources/libraries/sequence.pdf. The following section will define each of the functions, give examples of their usage, and analyze their work and span.</p>
<h3 id="seqnth"><a class="header" href="#seqnth"><code>Seq.nth</code></a></h3>
<p>The function <code>Seq.nth</code> allows for extracting any element from a sequence in O(1) work and span. This is a significant advantage over lists, which could take up to O(n) work and span, in the case of finding the last element of the list. <code>Seq.nth</code> has type <code>'a seq -&gt; int -&gt; 'a seq</code>.</p>
<p>An example: Let's say the sequence <code>S</code> is bound to the value <code>&lt;0, 1, 2&gt;</code>, which has type <code>int seq</code>. Then,</p>
<ul>
<li><code>Seq.nth S 0</code> evaluates to <code>0</code></li>
<li><code>Seq.nth S 2</code> evaluates to <code>2</code></li>
<li><code>Seq.nth S 5</code> raises an exception <code>Range</code>, which occurs when the index is too large or small.</li>
</ul>
<h3 id="seqtabulate"><a class="header" href="#seqtabulate"><code>Seq.tabulate</code></a></h3>
<p>This is a very common tool for constructing a sequence. The type of <code>Seq.tabulate</code> is <code>(int -&gt; 'a) -&gt; int -&gt; 'a seq</code>. The first argument is a function which maps an index to a value, and the second argument is an integer specifying the length of the sequence. In general:</p>
<p><code>Seq.tabulate f n ==&gt; &lt;f 0, f 1, f 2, ..., f (n-1)&gt;</code></p>
<p>As a concrete example:</p>
<p><code>Seq.tabulate (fn i =&gt; i) 5 ==&gt; &lt;0, 1, 2, 3, 4&gt;</code></p>
<p>Let's try writing a function that reverses a sequence. For example,</p>
<p><code>reverse &lt;0, 1, 2, 3, 4&gt; ==&gt; &lt;4, 3, 2, 1, 0&gt;</code></p>
<p>This function <code>reverse</code> would have type <code>'a seq -&gt; 'a seq</code>. In the above example, we have a sequence of length 5. The element at index 0 moves to index 4, the element at index 1 moves to index 3, ..., the element at index 4 moves to index 0. Generally, if the sequence has length <code>n</code>, the element at index <code>i</code> should move to <code>n - i - 1</code>. It's pretty easy to make off-by-one errors here, so be careful and test sequence functions thoroughly! The implementation of <code>reverse</code> is as follows:</p>
<pre><code>fun reverse S =
  let
    val n = Seq.length S
  in
    Seq.tabulate (fn i =&gt; Seq.nth S (n-i-1)) n
  end
</code></pre>
<p>It's also possible to write functions that deal with nested sequences. Let's write a function <code>multtable : int -&gt; int seq seq</code> that, when given a positive integer <code>n</code>, makes an <code>n</code> by <code>n</code> multiplication table. For example,</p>
<pre><code>multtable 5 ==&gt;
&lt;&lt;0,0,0,0,0&gt;,
 &lt;0,1,2,3,4&gt;,
 &lt;0,2,4,6,8&gt;,
 &lt;0,3,6,9,12&gt;,
 &lt;0,4,8,12,16&gt;&gt;
</code></pre>
<p>This time, the function that we're tabulating with needs to output a sequence, like <code>&lt;0,2,4,6,8&gt;</code>.</p>
<p>Here is the implementation:</p>
<pre><code>fun multtable n =
  Seq.tabulate (fn i =&gt;
    Seq.tabulate (fn j =&gt; i*j) n) n
</code></pre>
<p>Let's analyze the work of <code>multtable</code>. The function <code>(fn i =&gt; Seq.tabulate (fn j =&gt; i*j) n)</code> has <code>O(n)</code> work. This is since the function evaluates <code>i*j</code> (for different values of <code>j</code>) <code>n</code> times. The function is called <code>n</code> times (from the outer tabulate). Therefore, the total work of this function is <code>O(n^2)</code>.</p>
<p>For the span analysis, note that the function <code>(fn i =&gt; Seq.tabulate (fn j =&gt; i*j) n)</code> has <code>O(1)</code> span, because <code>i*j</code> is evaluated in parallel for all the different values of <code>j</code>. Then, the entire function has <code>O(1)</code> span because the function <code>(fn i =&gt; Seq.tabulate (fn j =&gt; i*j) n)</code> is called all in parallel.</p>
<p>In general, the cost graph for <code>Seq.tabulate</code> looks like this.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/tabulatecost.png"
    width="600" class="center"/>
    <figcaption>The cost graph for Seq.tabulate. Each branch at the top represents a different independent task for the processor(s) to perform.  </figcaption>
</figure>
<p>The work of <code>Seq.tabulate f S</code> is the sum of all costs in the graph above. The span is the maximum cost of any one of the branches, because the function is called on 0, 1, ..., n-1 in parallel.</p>
<h3 id="seqmap"><a class="header" href="#seqmap"><code>Seq.map</code></a></h3>
<p><code>Seq.map</code> is similar to <code>List.map</code>. The type of <code>Seq.map</code> is <code>('a -&gt; 'b) -&gt; 'a seq -&gt; 'b seq</code>. Given a function <code>f : 'a -&gt; 'b</code> and a sequence <code>&lt;x_1, x_2, x_3, ..., x_n&gt; : 'a seq</code>, we have:</p>
<pre><code>Seq.map f &lt;x_1, x_2, x_3, ..., x_n&gt; = &lt;f x_1, f x_2, f x_3, ..., f x_n&gt;
</code></pre>
<p>The work of evaluating the above expression is (work of doing <code>f x_1</code>) + (work of doing <code>f x_2</code>) + ... + (work of doing <code>f x_n</code>).
The calls <code>f x_1, f x_2, f x_3, ..., f x_n</code> are all done in parallel. So, the span is the max of (span of doing <code>f x_1</code>, span of doing <code>f x_2</code>, ..., span of doing <code>f x_n</code>).</p>
<h3 id="seqreduce"><a class="header" href="#seqreduce"><code>Seq.reduce</code></a></h3>
<p><code>Seq.reduce</code> is like <code>List.foldr</code>, but with sequences. The type is <code>Seq.reduce : ('a * 'a -&gt; 'a) -&gt; 'a -&gt; 'a seq -&gt; 'a</code>. In English, <code>Seq.reduce</code> takes in a combining function, a base value, and a sequence to &quot;reduce&quot;. For example, <code>Seq.reduce g z &lt;x_0, x_1, x_2, ..., x_n&gt;</code> is extensionally equivalent to <code>g(x_0, g(x_1, g(x_2, ..., g(x_n, z)))... )</code>. Notice that the combining function is <code>'a * 'a -&gt; 'a</code> instead of <code>'a * 'b -&gt; 'b</code>, as in <code>List.foldr</code>.</p>
<p>The neat part is, <code>Seq.reduce</code> also supports parallelism. In particular, when a combining function <code>g</code> has constant span, then <code>Seq.reduce g z S</code> has O(log |S|) span. We pay a slight cost: the function <code>g</code> must be associative, which means that <code>g(g(a,b),c) = g(a,g(b,c))</code> for all <code>a,b,c</code>. Furthermore, <code>z</code> must be the identity for <code>g</code>, which means <code>g(a,z) = g(z,a) = a</code> for all <code>a</code>.</p>
<p>To analyze the work and span, let's consider how SML actually evaluates <code>Seq.reduce g z S</code>. It first calls the combining function <code>g</code> on each pair of elements: <code>x_0</code> and <code>x_1</code>, <code>x_2</code> and <code>x_3</code>, and so on. All of these calls can be made in parallel. Then, we combine the intermediate results together. At the very end, all of the elements of <code>S</code> will be combined together.</p>
<figure class="aligncenter">
    <img src="concepts/../assets/reducecost.png"
    width="600" class="center"/>
    <figcaption>The cost graph for Seq.reduce. Each branch at the top represents a different independent task for the processor(s) to perform.  </figcaption>
</figure>
<p>The work is the sum of doing all the work shown in the cost graph, while the span is the longest path through the cost graph. Therefore, for constant <code>g</code>, the work of <code>Seq.reduce g z S</code> is O(|S|), and the span is O(log |S|).</p>
<p>An example of using this function is finding the sum of a sequence. So, <code>Seq.reduce (op +) 0 &lt;1, 2, 3, 4&gt;</code> evaluates to <code>10</code>.</p>
<h3 id="seqfilter"><a class="header" href="#seqfilter"><code>Seq.filter</code></a></h3>
<p>Again, a sequence function is analogous to a list function. <code>Seq.filter</code> is like <code>List.filter</code>. It takes in a predicate function of type <code>'a -&gt; bool</code> and a sequence of type <code>'a seq</code>, and keeps elements <code>x</code> such that <code>p x</code> evaluates to true. However, <code>Seq.filter</code> is optimized for parallel performance. The work is O(|S|). The span is O(log |S|), which may seem surprising as the predicate function may be applied to all elements in parallel. However, it is difficult to find out the number of elements that satisfy the predicate, and thus it's not possible to find the length of the filtered sequence in O(1). The implementation details are tricky, but use a divide-and-conquer approach just like <code>Seq.reduce</code>.</p>
<h3 id="seqappend"><a class="header" href="#seqappend"><code>Seq.append</code></a></h3>
<p>Just like <code>@</code>, the function <code>Seq.append : 'a seq * 'a seq -&gt; 'a seq</code> puts two sequences together. The work to create the appended sequence, such as in the call <code>Seq.append (S1,S2)</code>, is O(|S1| + |S2|). To justify this, think about how <code>Seq.append</code> may be implemented using <code>Seq.tabulate</code>. The tabulating function maps indices between 0 and |S1|-1 to elements from S1, and maps indices between |S1| and |S1 + S2| - 1 to elements from S2. Additionally, the span of <code>Seq.append</code> is O(1) regardless of the input sequences. This makes intuitive sense because <code>Seq.tabulate</code> also has O(1) span, when given a constant tabulating function.</p>
<h2 id="examples-of-functions-involving-sequences"><a class="header" href="#examples-of-functions-involving-sequences">Examples of functions involving sequences</a></h2>
<h2 id="exercise-pascals-triangle"><a class="header" href="#exercise-pascals-triangle">Exercise: Pascal's triangle</a></h2>
<p>Our task is to write a function <code>pascal : int -&gt; int seq seq</code>. Given a nonnegative integer <code>n</code>, <code>pascal n</code> evaluates to the first <code>n+1</code> rows of Pascal's triangle. For example:</p>
<pre><code>pascal 5 =
&lt;&lt;1&gt;,
 &lt;1,1&gt;,
 &lt;1,2,1&gt;,
 &lt;1,3,3,1&gt;,
 &lt;1,4,6,4,1&gt;,
 &lt;1,5,10,10,5,1&gt;&gt;
</code></pre>
<p>Let's try to do this task without using the formula for entries of Pascal's triangle. The 0th row of Pascal's triangle is our base case. Then, we can add elements from the (n-1)th row to calculate elements in the nth row (in parallel!). This is an incremental approach: we add one row of the answer at a time.</p>
<p>This problem has a bit of a dynamic programming flavor, in that we should remember the previous row to help calculate new rows. One issue is that using <code>Seq.append</code> or <code>Seq.cons</code> to add a row to a sequence is expensive. However, remember the pros and cons of sequences vs. lists! Adding on a row to a list requires just O(1) work. Therefore, our approach for this problem will use both sequences and lists. The solution is below. Note that it uses the function <code>reverse</code> from the <code>Seq.tabulate</code> section of this article.</p>
<pre><code>fun pascalH 0 = [Seq.singleton 1]
  | pascalH n =
    let
      val (prev::rest) = pascalH (n-1)
      fun rowmaker 0 = 1
        | rowmaker i =
          if i = n then 1
          else Seq.nth prev i + Seq.nth prev (i-1)
      val new = Seq.tabulate rowmaker (n+1)
    in
      new::prev::rest
    end

fun pascal n = reverse (Seq.fromList (pascalH n))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-evaluation"><a class="header" href="#lazy-evaluation">Lazy Evaluation</a></h1>
<p><em>By Len Huang, Cooper Pierce, and Brandon Wu, January 2021. Rewritten by Thea Brick, April 2022.</em></p>
<p>In programming languages, there's a few different strategies by which arguments
of a function call are evaluated. One you should be familiar with is <strong><em>eager</em></strong>
evaluation. SML is an <strong><em>eager</em></strong> language. In other words, we evaluate the
arguments first. We'll be discussing how to &quot;implement&quot; the exact
opposite form of evaluation: <strong><em>lazy</em></strong> evaluation. In <strong><em>lazy</em></strong> evaluation,
arguments are evaluated as needed. To implement this, we'll make use of an idea
called <strong>thunks</strong>.</p>
<h2 id="eager-vs-lazy"><a class="header" href="#eager-vs-lazy">Eager vs Lazy</a></h2>
<h3 id="eager-evaluation-1"><a class="header" href="#eager-evaluation-1">Eager Evaluation</a></h3>
<p>Let's say I have the function <code>double : int -&gt; int</code> which doubles a number, and
<code>square : int -&gt; int</code>, which squares a number. In both <strong><em>lazy</em></strong> and
<strong><em>eager</em></strong> evaluation, <code>double (square (double 2)) ==&gt;* 32</code>. However, they differ
in the way which they &quot;arrive&quot; at <code>32</code>. SML is an eager language, so the code
(eagerly) steps as follows:</p>
<pre><code class="language-sml">val double : int -&gt; int = fn n =&gt; 2 * n
val square : int -&gt; int = fn n =&gt; n * n

(* Eager *)
    double (square (double 2))
==&gt; double (square 4)
==&gt; double 16
==&gt; 32
</code></pre>
<p>You can see that we evaluated the arguments first. However, when doing things
lazily, arguments will be evaluated as <em>needed</em>. The notion of <em>need</em> will be
subjective relative to what's being implemented. The question now remains, since
SML is eager, how do we do things lazily?</p>
<h3 id="introducing-laziness-with-thunks"><a class="header" href="#introducing-laziness-with-thunks">Introducing Laziness with Thunks</a></h3>
<p>Since SML is an eager language, to have lazy evaluation we must simulate it in
some way. To do this, we need a way to wait until we <em>need</em> an argument to
evaluate it. This is where <strong>thunks</strong> come into play. A <strong>thunk</strong> is a function
of type <code>unit -&gt; t</code> for some type <code>t</code>. They help us represent this notion of
&quot;evaluation by need&quot; by wrapping an expression in a function, which delays
the computation of that expression.</p>
<p>Let's say we have some function <code>f</code> and argument <code>x</code>. When we run <code>f x</code>, <code>x</code>
will get evaluated immediately. However, by wrapping <code>x</code> inside a function,
we can delay its computation <em>(assume <code>f</code>'s type is correct)</em>: <code>f (fn () =&gt; x)</code>.
Since <strong><em>functions are values</em></strong>, this lambda function is already fully evaluated.
However, <code>x</code> has yet to be evaluated! Now we can wait to evaluate <code>x</code> by passing
in <code>() : unit</code> to the lambda function at some point. A lambda expression is like
a lawn mower on a cord - it has the potential to start doing some kind of work,
but not until its cord is pulled.</p>
<p>Let's see how that changes things in our earlier example. Here, we change <code>square</code>
into a lazy version that accepts a <strong>thunk</strong> instead of an <code>int</code>.</p>
<pre><code class="language-sml">val double : int -&gt; int = fn n =&gt; 2 * n
fun square (f : unit -&gt; int) : int = f () * f ()

(* Lazy *)
    double (square (fn () =&gt; double 2))
==&gt; double ((fn () =&gt; double 2) () * (fn () =&gt; double 2) ())
==&gt; double (double 2 * double 2)
==&gt; double (4 * 4)
==&gt; double 16
==&gt; 32
</code></pre>
<p>You can see that with lazy evaluation, we put off the computation of <code>double 2</code>
until we &quot;needed it&quot;. That &quot;need&quot; is subjective, but the key idea is that we
delayed the computation of <code>double 2</code> by wrapping it a <strong>thunk</strong>. Lets see
what this looks like in normal algebra.</p>
<p><strong>NOTE</strong>: You can see that the computation was &quot;put off&quot; since we had to
recompute the value of <code>double 2</code> twice. This seems rather inefficient, since we
don't want to have to recompute every time we use the value of some expression
multiple times. In other <em>lazy languages</em> that use a primarily lazy evaluation
strategy, there tends to be a sophisticated system of <em>memoization</em> (or,
remembering values) so that values do not have to be recomputed.</p>
<pre><code class="language-sml">(* Eager *)                  (* Lazy *)
    2 * (2 * 2)^2                2 * (2 * 2)^2
==&gt; 2 * (4)^2                ==&gt; 2 * ((2 * 2) * (2 * 2))
==&gt; 2 * (4 * 4)              ==&gt; 2 * (4 * 4)
==&gt; 2 * 16                   ==&gt; 2 * 16
==&gt; 32                       ==&gt; 32
</code></pre>
<p><strong>NOTE</strong>: In another sense, in a lazy setting, the final computed value of <code>2 * (2 * 2)^2</code> is just the computation of <code>2 * (2 * 2)^2</code> itself. Lazy evaluation is lazy because it
does not move until it is forced to - thus, in this example, we have shown how
algebraically we can obtain the final value of <code>2 * (2 * 2)^2</code> <em>when forced</em>,
where we use the term &quot;forcing&quot; to refer to forcing a lazy expression to
evaluate to a traditional &quot;value&quot;.</p>
<p>Since <code>square</code> is now the lazy function, we are delaying the evaluation of
<code>square</code>'s arguments. That's why in eager evaluation, we just do <code>2 * 2 ==&gt; 4</code>
before we square that value, whereas in lazy evaluation, we square the
unevaluated arguments by doing <code>(2 * 2) * (2 * 2)</code>.</p>
<p><em>Note, we let the type of a <strong>thunk</strong> be <code>unit -&gt; 'a</code> just because it's convenient.</em>
<em>Theoretically we could use a different type to represent thunks since all we need</em>
<em>is a way to wrap an expression in a function to delay its computation.</em></p>
<h2 id="lazy-lists"><a class="header" href="#lazy-lists">Lazy Lists</a></h2>
<p>Now that we have established this notion of <strong><em>laziness</em></strong> in SML, we can do
even fancier things, like create <em>infinite data structures</em>! Unlike regular data
structures, infinite data structures have the potential to encode an <em>unbounded</em>
amount of data. Let's first look at
a lazy list and compare it to a normal list.</p>
<pre><code class="language-sml">datatype 'a list     = [ ] |  ::  of 'a * 'a list
datatype 'a lazylist = Nil | Cons of 'a * (unit -&gt; 'a lazylist)
</code></pre>
<p>You'll see that a <code>lazylist</code> is very similar to normal <code>list</code>s. The only difference
is that the computation of the list's tail has been delayed with a thunk.
Just like before where we delayed computation of arguments for functions, we are now delaying the
computation of arguments for constructors. You can sort of think of it like
instead of having <code>x::xs</code>, we now have <code>x::(fn () =&gt; xs)</code>. This can help us create
infinite lists since the true computation of the list tail is always delayed.</p>
<p>For example, if I wanted to represent a list of fibonacci numbers, I could do:</p>
<pre><code class="language-sml">val fibs : int lazylist =
    let
        fun fib' x y = Cons(x, fn () =&gt; fib' y (x + y))
    in
        fib' 0 1
    end

(* Iterate through lazy list *)
val Cons(a1, f1) = fibs
val Cons(a2, f2) = f1 ()
val Cons(a3, f3) = f2 ()
val Cons(a4, f3) = f3 ()
val Cons(a5, f5) = f4 ()

(* Test cases *)
val 0 = a1
val 1 = a2
val 1 = a3
val 2 = a4
val 3 = a5
</code></pre>
<p>Here, we have a value <code>fibs : int lazylist</code> that represents the entire list of
fibonacci numbers. Instead of immediately evaluating the tail of the list, the
lazy list allows us to wait until a later time to continue iterating the list.
We can exploit this by later triggering the evaluation of <code>fib' y (x + y)</code>.</p>
<p>Note that if you tried to do this with normal lists, we would get some circular
evaluation since the computation is not being delayed. For example:</p>
<pre><code class="language-sml">(* Example REPL Output *)

- fun fib x y = x::(fib' y (x + y));

val fib = fn : int -&gt; int -&gt; int list

- fib 0 1;

uncaught exception Overflow [overflow]
  raised at: &lt;file stdIn&gt;
</code></pre>
<p>We get an <code>exception Overflow</code> since SML is trying to eagerly evaluate the
arguments passed into the constructor <code>::</code>. This causes it to go into an
infinite loop and eventually overflow.</p>
<blockquote>
<p>&quot;What's the tail of the list? I'm eager and I evaluate the arguments of the
constructor first! Why it's <code>fib y (x + y)</code>! How exciting. Let's evaluate
this. Well <code>fib y (x + y) ==&gt; y::(fib (x + y) (y + (x + y)))</code>. What's the
tail of the list? I'm eager and I evaluate the arguments of the constructor
first! Why it's <code>fib (x + y) (y + (x + y))</code>! How exciting. Let's evaluate
this...</p>
<p><em>a few steps later...</em></p>
<p>Why it's <code>fib ((y + (x + y)) + ((x + y + (y + (x + y))))) (((x + y + (y + (x + y)))) + ((y + (x + y)) + ((x + y + (y + (x + y))))))</code>!
dang this is one thicc expression. It's time to surrender and
<code>raise exception Overflow [overflow]</code>. We'll get em next time 😞</p>
<p><em>- The inner dialogue of the SML Compiler</em></p>
</blockquote>
<h2 id="thunks-and-continuations"><a class="header" href="#thunks-and-continuations">Thunks and Continuations</a></h2>
<p>Another way to think of <strong>thunks</strong> is in relation to continuations. We've seen
before continuations being passed into functions as a way to represent <em>what
instructions need to be executed</em>. Here, we are using the same idea but rather
than forcing all those instructions to be executed now, we are passing them off
so that they can be done when and if they are needed.</p>
<p>In the <code>fibs</code> example we can see this where the <code>lazylist</code> is defined to be the
specific element of the fibonacci sequence, and a continuation (thunk) to
produce the next element (along with a new continuation to compute the next next
element, and so on infinitely).</p>
<p>Another example that may be more enlightening is the function that tries to
find all elements in a list that satisfy some predicate <code>p</code>:</p>
<pre><code class="language-sml">fun listFind (p : 'a -&gt; bool) ([] : 'a list) : 'a lazylist = Nil
  | listFind p (x::xs) =
        if p x
        then Cons (x, fn () =&gt; listFind p xs)
        else listFind p xs

val p = fn x =&gt; x mod 2 = 0
val res : int lazylist = listFind p [1,2,3,4]
</code></pre>
<p>Here, <code>res</code> would be bound to <code>Cons(2, fn () =&gt; listFind p [3,4])</code>. Our program
is basically saying &quot;I found this element, 2, that satisfies your predicate, and
if you'd like to find another element: here's a continuation/thunk that will do
that for you&quot;. So rather than having to evaluate a predicate (with a
potentially large cost-bound) over a potentially huge list, we can be lazy, and
only look at what we need.</p>
<h1 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h1>
<p>Even though SML is an eager language, we can utilize <strong>thunks</strong> to delay the
computation of arguments. This allows us to simulate and represent a more
<strong>lazy</strong> style of evaluation, where we evaluate arguments <em>as needed</em>. Using
this idea, we can even represent things like infinite lists in SML!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imperative-programming"><a class="header" href="#imperative-programming">Imperative Programming</a></h1>
<p><em>By Len Huang and Cooper Pierce, February 2021</em></p>
<p>A fun thing we can do with functional programming in SML is imperative
programming! Does it seem counterintuitive? Perhaps. Is it cool? OF COURSE!
Background knowledge with languages like C, C++, Java, and Python will be
helpful but is not required.</p>
<h2 id="reference-cells"><a class="header" href="#reference-cells">Reference Cells</a></h2>
<p>The way SML goes about implementing imperative features is by using something
called <strong><em>reference types</em></strong>. These are <strong><em>references</em></strong> to a value of a
certain type. This is very similar to how a pointer might point to a certain
place in memory. More formally:</p>
<blockquote>
<p>A value of type <code>t ref</code> is a mutable cell capable of holding a value of type
<code>t</code>. For example, an <code>int ref</code> is a reference to an <code>int</code>.</p>
</blockquote>
<p><em>Reference Cells, Ref Cells, and Mutable Cells all refer to the same thing in</em>
<em>this article.</em></p>
<h2 id="functions--expressions-to-know"><a class="header" href="#functions--expressions-to-know">Functions / Expressions to Know</a></h2>
<p>There's a few different expressions and functions we can leverage to help us
interface with these <strong><em>reference types</em></strong>.</p>
<h3 id="ref-cells-ref"><a class="header" href="#ref-cells-ref">Ref Cells <code>ref</code></a></h3>
<p>First, we need to make something of this reference type. In other words, we
need a way to initialize our pointers. <code>ref</code> is also a constructor that helps
us initializes references (not to be confused with the <code>'a ref</code> type.) Below is
how we would make a reference to an <code>int value</code>, or, an <code>int ref</code>.</p>
<pre><code class="language-sml">(* ref : 'a -&gt; 'a ref *)
val pointer : int ref = ref 7
</code></pre>
<h3 id="bang-"><a class="header" href="#bang-">Bang <code>!</code></a></h3>
<p>Next, we need a way to get our values from these references. In other words, we
need a way to dereference our pointers. <code>!</code> (called bang) can be used
on an <code>'a ref</code> to retrieve the value being referenced.</p>
<pre><code class="language-sml">(* ! : 'a ref -&gt; 'a *)
val pointer : int ref = ref 7
val x : int = !pointer
</code></pre>
<p>Here, the value <code>7 : int</code> would be bound to <code>x</code>.</p>
<h3 id="assignment-"><a class="header" href="#assignment-">Assignment <code>:=</code></a></h3>
<p>After that, we need a way to update the data in our mutable cells. <code>:=</code>
(called the assignment operator) can be used to update the values of reference
types. Technically, it's an infix function that takes in the <code>'a ref</code> to
update and the <code>'a</code> value to update it to.</p>
<pre><code class="language-sml">(* := : 'a ref * 'a -&gt; unit *)
val pointer : int ref = ref 7
val x : int = !pointer
val () : unit = pointer := 21
val y : int = !pointer
</code></pre>
<p>Here, the value <code>7 : int</code> would be bound to <code>x</code>. However, the value <code>21 : int</code>
would be bound to <code>y</code>. When we dereference our ref-cell the first time, the
value is whatever we initialized it to (<code>7</code>). However, after we change what's
inside the ref-cell, we dereference the updated value (<code>21</code>). Even though
<code>x</code> and <code>y</code> are both bound to <code>!pointer</code>, they have different values!</p>
<blockquote>
<p>💡 Comparison to <code>void</code> methods!</p>
<p>Remember that SML is a functional programming language. This means that
anything that's not an exception or infinite loop must be a value! As
such, when we do things with side effects (like assignment), we can't
really have <em>no value</em> being returned. As such, SML implements this by
having these side effect functions and operations return <code>() : unit</code>.
Theoretically, <code>:=</code> could return something crazy, like an <code>'a tree list option</code>
if we really wanted to. It's just that <code>() : unit</code> is convenient.
So when you see <code>:= : 'a * 'a ref -&gt; unit</code>, you can think of it as a
<code>void</code> method or function in Java, C, and C++.</p>
<p>In other words, returning <code>() : unit</code> for the assignment operator is
SML's way of implementing <code>void</code> methods.</p>
</blockquote>
<p>Introducing imperative logic causes difficulties like these. It takes away the
confidence we have in our values instilled in us by referential transparency.
It often makes doing formal proofs about imperative code a bit more difficult.</p>
<h3 id="sequential-evaluation-"><a class="header" href="#sequential-evaluation-">Sequential Evaluation <code>;</code></a></h3>
<p>Finally, having a way to execute side effects but still return something
meaningful will be useful to use. Generally, <code>;</code> (yes this is just a
semicolon lol) lets us &quot;execute&quot; two &quot;programs&quot; in sequential order.
You see this used in the REPL:</p>
<pre><code>val x = 2 + 2;
val y = 8 - 4;
</code></pre>
<p>Where we execute one &quot;program&quot; with the side effect of binding <code>2 + 2</code>
to <code>x</code>, and then execute the next &quot;program&quot; with the side effect of
binding <code>8 - 4</code> to <code>y</code>, and continue to wait for the next &quot;program&quot;.
If you're familiar with languages like Java and C, this can also be
used to explain why semicolons are required at the end of each line.</p>
<p>The semicolon <code>;</code> is used to mark the end of one program and set up
the next program to sequentially follow. In SML (not just the REPL),
this is also valid syntax.</p>
<blockquote>
<p>For some expressions <code>exp1 : t1</code>, <code>exp2 : t2</code>, we have that <code>exp1;exp2 : t2</code>
where <code>exp1</code> is evaluated first, and then <code>exp2</code> is evaluated thereafter.</p>
</blockquote>
<p>One thing to note is that in SML, only the value of the second expression
is returned, and the type of the whole expression is the type of the last
expression.</p>
<pre><code class="language-sml">val pointer : int ref = ref 0
val x : int = (pointer := 7; !pointer)
val y : int = (pointer := 21; !pointer)
</code></pre>
<p>Here, we first initialize <code>pointer</code> to a dummy value. After that, we run
the program <code>pointer := 7</code>, and then right after, return <code>!pointer</code>. This
would mean that the value <code>7 : int</code> is bound to <code>x</code>, just like in the above
examples. Similarly, we run The program <code>pointer := 21</code>, and then right
after, return <code>!pointer</code>. This would mean that the value <code>21 : int</code> is
bound to <code>y</code>, just like in the above examples.</p>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it All Together</a></h2>
<p>Here's an example that uses all of the above operations in a meaningful way.</p>
<pre><code class="language-sml">local
    val a = ref 1
in
    fun fact 0 = !a
      | fact n = a := n * !a; fact (n - 1)
end
</code></pre>
<p>The way this <code>fact</code> function works is by continuously updating a reference
<code>a</code> we <strong>initialize</strong> with <code>ref a</code>. In the recursive case, for some number <code>n</code>,
we <strong>assign</strong> <code>a</code> to be <code>n * !a</code>. In other words, <code>n * current value of a</code>
(because we use the <strong>bang</strong> <code>!</code> to dereference <code>a</code>). After we run that
program (<code>a := n * !a</code>), the <strong>semicolon</strong> then brings us to the next program:
<code>fact (n - 1)</code>. Since only value of the second expression is returned, we
essentially are saying that <code>fact n = fact (n - 1)</code> with the side effect of
<code>a := n * !a</code> being run. Finally, once we reach the base case, we use the
<strong>bang</strong> <code>!</code> to dereference our ref cell which has accumulated all of
the side effects up until now.</p>
<blockquote>
<p>😰 If you try to call this implementation of <code>fact</code> more than once, something
unexpected might happen. Can you figure out what it is, and why that is?</p>
</blockquote>
<h1 id="operations"><a class="header" href="#operations">Operations</a></h1>
<ul>
<li><code>ref : 'a -&gt; 'a ref</code> initializes a new reference cell.</li>
<li><code>! : 'a ref -&gt; 'a</code> dereferences a reference cell.</li>
<li><code>:= : 'a ref * 'a -&gt; unit</code> assigns a reference cell a new value.
&quot;<code>void</code>&quot; method.</li>
<li><code>exp1;exp2</code> first runs <code>exp1</code> and then returns <code>exp2</code>, which is
useful for side effects.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sml-basics-examples"><a class="header" href="#sml-basics-examples">SML Basics Examples</a></h1>
<p><em>By Eunice Chen, May 2020</em></p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>For each of the following declarations, state the type and value of <code>x</code>.</p>
<pre><code class="language-sml">val x = 1 &gt; 5
</code></pre>
<p>Type: <code>bool</code></p>
<p>Value: <code>false</code></p>
<pre><code class="language-sml">val x = 15 div 0
</code></pre>
<p>Type: <code>int</code></p>
<p>Value: Does not reduce to a value because it raises an exception</p>
<pre><code class="language-sml">val x = 15.0 div 0.0
</code></pre>
<p>Type: not well-typed (<code>div</code> is a function of type <code>int * int -&gt; int</code>)</p>
<p>Value: No value, since it is not well-typed</p>
<pre><code class="language-sml">val x = fn (n : int) =&gt; Int.toString n
</code></pre>
<p>Type: <code>int -&gt; string</code></p>
<p>Value: <code>fn n =&gt; Int.toString n</code></p>
<pre><code class="language-sml">val x = fn n =&gt; (&quot;1&quot; ^ &quot;5&quot;) ^ (Int.toString n)
</code></pre>
<p>Type: <code>int -&gt; string</code></p>
<p>Value: <code>fn (n : int) =&gt; (&quot;1&quot; ^ &quot;5&quot;) ^ (Int.toString n)</code></p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<h3 id="example-0"><a class="header" href="#example-0">Example 0</a></h3>
<pre><code class="language-sml">let
  val y : int = 2
in
  fn (x : int) =&gt; z*z
end
</code></pre>
<p>What is the value of the let-in-end expression?</p>
<p>Value: No value, because <code>z</code> is not in scope (will cause an error).</p>
<h3 id="example-1"><a class="header" href="#example-1">Example 1</a></h3>
<pre><code class="language-sml">val y = 0
val z = 
    (let
      val x : int = 1
      fun f (x : int) = x
      val y : int = x + 1
    in
      fn (a : string) =&gt; x*2
    end) &quot;150&quot;
val a = y
</code></pre>
<p>What is the value of <code>y</code> before the let-in-end expression?</p>
<p>y = 0</p>
<p>What is the value of <code>y</code> within the let-in-end expression?</p>
<p>y = 2</p>
<p>What is the value of <code>a</code>?</p>
<p>a = 0</p>
<p>What is the value of <code>z</code>?</p>
<p>z = 2</p>
<h3 id="example-2"><a class="header" href="#example-2">Example 2</a></h3>
<pre><code class="language-sml">val x : int = 1 
fun f (x : int) = x + 1
val y : int = 2
val z : int = f y
val a : int = x
</code></pre>
<p>What are the values of <code>x</code>, <code>y</code>, <code>z</code>, and <code>a</code>?</p>
<p>x = 1</p>
<p>y = 2</p>
<p>z = 3</p>
<p>a = 1</p>
<h3 id="example-3"><a class="header" href="#example-3">Example 3</a></h3>
<pre><code class="language-sml">val x = 1
val y = 2
fun f (x, y) = 
    case x of 
      0 =&gt; 0
    | y =&gt; y
val a = f (y, x)
val b = f (x, y)
</code></pre>
<p>What are the values of <code>a</code> and <code>b</code>?</p>
<p>a = 2</p>
<p>b = 1</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion--induction"><a class="header" href="#recursion--induction">Recursion &amp; Induction</a></h1>
<p><em>By Eunice Chen, June 2020</em></p>
<h2 id="types-2"><a class="header" href="#types-2">Types</a></h2>
<p>For each of the following expressions, state its type and value.</p>
<pre><code class="language-sml">fun f (x : int) : int = f x
</code></pre>
<p>Type: <code>int -&gt; int</code><br />
Value: The value is the function itself</p>
<pre><code class="language-sml">val x = []::(150::[])
</code></pre>
<p>Type: <code>int list</code><br />
Value: [150]</p>
<pre><code class="language-sml">fun f L =
    case L of
      [] =&gt; [[]]
    | x::xs =&gt; [x] @ []
</code></pre>
<p>Type: not well-typed<br />
Value: no value, because it is not well-typed</p>
<p>What is the type and value of x?</p>
<pre><code class="language-sml">fun f (y : int) : int = f y
val x : int = f y
</code></pre>
<p>Type: int<br />
Value: No value, because it loops forever</p>
<p>What is the type and value of y?</p>
<pre><code class="language-sml">val x =
    let
      fun incr (n : int) = n + 1
    in
      incr
    end
val y = incr
</code></pre>
<p>Type: No type, since incr is not in scope<br />
Value: No value, since incr is not in scope</p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<h2 id="induction"><a class="header" href="#induction">Induction</a></h2>
<p>Given the following function:</p>
<pre><code class="language-sml">(* length: int list -&gt; int *)
fun length [] = 0
  | length x::xs = 1 + length(xs)

(* append: int list * int list -&gt; int list *)
fun append ([], L) = L
  | append (x::xs, L) = x :: append(xs, L)
</code></pre>
<p>Prove that for all <code>L1, L2 : int list</code>, <code>length(append(L1, L2))</code> = <code>length(L1) + length(L2)</code>.</p>
<p>Proof: By structural induction on <code>L1</code>.</p>
<p>BC: <code>L1 = []</code></p>
<p><code>length(append(L1, L2))</code><br />
= <code>length(append([], L2))</code><br />
= <code>length(L2)</code> [Clause 1 of append]</p>
<p><code>length(L1) + length(L2)</code><br />
= <code>length([]) + length(L2)</code><br />
= <code>0 + length(L2)</code> [Clause 1 of length]<br />
= <code>length(L2)</code> [math and totality of length]</p>
<p>IS: <code>L1 = x::xs</code> for some <code>x : int</code>, <code>xs : int list</code></p>
<p>IH: <code>length(append (xs, L2))</code> = <code>length(xs) + length(L2)</code></p>
<p>WTS: <code>length(append (x::xs, L2))</code> = <code>length(x::xs) + length(L2)</code></p>
<p><code>length(append (L1, L2))</code><br />
= <code>length(append (x::xs, L2)</code><br />
= <code>length (x::append(xs, L2))</code> [Clause 2 of append]<br />
= <code>1 + length(append(xs, L2))</code> [Clause 2 of length, totality of append]<br />
= <code>1 + length(xs) + length(L2)</code> [IH]</p>
<p><code>length(L1) + length(L2)</code><br />
= <code>length(x::xs) + length(L2)</code><br />
= <code>1 + length(xs) + length(L2)</code> [Clause 2 of length]</p>
<p>By structural induction, we have shown that for all <code>L1, L2 : int list</code>, <code>length(append(L1, L2))</code> = <code>length(L1) + length(L2)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about"><a class="header" href="#about">About</a></h1>
<p>SML Help is a joint venture between previous and current teaching assistants of
the computer science course 15-150: Principles of Functional Programming, taught
at Carnegie Mellon University. It is aimed at being a comprehensive and
accessible resource to students of 150, as well as those just interested in
learning functional programming concepts in general, as viewed through the lens
of the Standard ML language.</p>
<p>Teaching assistants form the backbone of 15-150, and SML Help no less. Without
them, this page would not have been possible. Special credit goes to Jacob
Neumann and Cam Wong for their instrumental work in getting the website working.</p>
<p>Contributors to SML Help include:</p>
<p>Brandon Wu, Cooper Pierce, David Sun, Eunice Chen, Harrison Grodin, James Gallicchio, Kaz Zhou and Len Huang</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
