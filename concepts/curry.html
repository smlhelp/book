<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Currying and Staging - SML Help</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A resource for learning SML">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Welcome!</a></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/install.html"><strong aria-hidden="true">1.1.</strong> Install & run SML</a></li><li class="chapter-item expanded "><a href="../start/syntax.html"><strong aria-hidden="true">1.2.</strong> Syntax Cheatsheet</a></li><li class="chapter-item expanded "><a href="../start/common.html"><strong aria-hidden="true">1.3.</strong> Common Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="../types/index.html"><strong aria-hidden="true">2.</strong> Types & Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/type.html"><strong aria-hidden="true">2.1.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/bool.html"><strong aria-hidden="true">2.1.1.</strong> bool</a></li><li class="chapter-item expanded "><a href="../types/int.html"><strong aria-hidden="true">2.1.2.</strong> int</a></li><li class="chapter-item expanded "><a href="../types/real.html"><strong aria-hidden="true">2.1.3.</strong> real</a></li><li class="chapter-item expanded "><a href="../types/string.html"><strong aria-hidden="true">2.1.4.</strong> string</a></li><li class="chapter-item expanded "><a href="../types/function.html"><strong aria-hidden="true">2.1.5.</strong> function types</a></li><li class="chapter-item expanded "><a href="../types/list.html"><strong aria-hidden="true">2.1.6.</strong> list</a></li><li class="chapter-item expanded "><a href="../types/options.html"><strong aria-hidden="true">2.1.7.</strong> options</a></li></ol></li><li class="chapter-item expanded "><a href="../types/sig.html"><strong aria-hidden="true">2.2.</strong> Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/basis.html"><strong aria-hidden="true">2.2.1.</strong> Basis Library Documentation</a></li><li class="chapter-item expanded "><a href="../types/aux-lib.html"><strong aria-hidden="true">2.2.2.</strong> Auxiliary Library Documentation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../debugging/index.html"><strong aria-hidden="true">3.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../debugging/errors.html"><strong aria-hidden="true">3.1.</strong> Common Errors</a></li><li class="chapter-item expanded "><a href="../debugging/hints.html"><strong aria-hidden="true">3.2.</strong> Debugging Hints</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/index.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/basic.html"><strong aria-hidden="true">4.1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/eval.html"><strong aria-hidden="true">4.1.1.</strong> Evaluation</a></li><li class="chapter-item expanded "><a href="../concepts/eeq.html"><strong aria-hidden="true">4.1.2.</strong> Extensional Equivalence</a></li><li class="chapter-item expanded "><a href="../concepts/patternmatch.html"><strong aria-hidden="true">4.1.3.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/recind.html"><strong aria-hidden="true">4.2.</strong> Recursion and Induction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/treeinduct.html"><strong aria-hidden="true">4.2.1.</strong> Tree Induction</a></li><li class="chapter-item expanded "><a href="../concepts/tail.html"><strong aria-hidden="true">4.2.2.</strong> Tail Recursion</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/analysis.html"><strong aria-hidden="true">4.3.</strong> Asymptotic Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/workspan.html"><strong aria-hidden="true">4.3.1.</strong> Work and Span</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/datatypes.html"><strong aria-hidden="true">4.4.</strong> Datatypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/poly.html"><strong aria-hidden="true">4.4.1.</strong> Parametric Polymorphism</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/hofs.html"><strong aria-hidden="true">4.5.</strong> Higher Order Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/curry.html" class="active"><strong aria-hidden="true">4.5.1.</strong> Currying and Staging</a></li><li class="chapter-item expanded "><a href="../concepts/common.html"><strong aria-hidden="true">4.5.2.</strong> Common HOFs and Partial Evaluation</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/control.html"><strong aria-hidden="true">4.6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/cps.html"><strong aria-hidden="true">4.6.1.</strong> Continuation Passing Style</a></li><li class="chapter-item expanded "><a href="../concepts/exn.html"><strong aria-hidden="true">4.6.2.</strong> Exceptions</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/mods.html"><strong aria-hidden="true">4.7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/mods.html"><strong aria-hidden="true">4.7.1.</strong> Basics and Ascription</a></li><li class="chapter-item expanded "><a href="../concepts/functors.html"><strong aria-hidden="true">4.7.2.</strong> Functors</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/apps.html"><strong aria-hidden="true">4.8.</strong> Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/sequences.html"><strong aria-hidden="true">4.8.1.</strong> Sequences</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/lazy.html"><strong aria-hidden="true">4.9.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../concepts/imperative.html"><strong aria-hidden="true">4.10.</strong> Imperative</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/index.html"><strong aria-hidden="true">5.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/basics.html"><strong aria-hidden="true">5.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="../examples/recursion.html"><strong aria-hidden="true">5.2.</strong> Recursion & Induction</a></li></ol></li><li class="chapter-item expanded "><a href="../about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SML Help</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="currying-and-staging"><a class="header" href="#currying-and-staging">Currying and Staging</a></h1>
<p><em>By Brandon Wu, June 2020</em></p>
<p>Suppose that we are interested in writing a function
that adds two numbers. This is fairly simple - this is not a new concept to us.</p>
<pre><code class="language-sml">fun add (x, y) = x + y
</code></pre>
<p>Then this function should clearly have type <code>int * int -&gt; int</code>. We also know
that this notation is really just syntactic sugar for the following:</p>
<pre><code class="language-sml">val add = fn (x, y) =&gt; x + y
</code></pre>
<p>It binds the lambda expression that takes in a tuple of two integers and adds
them together to the identifier of <code>add</code>. Yet with our knowledge of expressions
and values, it is not too outlandish to write the following instead:</p>
<pre><code class="language-sml">fun addCurry x = fn y =&gt; x + y
</code></pre>
<p>What might be the type of this function? Well, we know that <code>addCurry</code> takes in
a value <code>x</code>, which should be an <code>int</code>, since it is summed with <code>y</code>. It then
returns a lambda expression that takes in that same <code>y</code>, and returns the sum,
which is an <code>int</code>. It seems to us that the type should be <code>int -&gt; (int -&gt; int)</code>.
This is an example of a <em>curried</em> function, and one of the first examples we
will see of a <em>higher-order function</em>.</p>
<blockquote>
<p><strong>[Higher-Order Functions]</strong> A <em>higher-order function</em> is a function that
takes in other functions as input, or returns a function as output.</p>
</blockquote>
<blockquote>
<p><strong>[Currying]</strong> Named after mathematician/logician Haskell Brooks Curry,
<em>currying</em> is the act of transforming a function that takes multiple arguments into a
function that returns a function that takes the remaining arguments.
Intuitively, it separates the arguments into a series of function
applications, instead of all at once. We may refer to a general higher-order
function that returns a function as a curried function.</p>
</blockquote>
<p>An important note is that in the type <code>int -&gt; (int -&gt; int)</code>, the parentheses are
unnecessary. This is because type arrows are <em>right-associative</em>, in the same
way that <code>::</code> is. This means that there is already an implicit parentheses in
the type <code>int -&gt; int -&gt; int</code> - the function simply takes in an integer and
returns a function from <code>int -&gt; int</code>. This is thus a separate type than <code>(int -&gt; int) -&gt; int</code>, which is a function that takes in a function from <code>int -&gt; int</code> and
returns an integer.</p>
<p>Note that in the curried example of <code>addCurry</code> we wrote above, this is really
syntactic sugar for the following:</p>
<pre><code class="language-sml">val addCurry = fn x =&gt; fn y =&gt; x + y
</code></pre>
<p>Not being ones to skimp on the syntactic sugar (which perhaps spells danger for
our syntactic blood sugar levels), we can take this one step further. We can
write the exact same declaration in a more concise way, using the form:</p>
<pre><code class="language-sml">fun addCurry x y = x + y
</code></pre>
<p>This thus will curry our arguments for us, when we separate them by a space.</p>
<p>Note that our implementations of <code>addCurry</code> and <code>add</code> are <em>not</em> extensionally
equivalent - for the simple reason that they do not even have the same type!
They do, however, in a sense <em>correspond</em>, in that they seem to do the <em>same
thing</em> - that is, add numbers together. The manner in which they do so is
entirely disparate, however.</p>
<p>It is important to note that currying our functions gives us a notion of
<em>partial application</em>, where we can give a curried function only <em>some</em> of its
&quot;arguments&quot;. This lends us to further specialization and modularity based on the
use case and amount of information available. This is discussed more in the
coming section.</p>
<h2 id="revisiting-extensional-equivalence"><a class="header" href="#revisiting-extensional-equivalence">Revisiting Extensional Equivalence</a></h2>
<p>In previous chapters, we have explored the idea of extensional equivalence, and
constructed a definition for extensional equivalence that covered two cases -
the function case and the non-function case.</p>
<p>We seemed to agree on a meaning that said that, for non-function values, two
values are extensionally equivalent if they are the <em>same value</em>, which is an
perhaps an ill-justified definition that may leave a bad taste in one's mouth,
but ultimately boils down to our intuitive notion that, yes, some values are
just the <em>same</em> and we can't really do much more than question that. For
instance, we can see that <code>(1, 2, &quot;hi&quot;)</code> and <code>(1, 2, &quot;hi&quot;)</code> are the &quot;same&quot;,
and neither are the same as <code>(2, 1, &quot;hello&quot;)</code>. For functions, however, we
decided on a slightly more appeasing definition that defined a function by
its <em>input-output</em> behavior. We restate the definition below:</p>
<blockquote>
<p><strong>[Extensional Equivalence (Functions)]</strong> We say two expressions <code>e : t1 -&gt; t2</code> and <code>e' : t1 -&gt; t2</code> for some types <code>t1</code> and <code>t2</code> are extensionally
equivalent if for all values <code>x : t1</code>, <code>e x</code> \( \cong \)<code>e' x</code>.</p>
</blockquote>
<p>It is our hope that we are now in a place to properly appreciate this
definition. For functions that have type <code>int -&gt; int</code>, this is a fairly
straightforward definition - these functions are extensionally equivalent if,
for every integer that we give them, they return the same int. However, what
about curried functions? Our definition, in light of this new concept, is that
curried functions are extensionally equivalent if <em>the functions that they
return are extensionally equivalent</em>.</p>
<p>No matter how deeply nested this currying takes place, this definition will
suffice. Types must be finite, so we must eventually reach a point where we can
say that values are &quot;the same&quot; (excluding the existence of non-equality types, perhaps).
We can see now that this idea of extensional equivalence is elegantly
compatible with the existence of curried functions, being a recursive definition
much in the same way that the <code>datatype</code>s that we declare or the <code>fun</code>ctions
that we write are.</p>
<h2 id="staging"><a class="header" href="#staging">Staging</a></h2>
<p>With curried functions, we can have much more deliberate control over <em>when</em> a
function does evaluation, particularly with respect to the inputs that it
receives.</p>
<p>Consider an analogy. Suppose you have math homework to do, but you left your
calculator at home. A more lazy-minded student might procrastinate, thinking
that they would only start once they got home, but a more pragmatically-minded
individual might simply start on the problems that don't require a calculator.
The idea of staging is that we can reap efficiency benefits for certain
problems when facing a scarcity of information, by simply doing computations
that require the arguments that are at hand first. We thus make a distinction
between functions that must have all of their arguments to do useful work, and
those who do not.</p>
<p>For instance, take the addition function.</p>
<pre><code class="language-sml">fun add (x : int, y : int) : int = x + y
</code></pre>
<p>This is not a function that we would categorize as being able to do &quot;useful
work&quot; with a single one of its arguments. Even if we were to curry <code>add</code>, with
only one <code>int</code> it can't really do anything but simply wait for the second
argument. In this case, the efficiency benefits are marginal at best. The
computations are somewhat &quot;dependent&quot; - we need access to both arguments in
order to do anything meaningful.</p>
<p>Consider a more contrived example:</p>
<pre><code class="language-sml">(* contrived : int -&gt; int -&gt; int *)
fun contrived x y =
    let
        val z = horrible_computation x (* this takes 3 years *)
    in
        y + z
    end
</code></pre>
<p>The function <code>contrived</code> takes in two arguments <code>x</code> and <code>y</code>. It then performs
some transformation on <code>x</code> using the function <code>horrible_computation</code> (which
takes 3 years to run, unfortunately), and then adds <code>y</code> to the result of that
transformation <code>z</code>.</p>
<p>Suppose that we are interested in computing the results of <code>contrived 4 2</code> and
<code>contrived 4 5</code>, for no reason other than because we can. Then, clearly
evaluation of those two expressions will take 3 years each (per
<code>horrible_computation</code>'s horrible computational nature) - totalling up to six
years! This is far too long, and we want to do better.</p>
<p>One thing that we note is that almost all of the work that we expended in
computing <code>contrived 4 2</code> and <code>contrived 4 5</code> was in evaluating
<code>horrible_computation 4</code>. This computation took us 3 years, but we repeated it
twice! In both of queries we made, we had to compute the exact same thing, which
led to major inefficiencies. The rest of the work of <code>contrived</code> was negligible
compared to the overhead of <code>horrible_computation</code>. It seems that we should be
able to achieve better results.</p>
<p>Consider the following definition instead:</p>
<pre><code class="language-sml">(* contrivedStaged : int -&gt; int -&gt; int *)
fun contrivedStaged x =
    let
        val z = horrible_computation x (* this still takes 3 years *)
    in
        fn y =&gt; y + z
    end
</code></pre>
<p>Now, we have <em>staged</em> <code>contrived</code>. <code>contrivedStaged</code> still has the same type as
<code>contrived</code>, but it behaves slightly differently. It is not too difficult to see
that <code>contrived</code> is extensionally equivalent to <code>contrivedStaged</code>, but we have
made a slightly more optimal change with regards to SML's semantics.</p>
<p>Now, instead of waiting for the second argument <code>y</code> to begin executing
<code>horrible_computation x</code>, <code>contrivedStaged</code> does so immediately after receiving
<code>x</code>. This is clearly better - there was no point to wait for <code>y</code> in the first
place, since <code>horrible_computation</code> does not depend on it. So now we can execute
the following code fragment:</p>
<pre><code class="language-sml">val intermediate = contrivedStaged 4
val ans1 = intermediate 2
val ans2 = intermediate 5
(* takes 3 years in total *)
</code></pre>
<p>We can do this because <code>contrivedStaged 4</code> computes the result of
<code>horrible_computation 4</code>, and then <em>stores the result</em> in the closure of the
function that it returns. This means that, in the scope of <code>intermediate</code>, it
contains the answer that was common to both of the expressions we wrote earlier.
Now, we can execute the step of <code>y + z</code> (which is nearly instantaneous), cutting
our runtime in half. Now, we can obtain the result of <code>contrived 4 2</code> and
<code>contrived 4 5</code> in only 3 years (though to evaluate both of those expressions
themselves would still take 6 years!).</p>
<p>It is important to note that currying is <em>not</em> the same thing as staging.
<code>contrived</code> was curried, but not staged optimally - we made a change that, even
though it had the same type, let us structure our queries in a more optimal
manner. This is an important idea with many applications, such as when building
up a data structure to make queries to, or in graphics when a lot of work must
first be done to preprocess the given data.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../concepts/hofs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../concepts/common.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../concepts/hofs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../concepts/common.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
