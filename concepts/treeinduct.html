<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tree Induction - SML Help</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A resource for learning SML">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Welcome!</a></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/install.html"><strong aria-hidden="true">1.1.</strong> Install & run SML</a></li><li class="chapter-item expanded "><a href="../start/syntax.html"><strong aria-hidden="true">1.2.</strong> Syntax Cheatsheet</a></li><li class="chapter-item expanded "><a href="../start/common.html"><strong aria-hidden="true">1.3.</strong> Common Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="../types/index.html"><strong aria-hidden="true">2.</strong> Types & Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/type.html"><strong aria-hidden="true">2.1.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/bool.html"><strong aria-hidden="true">2.1.1.</strong> bool</a></li><li class="chapter-item expanded "><a href="../types/int.html"><strong aria-hidden="true">2.1.2.</strong> int</a></li><li class="chapter-item expanded "><a href="../types/real.html"><strong aria-hidden="true">2.1.3.</strong> real</a></li><li class="chapter-item expanded "><a href="../types/string.html"><strong aria-hidden="true">2.1.4.</strong> string</a></li><li class="chapter-item expanded "><a href="../types/function.html"><strong aria-hidden="true">2.1.5.</strong> function types</a></li><li class="chapter-item expanded "><a href="../types/list.html"><strong aria-hidden="true">2.1.6.</strong> list</a></li><li class="chapter-item expanded "><a href="../types/options.html"><strong aria-hidden="true">2.1.7.</strong> options</a></li></ol></li><li class="chapter-item expanded "><a href="../types/sig.html"><strong aria-hidden="true">2.2.</strong> Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/basis.html"><strong aria-hidden="true">2.2.1.</strong> Basis Library Documentation</a></li><li class="chapter-item expanded "><a href="../types/aux-lib.html"><strong aria-hidden="true">2.2.2.</strong> Auxiliary Library Documentation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../debugging/index.html"><strong aria-hidden="true">3.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../debugging/errors.html"><strong aria-hidden="true">3.1.</strong> Common Errors</a></li><li class="chapter-item expanded "><a href="../debugging/hints.html"><strong aria-hidden="true">3.2.</strong> Debugging Hints</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/index.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/basic.html"><strong aria-hidden="true">4.1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/eval.html"><strong aria-hidden="true">4.1.1.</strong> Evaluation</a></li><li class="chapter-item expanded "><a href="../concepts/eeq.html"><strong aria-hidden="true">4.1.2.</strong> Extensional Equivalence</a></li><li class="chapter-item expanded "><a href="../concepts/patternmatch.html"><strong aria-hidden="true">4.1.3.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/recind.html"><strong aria-hidden="true">4.2.</strong> Recursion and Induction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/treeinduct.html" class="active"><strong aria-hidden="true">4.2.1.</strong> Tree Induction</a></li><li class="chapter-item expanded "><a href="../concepts/tail.html"><strong aria-hidden="true">4.2.2.</strong> Tail Recursion</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/analysis.html"><strong aria-hidden="true">4.3.</strong> Asymptotic Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/workspan.html"><strong aria-hidden="true">4.3.1.</strong> Work and Span</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/datatypes.html"><strong aria-hidden="true">4.4.</strong> Datatypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/poly.html"><strong aria-hidden="true">4.4.1.</strong> Parametric Polymorphism</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/hofs.html"><strong aria-hidden="true">4.5.</strong> Higher Order Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/curry.html"><strong aria-hidden="true">4.5.1.</strong> Currying and Staging</a></li><li class="chapter-item expanded "><a href="../concepts/common.html"><strong aria-hidden="true">4.5.2.</strong> Common HOFs and Partial Evaluation</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/control.html"><strong aria-hidden="true">4.6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/cps.html"><strong aria-hidden="true">4.6.1.</strong> Continuation Passing Style</a></li><li class="chapter-item expanded "><a href="../concepts/exn.html"><strong aria-hidden="true">4.6.2.</strong> Exceptions</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/mods.html"><strong aria-hidden="true">4.7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/mods.html"><strong aria-hidden="true">4.7.1.</strong> Basics and Ascription</a></li><li class="chapter-item expanded "><a href="../concepts/functors.html"><strong aria-hidden="true">4.7.2.</strong> Functors</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/apps.html"><strong aria-hidden="true">4.8.</strong> Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/sequences.html"><strong aria-hidden="true">4.8.1.</strong> Sequences</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/lazy.html"><strong aria-hidden="true">4.9.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../concepts/imperative.html"><strong aria-hidden="true">4.10.</strong> Imperative</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/index.html"><strong aria-hidden="true">5.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/basics.html"><strong aria-hidden="true">5.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="../examples/recursion.html"><strong aria-hidden="true">5.2.</strong> Recursion & Induction</a></li></ol></li><li class="chapter-item expanded "><a href="../about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SML Help</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="thinking-about-recursion-inductively"><a class="header" href="#thinking-about-recursion-inductively">Thinking About Recursion Inductively</a></h1>
<p><em>By Len Huang, August 2020</em></p>
<p>There's a strong association between mathematical induction and recursion, especially in SML. Often times, we'll be able to use similar vocabularies when describing SML problems and mathematical induction. In particular, we're going to be use the words <strong>base case, induction hypothesis, and induction step</strong> to describe both types of problems.</p>
<h2 id="inductive-intuition"><a class="header" href="#inductive-intuition">Inductive Intuition</a></h2>
<p>Approaching induction proofs can fall along the following line of logic:</p>
<ol>
<li>Solve the <strong>base cases</strong>.</li>
<li>Define the <strong>inductive hypothesis</strong>.</li>
<li>Assume the correctness of the <strong>inductive hypothesis</strong> to show the correctness of the <strong>inductive step</strong>.</li>
</ol>
<p>We can similarly apply this line of logic to solving problems with SML functions! Let's take a look at a common recursive problem. <code>treeSum</code> takes an int tree and returns the sum of all the integers in that tree. By the end of this, we'll be able to implement recursive functions with the following inductive logic:</p>
<pre><code class="language-sml">fun treeSum (Empty : int tree) : int = 0
  | treeSum (Node(L,x,R)) = treeSum(L) + treeSum(R) + x
</code></pre>
<blockquote>
<p>The <strong>base case</strong> for <code>treeSum</code> is that an <code>Empty</code> tree has a sum of 0. Let's define the <strong>inductive hypothesis</strong> to be that for some tree <code>T</code>, that <code>treeSum</code> is correct for its left subtree and right subtree. Define my <strong>inductive step</strong> to be for a tree <code>T = Node(L,x,R)</code>. By the definition of trees, I know that all integers in <code>T</code> are represented by the integers in <code>L</code>, <code>R</code>, and the integer <code>x</code>. If I sum all of these, I will get <code>treeSum(T)</code>. By assuming the <strong>IH</strong>, I can say that <code>treeSum L</code> and <code>treeSum R</code> are correct. Therefore, by math, I will say that <code>treeSum T = (treeSum L) + (treeSum R) + x</code> is correct by the above reasoning. As such, I've shown my <strong>IS</strong> to be correct, and thus the theorem that <code>treeSum T</code> is correct for all <code>T : int tree</code>.</p>
</blockquote>
<h2 id="an-exploration-of-tree-sums"><a class="header" href="#an-exploration-of-tree-sums">An Exploration of Tree Sums</a></h2>
<p>Let's define <code>treeSum</code>. This function should take in an <code>int tree</code> and return the sum of all the integers in that tree.</p>
<pre><code class="language-sml">datatype int tree = Empty | Node of int tree * int * int

fun treeSum (T : int tree) : int = ...
</code></pre>
<p>Note that in SML, the <code>tree</code> datatype is recursively defined. This is a good hint that we should be using recursive/inductive strategies to approach this problem. Consider the proof of the following theorem:</p>
<blockquote>
<p><strong>Theorem:</strong> For all <code>T : int tree</code>, <code>treeSum T</code> is correct.</p>
</blockquote>
<p>Let's not worry about formalizing this proof too much so that we can focus on the <strong>inductive intuition</strong> of it. If we were to prove this using induction, we'll need a <strong>(1) base case, (2) induction hypothesis, and (3) induction step.</strong></p>
<h3 id="1-solving-for-the-base-cases"><a class="header" href="#1-solving-for-the-base-cases">1. Solving for the Base Cases</a></h3>
<p>Let's first think about proving the base case: <code>T = Empty</code>. What does it mean for <code>treeSum Empty</code> to be correct? Well, an <code>Empty</code> tree does not have any nodes, and if there are no nodes, there are no <code>int</code> values. The sum of nothing is 0. Let's write that in a proof-like manner:</p>
<blockquote>
<p><strong>Base Case:</strong> <code>T = Empty</code></p>
<ul>
<li><code>treeSum(Empty) ==&gt; 0</code> because an <code>Empty</code> int tree does not have an int value.</li>
</ul>
</blockquote>
<p>That wasn't so bad! If we have an empty node, we can't have a value there, and so the sum is 0. Before we move on to solving the recursive step, let's tie in this idea of how recursion and induction are related. In our proof, we say that <code>treeSum Empty</code> is correct when it evaluates to 0. Let's use this as an answer to how to define the base case of our function:</p>
<pre><code class="language-sml">fun treeSum (Empty : int tree): int = 0
</code></pre>
<p>Nice job! We've leveraged inductive reasoning to help us define the base case for our recursive problem. Let's move on to something a little harder and may be less obvious than what we've done here.</p>
<h3 id="2-define-the-inductive-hypothesis"><a class="header" href="#2-define-the-inductive-hypothesis">2. Define the Inductive Hypothesis</a></h3>
<p>The next step in our proof is to define the inductive hypothesis. Here, we'll assume the correctness of a smaller part, then use that to prove the correctness of a bigger part. More specifically, we'll be using some ideas of <a href="https://smlhelp.github.io/#todolinktostructuralinductionsection">structural induction</a> for this problem. Let's elaborate more on that:</p>
<blockquote>
<p><strong>Induction Hypothesis:</strong> Assume for all <code>L : int tree</code> and <code>R : int tree</code> that <code>treeSum L</code> is correct and <code>treeSum R</code> is correct.</p>
</blockquote>
<p>Because we've shown our base case to be true, let's assume tha for the recursive structures (the left subtree <code>L</code> and the right subtree <code>R</code>), <code>treeSum</code> is correct. Just like how in induction we can use these nuggets of information to help us prove our <strong>inductive step</strong>, we can do the same to help us solve the SML function.</p>
<h3 id="3-assume-the-inductive-hypothesis-to-show-the-inductive-step"><a class="header" href="#3-assume-the-inductive-hypothesis-to-show-the-inductive-step">3. Assume the Inductive Hypothesis to Show the Inductive Step.</a></h3>
<p>What nuggets of information do we know from the previous step, and how can we use that to help us with inductive step? We assume that both <code>treeSum L</code> and <code>treeSum R</code> are correct by the <strong>inductive hypothesis (IH)</strong>. Since they are correct, their outputs represent the sum of all the integers in them. For <code>treeSum L</code> is the sum of all integers in the int tree <code>L</code> and for <code>treeSum R</code> is the sum of all integers in the int tree <code>R</code>.</p>
<p>We also know that since <code>L</code> and <code>R</code> are the left and right subtrees of <code>T</code>, by definition, they represent all nodes of <code>T</code> (except the root node). Then, to get sum of <code>T</code>, we just need the sum of <code>L</code>, <code>R</code>, and the value of the root node! Let's proof-ify this line of thought a bit more:</p>
<blockquote>
<p><strong>Inductive Step:</strong> <code>T = Node(L,x,R)</code></p>
<ul>
<li><code>treeSum L</code> is correct by <strong>IH</strong></li>
<li><code>treeSum R</code> is correct by <strong>IH</strong></li>
<li>&quot;All integers in <code>T</code>&quot; are represented by &quot;all integers in <code>L</code>&quot;, &quot;all integers in <code>R</code>&quot;, and <code>x</code> by definition of trees.</li>
<li>The sum of &quot;all integers in <code>T</code>&quot; is the sum of &quot;all integers in <code>L</code>, &quot;all integers in <code>R</code>&quot;, and the integer <code>x</code>.</li>
<li><code>treeSum T = (treeSum L) + (treeSum R) + x</code> by definition of <code>treeSum</code>.</li>
<li><code>(treeSum L) + (treeSum R) + x</code> is correct by math and above logic.</li>
<li><code>treeSum T</code> is correct by substitution.</li>
</ul>
</blockquote>
<p>Using the logic needed to complete the proof, we were able to arrive at how to implement our function! Let's translate the above logic into SML:</p>
<pre><code class="language-sml">fun treeSum (Empty : int tree) : int = 0
  | treeSum (Node(L,x,R)) = (treeSum L) + (treeSum R) + x
</code></pre>
<h2 id="qed"><a class="header" href="#qed">QED</a></h2>
<p>And like that, we're able to leverage mathematical induction to help us find the solution to part of an SML function. For some, this intuition is obvious. But for others, it isn't! A deep spiral of pure math and proving every single aspect of your code isn't usually needed. <strong>BUT</strong>, it will definitely be helpful to adopt this style of thinking when approaching more difficult and advanced recursion problems. Whenever you're trying to implement a recursive function in SML, remember to think inductively!</p>
<ol>
<li>Solve the <strong>base cases</strong>.</li>
<li>Define the <strong>inductive hypothesis</strong>.</li>
<li>Assume the correctness of the <strong>inductive hypothesis</strong> to show the correctness of the <strong>inductive step</strong>.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../concepts/recind.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../concepts/tail.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../concepts/recind.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../concepts/tail.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
