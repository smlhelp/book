<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Recursion and Induction - SML Help</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A resource for learning SML">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Welcome!</a></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/install.html"><strong aria-hidden="true">1.1.</strong> Install & run SML</a></li><li class="chapter-item expanded "><a href="../start/syntax.html"><strong aria-hidden="true">1.2.</strong> Syntax Cheatsheet</a></li><li class="chapter-item expanded "><a href="../start/common.html"><strong aria-hidden="true">1.3.</strong> Common Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="../types/index.html"><strong aria-hidden="true">2.</strong> Types & Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/type.html"><strong aria-hidden="true">2.1.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/bool.html"><strong aria-hidden="true">2.1.1.</strong> bool</a></li><li class="chapter-item expanded "><a href="../types/int.html"><strong aria-hidden="true">2.1.2.</strong> int</a></li><li class="chapter-item expanded "><a href="../types/real.html"><strong aria-hidden="true">2.1.3.</strong> real</a></li><li class="chapter-item expanded "><a href="../types/string.html"><strong aria-hidden="true">2.1.4.</strong> string</a></li><li class="chapter-item expanded "><a href="../types/function.html"><strong aria-hidden="true">2.1.5.</strong> function types</a></li><li class="chapter-item expanded "><a href="../types/list.html"><strong aria-hidden="true">2.1.6.</strong> list</a></li><li class="chapter-item expanded "><a href="../types/options.html"><strong aria-hidden="true">2.1.7.</strong> options</a></li></ol></li><li class="chapter-item expanded "><a href="../types/sig.html"><strong aria-hidden="true">2.2.</strong> Signatures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/basis.html"><strong aria-hidden="true">2.2.1.</strong> Basis Library Documentation</a></li><li class="chapter-item expanded "><a href="../types/aux-lib.html"><strong aria-hidden="true">2.2.2.</strong> Auxiliary Library Documentation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../debugging/index.html"><strong aria-hidden="true">3.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../debugging/errors.html"><strong aria-hidden="true">3.1.</strong> Common Errors</a></li><li class="chapter-item expanded "><a href="../debugging/hints.html"><strong aria-hidden="true">3.2.</strong> Debugging Hints</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/index.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/basic.html"><strong aria-hidden="true">4.1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/eval.html"><strong aria-hidden="true">4.1.1.</strong> Evaluation</a></li><li class="chapter-item expanded "><a href="../concepts/eeq.html"><strong aria-hidden="true">4.1.2.</strong> Extensional Equivalence</a></li><li class="chapter-item expanded "><a href="../concepts/patternmatch.html"><strong aria-hidden="true">4.1.3.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/recind.html" class="active"><strong aria-hidden="true">4.2.</strong> Recursion and Induction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/treeinduct.html"><strong aria-hidden="true">4.2.1.</strong> Tree Induction</a></li><li class="chapter-item expanded "><a href="../concepts/tail.html"><strong aria-hidden="true">4.2.2.</strong> Tail Recursion</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/analysis.html"><strong aria-hidden="true">4.3.</strong> Asymptotic Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/workspan.html"><strong aria-hidden="true">4.3.1.</strong> Work and Span</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/datatypes.html"><strong aria-hidden="true">4.4.</strong> Datatypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/poly.html"><strong aria-hidden="true">4.4.1.</strong> Parametric Polymorphism</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/hofs.html"><strong aria-hidden="true">4.5.</strong> Higher Order Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/curry.html"><strong aria-hidden="true">4.5.1.</strong> Currying and Staging</a></li><li class="chapter-item expanded "><a href="../concepts/common.html"><strong aria-hidden="true">4.5.2.</strong> Common HOFs and Partial Evaluation</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/control.html"><strong aria-hidden="true">4.6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/cps.html"><strong aria-hidden="true">4.6.1.</strong> Continuation Passing Style</a></li><li class="chapter-item expanded "><a href="../concepts/exn.html"><strong aria-hidden="true">4.6.2.</strong> Exceptions</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/mods.html"><strong aria-hidden="true">4.7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/mods.html"><strong aria-hidden="true">4.7.1.</strong> Basics and Ascription</a></li><li class="chapter-item expanded "><a href="../concepts/functors.html"><strong aria-hidden="true">4.7.2.</strong> Functors</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/apps.html"><strong aria-hidden="true">4.8.</strong> Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/sequences.html"><strong aria-hidden="true">4.8.1.</strong> Sequences</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/lazy.html"><strong aria-hidden="true">4.9.</strong> Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="../concepts/imperative.html"><strong aria-hidden="true">4.10.</strong> Imperative</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/index.html"><strong aria-hidden="true">5.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/basics.html"><strong aria-hidden="true">5.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="../examples/recursion.html"><strong aria-hidden="true">5.2.</strong> Recursion & Induction</a></li></ol></li><li class="chapter-item expanded "><a href="../about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SML Help</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="recursion-and-induction"><a class="header" href="#recursion-and-induction">Recursion and Induction</a></h1>
<p><em>By Jacob Neumann and Kaz Zhou, May 2022</em></p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Functional programmers have a particular affinity for the technique of <strong><em>recursion</em></strong>. Recursion is a way of writing functions: a given SML function either will or won't be <em>recursive</em>, and you can tell by looking at its declaration. Most of the main functions (i.e. the ones doing the &quot;real work&quot; of a problem) you write when programming in a functional style will be recursive, and <em>thinking recursively</em> is an essential skill for functional programming. Indeed, many of the features of functional programming languages like SML are designed to facilitate writing recursive functions. And — as we discuss more in <a href="datatypes.html">the page about datatypes</a> — we'll also be designing our data to make it easier to define recursive functions.</p>
<p>Going hand-in-hand with recursion is the proof technique of <strong><em>induction</em></strong>. Induction is a tool used throughout mathematics, and will form the basis for the mathematical analysis of functional programming. To prove the correctness of a recursive function, the natural (and often the only) choice is to make use of an inductive argument. Moreover, the form of the recursive function will suggest to us the structure of the inductive proof. In this article, we'll develop this connection for natural numbers and integer lists. The connection between recursion and induction for trees is explored <a href="treeinduct.html">here</a>, and for general datatypes <a href="datatypes.html">here</a>. A specific kind of recursion, called <em>tail recursion</em>, is discussed <a href="tail.html">here</a>.</p>
<h2 id="iterative-versus-recursive-thinking"><a class="header" href="#iterative-versus-recursive-thinking">Iterative versus Recursive Thinking</a></h2>
<p>Here's a simple programming problem: write a function <code>exp</code> which takes in a natural number (an integer greater than or equal to zero) and returns the quantity 2<sup>n</sup>. Of course, 2<sup>n</sup> is just the quantity 2 multiplied by itself n times (e.g. 2<sup>3</sup> is 2 times 2 times 2), with the edge case of 2<sup>0</sup>=1. Now, if we were asked to solve this problem in an <em>imperative programming language</em> (like Python or C), our first instinct might be to do something like this:</p>
<pre><code>int exp (int n) { 
    // requires: n&gt;=0
    i = 0;
    res = 1;
    while (i&lt;n) {
        res = res * 2;
        i = i+1;
    }
    return res;
}
</code></pre>
<p>This code directly solves the problem by &quot;multiplying by 2, n times&quot;: it establishes a &quot;result&quot; <code>res</code>, and then repeatedly mutates <code>res</code> by multiplying by 2. The counter <code>i</code> and the loop guard are there to make sure that we do this exactly n times, giving 2<sup>n</sup>. This is what's called an <strong><em>iterative solution</em></strong>: it consists of initializing our data (in this case, the values stored in <code>res</code> and <code>i</code>), performing a carefully-chosen sequence of mutations to it (doubling <code>res</code> and incrementing <code>i</code>), and then reading off the result (the value in <code>res</code>). It is this style of thinking which plays a central role in imperative programming. </p>
<p>Such a solution is not possible when doing functional programming. Indeed, pure functional programming languages (by definition[1]) do not have data &quot;cells&quot; which can be repeatedly modified (as <code>i</code> and <code>res</code> are in the preceding example): everything in a functional programming language is <strong><em>immutable</em></strong>. If <code>i</code> is a &quot;variable&quot; in a functional programming language, <code>i</code> has just one value and will never have a different value. So we must find a different way to solve this problem. Our solution will be to use <strong><em>recursion</em></strong>.</p>
<p>The following is a correct SML implementation of <code>exp</code>. Type annotations have been omitted, for clarity.</p>
<pre><code class="language-sml">(* exp : int -&gt; int
 * REQUIRES: n&gt;=0 
 * ENSURES: exp n == 2^n
 *)
fun exp 0 = 1
  | exp n = 2 * exp(n-1)
</code></pre>
<p>In the above code, we specify the <strong><em>base case</em></strong> that \( 2^0 = 1 \). Then, for inputs greater than 0,
we first compute \(2^{n-1} \) recursively, and then multiply 2 to it.
By &quot;recursively&quot;, we are assuming our code works for smaller inputs.
You can trace through a few test cases to convince yourself that these elegant two lines of code
indeed implement <code>exp</code>.</p>
<h2 id="proof-by-induction"><a class="header" href="#proof-by-induction">Proof by Induction</a></h2>
<p>Perhaps test cases are not enough for you, or you would like to see the deep connection
between induction and recursion. We can use the principle of mathematical induction to
<strong><em>prove</em></strong> that our <code>exp</code> code works. Here is the theorem we want to show. Recall that we use
<code>==</code> to denote two expressions being extensionally equivalent.</p>
<p><strong>Theorem:</strong> <code>exp n ==</code> \(2^n\) for all integer values \( n \geq 0 \).</p>
<p><strong>Proof:</strong> We use the principle of mathematical induction on <code>n</code>.</p>
<p><strong>Base case:</strong> We prove the theorem for <code>n = 0</code>.</p>
<p><code>exp 0 == 1</code> (by clause 1 of <code>exp</code>)</p>
<p><code>1 ==</code> \(2^0\) (math)</p>
<p>When dealing with arithmetic, we may justify proof steps by &quot;math&quot;.
Also, unless stated otherwise, we may assume SML implements basic mathematical operations correctly,
such as <code>+</code> and <code>*</code>.</p>
<p><strong>Inductive step:</strong> Let \( k \geq 0 \) be fixed. </p>
<p>Induction hypothesis: Assume that <code>exp k ==</code> \( 2^k \).</p>
<p>We want to show the theorem for <code>k+1</code>.</p>
<p><code>exp (k+1) == 2 * exp (k+1-1)</code> (by clause 2 of <code>exp</code>)</p>
<p><code>== 2 * exp k</code> (by math, \(k+1-1 \) <code>==</code> \(k \) )</p>
<p><code>== 2 *</code> \(2^k \) (by IH)</p>
<p><code>==</code> \(2^{k+1} \) (math)</p>
<p>This concludes the inductive step. </p>
<p>There are some things to note about this proof. First, every time we are evaluating SML code,
we justify which line of code allows us to make a particular step.
For example, when evaluating <code>exp (k+1)</code>, clause 2 of <code>exp</code> tells us that expression is
extensionally equivalent to <code>2 * exp (k+1-1)</code>. In fact, we can say <code>exp (k+1)</code> <strong><em>steps to</em></strong>
<code>2 * exp (k+1-1)</code>.</p>
<p>Second, we've abbreviated the induction hypothesis citation as &quot;IH&quot;. Furthermore, note how
we quantified the induction hypothesis: we are not assuming the theorem is true for all
natural numbers. Rather, we assume the theorem is true for some fixed <code>k</code> (which is \( \geq 0 \) ).</p>
<p>The principle of mathematical induction works due to a sort of domino effect. Let's notate
that the theorem is true for an integer <code>n</code> with \( P(n) \). In the above proof, we've shown
\( P(0) \), and that \( P(k) \implies P(k+1) \) for all \(k \geq 0 \).</p>
<p>For example, suppose we wanted to show \( P(2) \). We begin with \( P(0) \), and from the inductive step get
\( P(1) \). Then we apply the inductive step again to get \( P(2) \).</p>
<h2 id="the-type-of-natural-numbers"><a class="header" href="#the-type-of-natural-numbers">The &quot;Type&quot; of Natural Numbers</a></h2>
<p>We can <em>inductively</em> define the natural numbers using Peano's axioms:</p>
<p>\( 0 \) is a natural number.
For every natural number \( n \), \( S(n) \) is a natural number.</p>
<p>We call \( S(n) \) the successor of \( n \). It's just a fancy term for saying &quot;add 1&quot;.
Using these axioms, we can create a datatype that encapsulates natural numbers:</p>
<p><code>datatype nat = Zero | Succ of nat</code></p>
<p>This is essentially saying that <code>Zero : nat</code>, and
if some expression <code>e : nat</code>, then <code>Succ e</code> also has type <code>nat</code>.
For example, the number 3 corresponds to <code>Succ (Succ (Succ Zero))</code>.</p>
<p>Using this datatype, we can view the principle of mathematical induction merely as
<strong><em>structural induction</em></strong> on the <code>nat</code> datatype. As an example, let us rewrite <code>exp</code> as:</p>
<pre><code class="language-sml">(* exp' : nat -&gt; int
 * REQUIRES: true 
 * ENSURES: exp' n == 2^n
 *)
fun exp' Zero = 1
  | exp' (Succ n) = 2 * exp' n
</code></pre>
<p>The <code>ENSURES</code> is a bit sloppy because we haven't defined taking exponents of values of type <code>nat</code>,
but hopefully it has meaning for the code's reader. Now, if we wanted
to prove the correctness of this version of <code>exp'</code>, our base case would be showing
<code>exp' Zero == </code> \( 2^0 \). The inductive step would be showing that if <code>exp' n == </code> \( 2^n \), then
<code>exp' (Succ n) == </code> \( 2^{n+1} \). We'll omit the proof's details.</p>
<p>It may seem pointless to write the above code (indeed, it is not that practical). But, there
are two advantages: we don't need to restrict the inputs to <code>exp'</code> anymore, because negative numbers
are not natural numbers! So, we won't need to worry about looping forever, which would happen
in the earlier version of <code>exp</code> if we tried evaluating <code>exp ~1</code>. Also, the code portrays how
<strong><em>structural induction</em></strong> is basically an overpowered version of the principle of mathematical induction.</p>
<h2 id="strong-induction"><a class="header" href="#strong-induction">Strong induction</a></h2>
<p>For proofs on natural numbers, we can also make use of <strong><em>strong induction</em></strong>. With strong induction, the
inductive step is showing that for an arbitrary \( k &gt; 0 \),
\( P(0), P(1), \cdots, P(k-1) \) all together imply \( P(k) \). In other words, we can make use of
the theorem being true on all previous natural numbers, as our induction hypothesis.</p>
<p>With <code>exp</code>, the recursive case only references <code>exp (n-1)</code>, so the principle of mathematical induction
(also known as simple induction) is sufficient. But for code which references not just the previous number,
strong induction will be useful in proofs. For example, let us rewrite <code>exp</code> one last time:</p>
<pre><code class="language-sml">(* exp'' : int -&gt; int
 * REQUIRES: n &gt;= 0
 * ENSURES: exp'' n == 2^n
 *)
fun exp'' 0 = 1
  | exp'' 1 = 2
  | exp'' n = exp'' (n-1) + 2 * exp'' (n-2)
</code></pre>
<p>This code is needlessly complicated and inefficient, but it works.
It only exists for us to illustrate strong induction. The recursive case uses both <code>n-1</code> and <code>n-2</code>,
so we'll need strong induction to prove the correctness of <code>exp''</code>.</p>
<p>In addition, <strong>the proof mirrors the code.</strong> What we mean by this is, there should be a different case
for each clause of the function. Our proof would have a base case for both <code>n = 0</code> and <code>n = 1</code>, because
the first two clauses of <code>exp''</code> deal with those cases. Again, we omit the details of <code>exp''</code>'s correctness.</p>
<h2 id="list-recursion"><a class="header" href="#list-recursion">List Recursion</a></h2>
<p>Let's first define lists. Here are some examples of <code>int list</code>s:</p>
<pre><code class="language-sml">[1,5,1,5,0]
[42,~42]
[]
</code></pre>
<p>The last one is called the empty list.
We can also build lists containing other types:</p>
<pre><code class="language-sml">[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
</code></pre>
<p>Let <code>t</code> be some type. Intuitively, a value of type <code>t list</code> has a bunch of values of type <code>t</code> inside it (or is the empty list).
We can readily access the first element of the list (also called the <strong><em>head</em></strong>) by pattern matching with
the <code>::</code> operator (pronounced &quot;cons&quot;).</p>
<p>We can build lists using the constructors <code>[]</code> and <code>::</code>. The empty list, <code>[]</code>, is the base case.
The inductive case is <code>::</code>, which is an infix operator that takes in <code>t * t list</code> and creates a <code>t list</code>.
For example, <code>1::[]</code> is the list <code>[1]</code>, and <code>1::[2,3]</code> is the list <code>[1,2,3]</code>. It adds an element to
the front of a list.</p>
<p>The inductive definition of lists means that it's natural to write recursive functions on lists.
We can write a function that computes the length of a list as follows:</p>
<pre><code class="language-sml">(* length : int list -&gt; int
 * REQUIRES: true
 * ENSURES: length L returns the number of values in L.
 *)
fun length [] = 0
  | length (x::xs) = 1 + length xs
</code></pre>
<p>Our function takes in an <code>int list</code>, and outputs an <code>int</code>. For the empty list, we return 0 straight away.
A nonempty list has the form <code>x::xs</code>, where <code>x</code> is the first element of the list, and <code>xs</code> is the rest of the list.
(Perhaps <code>xs</code> means there are many <code>x</code>'s, or it's a homophone of &quot;excess&quot;. We will never know.)
In the recursive case, we calculate the length of the rest of the list by evaluating <code>length xs</code>,
and then add 1 to account for <code>x</code> being in the original list as well.</p>
<p>Now, let's write a slightly more complex function, <code>@</code>, which appends together two lists. It is an infix operator,
and to notate this we write <code>infix @</code>. Here are examples of using <code>@</code>:</p>
<pre><code class="language-sml">[1,2,3] @ [4,5,6] == [1,2,3,4,5,6]
[&quot;s&quot;, &quot;o&quot;] @ [&quot;u&quot;, &quot;p&quot;] == [&quot;s&quot;, &quot;o&quot;, &quot;u&quot;, &quot;p&quot;]
[] @ [] == []
</code></pre>
<p>Here is the implementation:</p>
<pre><code class="language-sml">(* @ : int list * int list -&gt; int list
 * REQUIRES: true
 * ENSURES: A @ B evaluates to a list with 
 * all the elements of A, then all the elements of B
 *)
infix @

fun [] @ B = B
  | (x::xs) @ B = x::(xs @ B)
</code></pre>
<p>(Note you will not be able to run this code in the smlnj REPL, because <code>@</code> is a keyword that we cannot overwrite.
However, you may give the function a different name for testing purposes.)</p>
<p>Our <code>@</code> function recurses on the left list. If it's empty, we just return the right list.
If it's nonempty, we evaluate <code>xs @ B</code>, and then tack on <code>x</code> to the beginning.</p>
<h2 id="list-induction"><a class="header" href="#list-induction">List Induction</a></h2>
<p>Let's consider proofs by structural induction on lists. Let's say we want to show that some property \( P \)
is true for all values of type <code>t list</code>. It suffices to show the following:</p>
<p><strong>Base case:</strong> \( P( \) <code>[]</code> \() \). In other words, we show the theorem holds for the empty list.</p>
<p><strong>Inductive step:</strong> For any value <code>xs : t list</code>, and any value <code>x : t</code>,
\( P( \) <code>xs</code> \() \implies P( \) <code>x::xs</code> \() \).</p>
<p>For example, if the type <code>t</code> is <code>int</code>, then \( P( \) <code>[1,2]</code> \( ) \) is true because
the base case tells us \( P( \) <code>[]</code> \( ) \), and then one application of the inductive step gets us
\( P( \) <code>2::[]</code> \( ) \), and one more application of the inductive step gets us
\( P( \) <code>1::2::[]</code> \( ) \). Remember that <code>1::2::[]</code> is the same thing as <code>[1,2]</code>.</p>
<h3 id="proving-the-totality-of-length"><a class="header" href="#proving-the-totality-of-length">Proving the totality of <code>length</code></a></h3>
<p>Recall the code of <code>length</code>, which has type <code>int list -&gt; int</code>:</p>
<pre><code class="language-sml">fun length [] = 0
  | length (x::xs) = 1 + length xs
</code></pre>
<p><strong>Theorem:</strong> for all values <code>L : int list</code>, <code>length L</code> evaluates to a value.</p>
<p>In other words, the theorem states that the function <code>length</code> is <strong><em>total</em></strong>.
We'll use <code>==&gt;</code> throughout the proof to denote &quot;steps to&quot;, as we are trying to show <code>length L</code>
evaluates to a value. </p>
<blockquote>
<p>Be careful not to mix up <code>==&gt;</code> and <code>==</code>. For example, <code>4 == 2+2</code> is true
because the expressions are extensionally equivalent, but no compiler in their right mind would
step <code>4</code> to <code>2+2</code>. Therefore <code>4 ==&gt; 2+2</code> is nonsense.)</p>
</blockquote>
<blockquote>
<p>Furthermore, &quot;steps to&quot;, or <code>==&gt;</code>, is very different from \( \implies \). 
<code>==&gt;</code> is used when talking about expressions in SML.
\( \implies \) is not particular to SML, since it's the symbol for logical implication.</p>
</blockquote>
<p><strong>Proof:</strong> We'll use structural induction on <code>L</code>.</p>
<p><strong>Base case:</strong> We prove the theorem when <code>L</code> is <code>[]</code>.</p>
<p><code>length [] ==&gt; 0</code> by clause 1 of <code>length</code>. 0 is a value, as desired.</p>
<p><strong>Inductive step:</strong> Let <code>xs</code> be some value of type <code>int list</code>.</p>
<p>Induction hypothesis: Assume that <code>length xs</code> evaluates to a value.</p>
<p>Let <code>x : int</code> be an arbitrary value. We want to show that <code>length (x::xs)</code> evaluates to a value.</p>
<p><code>length (x::xs) ==&gt; 1 + length xs</code> (by clause 2 of <code>length</code>)</p>
<p><code>==&gt; 1 + v</code> (by IH, <code>length xs ==&gt; v</code> for some value <code>v</code>)</p>
<p>Now, <code>1 + v</code> evaluates to a value (we assume that SML implements operators like <code>+</code> correctly, and we
do not care about overflow). This concludes the inductive step.</p>
<p>Note how powerful structural induction is! We've proven a fact about <em>all</em> values of type <code>int list</code>
(there are very many such values). To conquer the infinite, we only needed to prove a base case
and the inductive step, due to the inductive nature of lists.</p>
<p>Let's now sketch out a proof that <code>@</code> is total (that is, for all values <code>A : int list</code> and <code>B : int list</code>,
<code>A @ B</code> evaluates to a value). Recall the code of <code>@</code>:</p>
<pre><code>fun [] @ B = B
  | (x::xs) @ B = x::(xs @ B)
</code></pre>
<p>Note that the code of <code>@</code> does not care what the right list, <code>B</code>, looks like!
We only case on whether the left list is empty or nonempty.
As such, it makes sense that a proof about <code>@</code> would use structural induction on the left list, <code>A</code>.
(Again, <strong>the proof mirrors the code</strong>!)</p>
<p>The base case would involve proving <code>[] @ B</code> evaluates to a value, for any <code>B : int list</code>.</p>
<p>The inductive step would roughly be: given an arbitrary <code>xs : int list</code> and <code>x : int</code>, prove that
for all <code>B : int list</code>, the fact that <code>xs @ B</code> evaluates to a value implies that 
<code>(x::xs) @ B</code> evaluates to a value.</p>
<p>We leave the proof's details as an exercise, but they are quite similar to the proof that <code>length</code> is total.
The main difference is we are letting <code>B</code> be an arbitrary value of type <code>int list</code> throughout the entire proof.</p>
<h2 id="takeaways"><a class="header" href="#takeaways">Takeaways</a></h2>
<p>Functional programming lends itself very nicely to recursive code, rather than iterative code.
Induction is a powerful technique for proving theorems about recursive functions.
There are different types of induction, useful for functions on various types.
For natural numbers, we may use simple or strong induction. (Or, we can be fancy
and consider the datatype of natural numbers, <code>nat</code>, and use structural induction.)
For lists and other recursively defined datatypes, structural induction is the way to go.</p>
<blockquote>
<p>Not all proofs about SML code need induction!
Recursion and induction go hand in hand. So, if you were tasked with
proving a theorem on a <em>non-recursive</em> function, there will be no need for induction!</p>
</blockquote>
<p>We also saw how <strong>proofs mirror the code</strong>. Non-recursive clauses in functions (that is,
where the function does not call itself) correspond to base cases in proofs. Recursive clauses
in functions correspond to inductive steps. (When we move into more complex datatypes
than lists, which may have multiple inductive cases, there may be multiple inductive steps!)
The deep connection between recursion and induction is just another example of how
the fields of computer science and mathematics are closely tied.</p>
<h3 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h3>
<ul>
<li>[1] SML actually does have mutable data cells called <code>ref</code>s. For this reason, SML is not (strictly speaking) a <em>pure</em> functional programming language. But we primarily program with the parts of SML which are pure, and therefore don't have to worry about <em>side effects</em>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../concepts/patternmatch.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../concepts/treeinduct.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../concepts/patternmatch.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../concepts/treeinduct.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
